System.register('ionic/components', ['./components/app/app', './components/app/id', './components/action-sheet/action-sheet', './components/alert/alert', './components/blur/blur', './components/button/button', './components/checkbox/checkbox', './components/content/content', './components/icon/icon', './components/item/item', './components/item/item-sliding', './components/menu/menu', './components/menu/menu-types', './components/menu/menu-toggle', './components/menu/menu-close', './components/text-input/text-input', './components/label/label', './components/list/list', './components/show-hide-when/show-hide-when', './components/modal/modal', './components/nav/nav', './components/nav/nav-controller', './components/nav/view-controller', './components/nav/nav-push', './components/nav/nav-router', './components/navbar/navbar', './components/overlay/overlay', './components/slides/slides', './components/radio/radio', './components/scroll/scroll', './components/scroll/pull-to-refresh', './components/searchbar/searchbar', './components/segment/segment', './components/tabs/tabs', './components/tabs/tab', './components/tap-click/tap-click', './components/toggle/toggle', './components/toolbar/toolbar'], function (_export) {
  'use strict';

  return {
    setters: [function (_componentsAppApp) {
      for (var _key in _componentsAppApp) {
        if (_key !== 'default') _export(_key, _componentsAppApp[_key]);
      }
    }, function (_componentsAppId) {
      for (var _key2 in _componentsAppId) {
        if (_key2 !== 'default') _export(_key2, _componentsAppId[_key2]);
      }
    }, function (_componentsActionSheetActionSheet) {
      for (var _key3 in _componentsActionSheetActionSheet) {
        if (_key3 !== 'default') _export(_key3, _componentsActionSheetActionSheet[_key3]);
      }
    }, function (_componentsAlertAlert) {
      for (var _key4 in _componentsAlertAlert) {
        if (_key4 !== 'default') _export(_key4, _componentsAlertAlert[_key4]);
      }
    }, function (_componentsBlurBlur) {
      for (var _key5 in _componentsBlurBlur) {
        if (_key5 !== 'default') _export(_key5, _componentsBlurBlur[_key5]);
      }
    }, function (_componentsButtonButton) {
      for (var _key6 in _componentsButtonButton) {
        if (_key6 !== 'default') _export(_key6, _componentsButtonButton[_key6]);
      }
    }, function (_componentsCheckboxCheckbox) {
      for (var _key7 in _componentsCheckboxCheckbox) {
        if (_key7 !== 'default') _export(_key7, _componentsCheckboxCheckbox[_key7]);
      }
    }, function (_componentsContentContent) {
      for (var _key8 in _componentsContentContent) {
        if (_key8 !== 'default') _export(_key8, _componentsContentContent[_key8]);
      }
    }, function (_componentsIconIcon) {
      for (var _key9 in _componentsIconIcon) {
        if (_key9 !== 'default') _export(_key9, _componentsIconIcon[_key9]);
      }
    }, function (_componentsItemItem) {
      for (var _key10 in _componentsItemItem) {
        if (_key10 !== 'default') _export(_key10, _componentsItemItem[_key10]);
      }
    }, function (_componentsItemItemSliding) {
      for (var _key11 in _componentsItemItemSliding) {
        if (_key11 !== 'default') _export(_key11, _componentsItemItemSliding[_key11]);
      }
    }, function (_componentsMenuMenu) {
      for (var _key12 in _componentsMenuMenu) {
        if (_key12 !== 'default') _export(_key12, _componentsMenuMenu[_key12]);
      }
    }, function (_componentsMenuMenuTypes) {
      for (var _key13 in _componentsMenuMenuTypes) {
        if (_key13 !== 'default') _export(_key13, _componentsMenuMenuTypes[_key13]);
      }
    }, function (_componentsMenuMenuToggle) {
      for (var _key14 in _componentsMenuMenuToggle) {
        if (_key14 !== 'default') _export(_key14, _componentsMenuMenuToggle[_key14]);
      }
    }, function (_componentsMenuMenuClose) {
      for (var _key15 in _componentsMenuMenuClose) {
        if (_key15 !== 'default') _export(_key15, _componentsMenuMenuClose[_key15]);
      }
    }, function (_componentsTextInputTextInput) {
      for (var _key16 in _componentsTextInputTextInput) {
        if (_key16 !== 'default') _export(_key16, _componentsTextInputTextInput[_key16]);
      }
    }, function (_componentsLabelLabel) {
      for (var _key17 in _componentsLabelLabel) {
        if (_key17 !== 'default') _export(_key17, _componentsLabelLabel[_key17]);
      }
    }, function (_componentsListList) {
      for (var _key18 in _componentsListList) {
        if (_key18 !== 'default') _export(_key18, _componentsListList[_key18]);
      }
    }, function (_componentsShowHideWhenShowHideWhen) {
      for (var _key19 in _componentsShowHideWhenShowHideWhen) {
        if (_key19 !== 'default') _export(_key19, _componentsShowHideWhenShowHideWhen[_key19]);
      }
    }, function (_componentsModalModal) {
      for (var _key20 in _componentsModalModal) {
        if (_key20 !== 'default') _export(_key20, _componentsModalModal[_key20]);
      }
    }, function (_componentsNavNav) {
      for (var _key21 in _componentsNavNav) {
        if (_key21 !== 'default') _export(_key21, _componentsNavNav[_key21]);
      }
    }, function (_componentsNavNavController) {
      for (var _key22 in _componentsNavNavController) {
        if (_key22 !== 'default') _export(_key22, _componentsNavNavController[_key22]);
      }
    }, function (_componentsNavViewController) {
      for (var _key23 in _componentsNavViewController) {
        if (_key23 !== 'default') _export(_key23, _componentsNavViewController[_key23]);
      }
    }, function (_componentsNavNavPush) {
      for (var _key24 in _componentsNavNavPush) {
        if (_key24 !== 'default') _export(_key24, _componentsNavNavPush[_key24]);
      }
    }, function (_componentsNavNavRouter) {
      for (var _key25 in _componentsNavNavRouter) {
        if (_key25 !== 'default') _export(_key25, _componentsNavNavRouter[_key25]);
      }
    }, function (_componentsNavbarNavbar) {
      for (var _key26 in _componentsNavbarNavbar) {
        if (_key26 !== 'default') _export(_key26, _componentsNavbarNavbar[_key26]);
      }
    }, function (_componentsOverlayOverlay) {
      for (var _key27 in _componentsOverlayOverlay) {
        if (_key27 !== 'default') _export(_key27, _componentsOverlayOverlay[_key27]);
      }
    }, function (_componentsSlidesSlides) {
      for (var _key28 in _componentsSlidesSlides) {
        if (_key28 !== 'default') _export(_key28, _componentsSlidesSlides[_key28]);
      }
    }, function (_componentsRadioRadio) {
      for (var _key29 in _componentsRadioRadio) {
        if (_key29 !== 'default') _export(_key29, _componentsRadioRadio[_key29]);
      }
    }, function (_componentsScrollScroll) {
      for (var _key30 in _componentsScrollScroll) {
        if (_key30 !== 'default') _export(_key30, _componentsScrollScroll[_key30]);
      }
    }, function (_componentsScrollPullToRefresh) {
      for (var _key31 in _componentsScrollPullToRefresh) {
        if (_key31 !== 'default') _export(_key31, _componentsScrollPullToRefresh[_key31]);
      }
    }, function (_componentsSearchbarSearchbar) {
      for (var _key32 in _componentsSearchbarSearchbar) {
        if (_key32 !== 'default') _export(_key32, _componentsSearchbarSearchbar[_key32]);
      }
    }, function (_componentsSegmentSegment) {
      for (var _key33 in _componentsSegmentSegment) {
        if (_key33 !== 'default') _export(_key33, _componentsSegmentSegment[_key33]);
      }
    }, function (_componentsTabsTabs) {
      for (var _key34 in _componentsTabsTabs) {
        if (_key34 !== 'default') _export(_key34, _componentsTabsTabs[_key34]);
      }
    }, function (_componentsTabsTab) {
      for (var _key35 in _componentsTabsTab) {
        if (_key35 !== 'default') _export(_key35, _componentsTabsTab[_key35]);
      }
    }, function (_componentsTapClickTapClick) {
      for (var _key36 in _componentsTapClickTapClick) {
        if (_key36 !== 'default') _export(_key36, _componentsTapClickTapClick[_key36]);
      }
    }, function (_componentsToggleToggle) {
      for (var _key37 in _componentsToggleToggle) {
        if (_key37 !== 'default') _export(_key37, _componentsToggleToggle[_key37]);
      }
    }, function (_componentsToolbarToolbar) {
      for (var _key38 in _componentsToolbarToolbar) {
        if (_key38 !== 'default') _export(_key38, _componentsToolbarToolbar[_key38]);
      }
    }],
    execute: function () {}
  };
});
System.register('ionic/ionic', ['./config/modes', './platform/registry', './animations/builtins', './animations/ios-transition', './animations/md-transition', './config/bootstrap', './config/config', './config/directives', './decorators/config-component', './decorators/app', './decorators/page', './components', './platform/platform', './platform/storage', './util/click-block', './util/events', './util/keyboard', './animations/animation', './translation/translate', './translation/translate_pipe'], function (_export) {
  'use strict';

  return {
    setters: [function (_configModes) {}, function (_platformRegistry) {}, function (_animationsBuiltins) {}, function (_animationsIosTransition) {}, function (_animationsMdTransition) {}, function (_configBootstrap) {
      for (var _key in _configBootstrap) {
        if (_key !== 'default') _export(_key, _configBootstrap[_key]);
      }
    }, function (_configConfig) {
      for (var _key2 in _configConfig) {
        if (_key2 !== 'default') _export(_key2, _configConfig[_key2]);
      }
    }, function (_configDirectives) {
      for (var _key3 in _configDirectives) {
        if (_key3 !== 'default') _export(_key3, _configDirectives[_key3]);
      }
    }, function (_decoratorsConfigComponent) {
      for (var _key4 in _decoratorsConfigComponent) {
        if (_key4 !== 'default') _export(_key4, _decoratorsConfigComponent[_key4]);
      }
    }, function (_decoratorsApp) {
      for (var _key5 in _decoratorsApp) {
        if (_key5 !== 'default') _export(_key5, _decoratorsApp[_key5]);
      }
    }, function (_decoratorsPage) {
      for (var _key6 in _decoratorsPage) {
        if (_key6 !== 'default') _export(_key6, _decoratorsPage[_key6]);
      }
    }, function (_components) {
      for (var _key7 in _components) {
        if (_key7 !== 'default') _export(_key7, _components[_key7]);
      }
    }, function (_platformPlatform) {
      for (var _key8 in _platformPlatform) {
        if (_key8 !== 'default') _export(_key8, _platformPlatform[_key8]);
      }
    }, function (_platformStorage) {
      for (var _key9 in _platformStorage) {
        if (_key9 !== 'default') _export(_key9, _platformStorage[_key9]);
      }
    }, function (_utilClickBlock) {
      for (var _key10 in _utilClickBlock) {
        if (_key10 !== 'default') _export(_key10, _utilClickBlock[_key10]);
      }
    }, function (_utilEvents) {
      for (var _key11 in _utilEvents) {
        if (_key11 !== 'default') _export(_key11, _utilEvents[_key11]);
      }
    }, function (_utilKeyboard) {
      for (var _key12 in _utilKeyboard) {
        if (_key12 !== 'default') _export(_key12, _utilKeyboard[_key12]);
      }
    }, function (_animationsAnimation) {
      for (var _key13 in _animationsAnimation) {
        if (_key13 !== 'default') _export(_key13, _animationsAnimation[_key13]);
      }
    }, function (_translationTranslate) {
      for (var _key14 in _translationTranslate) {
        if (_key14 !== 'default') _export(_key14, _translationTranslate[_key14]);
      }
    }, function (_translationTranslate_pipe) {
      for (var _key15 in _translationTranslate_pipe) {
        if (_key15 !== 'default') _export(_key15, _translationTranslate_pipe[_key15]);
      }
    }],
    execute: function () {}
  };
});
System.register('ionic/util', ['./util/dom', './util/util'], function (_export) {
  'use strict';

  var domUtil, dom;
  return {
    setters: [function (_utilDom) {
      domUtil = _utilDom;
    }, function (_utilUtil) {
      for (var _key in _utilUtil) {
        if (_key !== 'default') _export(_key, _utilUtil[_key]);
      }
    }],
    execute: function () {
      dom = domUtil;

      _export('dom', dom);
    }
  };
});
System.register('ionic/components/ion', ['../util/dom'], function (_export) {
    /**
     * Base class for all Ionic components. Exposes some common functionality
     * that all Ionic components need, such as accessing underlying native elements and
     * sending/receiving app-level events.
     */
    'use strict';

    var dom, Ion;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilDom) {
            dom = _utilDom;
        }],
        execute: function () {
            Ion = (function () {
                function Ion(elementRef, config) {
                    _classCallCheck(this, Ion);

                    this.elementRef = elementRef;
                    this.config = config;
                }

                _createClass(Ion, [{
                    key: 'ngOnInit',
                    value: function ngOnInit() {
                        var cls = this.constructor;
                        if (cls.defaultInputs && this.config) {
                            for (var prop in cls.defaultInputs) {
                                // Priority:
                                // ---------
                                // 1) Value set from within constructor
                                // 2) Value set from the host element's attribute
                                // 3) Value set by the users global config
                                // 4) Value set by the default mode/platform config
                                // 5) Value set from the component's default
                                if (this[prop]) {
                                    // this property has already been set on the instance
                                    // could be from the user setting the element's attribute
                                    // or from the user setting it within the constructor
                                    continue;
                                }
                                // get the property values from a global user/platform config
                                var configVal = this.config.get(prop);
                                if (configVal) {
                                    this[prop] = configVal;
                                    continue;
                                }
                                // wasn't set yet, so go with property's default value
                                this[prop] = cls.defaultInputs[prop];
                            }
                        }
                    }
                }, {
                    key: 'getElementRef',
                    value: function getElementRef() {
                        return this.elementRef;
                    }
                }, {
                    key: 'getNativeElement',
                    value: function getNativeElement() {
                        return this.elementRef.nativeElement;
                    }
                }, {
                    key: 'getDimensions',
                    value: function getDimensions() {
                        return dom.getDimensions(this);
                    }
                }, {
                    key: 'width',
                    value: function width() {
                        return dom.getDimensions(this).width;
                    }
                }, {
                    key: 'height',
                    value: function height() {
                        return dom.getDimensions(this).height;
                    }
                }]);

                return Ion;
            })();

            _export('Ion', Ion);
        }
    };
});
System.register('ionic/animations/animation', ['../util/dom', '../util/util'], function (_export) {
    /**
      Animation Steps/Process
      -----------------------
    
     - Construct animation (doesn't start)
     - Client play()'s animation, returns promise
     - Add before classes to elements
     - Remove before classes from elements
     - Elements staged in "from" effect w/ inline styles
     - Call onReady()
     - Wait for RENDER_DELAY milliseconds (give browser time to render)
     - Call onPlay()
     - Run from/to animation on elements
     - Animations finish async
     - Set inline styles w/ the "to" effects on elements
     - Add after classes to elements
     - Remove after classes from elements
     - Call onFinish()
     - Resolve play()'s promise
    **/
    /**
     * @private
    **/
    'use strict';

    var CSS, rafFrames, extend, Animation, Animate, TRANSFORMS, ANIMATE_PROPERTIES, CUBIC_BEZIERS, EASING_FN, AnimationRegistry;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function insertEffects(effects, fromEffect, toEffect, easingConfig) {
        easingConfig.opts = easingConfig.opts || {};
        var increment = easingConfig.opts.increment || 0.04;
        var easingFn = EASING_FN[easingConfig.name];
        var pos = undefined,
            tweenEffect = undefined,
            addEffect = undefined,
            property = undefined,
            toProperty = undefined,
            fromValue = undefined,
            diffValue = undefined;
        for (pos = increment; pos <= 1 - increment; pos += increment) {
            tweenEffect = {};
            addEffect = false;
            for (property in toEffect) {
                toProperty = toEffect[property];
                if (toProperty.tween) {
                    fromValue = fromEffect[property].num;
                    diffValue = toProperty.num - fromValue;
                    tweenEffect[property] = {
                        value: roundValue(easingFn(pos, easingConfig.opts) * diffValue + fromValue) + toProperty.unit
                    };
                    addEffect = true;
                }
            }
            if (addEffect) {
                effects.push(convertProperties(tweenEffect));
            }
        }
    }
    function parseEffect(inputEffect) {
        var val = undefined,
            r = undefined,
            num = undefined,
            property = undefined;
        var outputEffect = {};
        for (property in inputEffect) {
            val = inputEffect[property];
            r = val.toString().match(/(^-?\d*\.?\d*)(.*)/);
            num = parseFloat(r[1]);
            outputEffect[property] = {
                value: val,
                num: num,
                unit: r[0] != r[2] ? r[2] : '',
                tween: !isNaN(num) && ANIMATE_PROPERTIES.indexOf(property) > -1
            };
        }
        return outputEffect;
    }
    function convertProperties(inputEffect) {
        var outputEffect = {};
        var transforms = [];
        var value = undefined,
            property = undefined;
        for (property in inputEffect) {
            value = inputEffect[property].value;
            if (TRANSFORMS.indexOf(property) > -1) {
                transforms.push(property + '(' + value + ')');
            } else {
                outputEffect[property] = value;
            }
        }
        if (transforms.length) {
            transforms.push('translateZ(0px)');
            outputEffect.transform = transforms.join(' ');
        }
        return outputEffect;
    }
    function inlineStyle(ele, effect) {
        if (ele && effect) {
            var transforms = [];
            var value = undefined,
                property = undefined;
            for (property in effect) {
                value = effect[property].value;
                if (TRANSFORMS.indexOf(property) > -1) {
                    transforms.push(property + '(' + value + ')');
                } else {
                    ele.style[property] = value;
                }
            }
            if (transforms.length) {
                transforms.push('translateZ(0px)');
                ele.style[CSS.transform] = transforms.join(' ');
            }
        }
    }
    function roundValue(val) {
        return Math.round(val * 10000) / 10000;
    }

    function parallel(tasks, done) {
        var l = tasks.length;
        if (!l) {
            done && done();
            return;
        }
        var completed = 0;
        function taskCompleted() {
            completed++;
            if (completed === l) {
                done && done();
            }
        }
        for (var i = 0; i < l; i++) {
            tasks[i](taskCompleted);
        }
    }
    return {
        setters: [function (_utilDom) {
            CSS = _utilDom.CSS;
            rafFrames = _utilDom.rafFrames;
        }, function (_utilUtil) {
            extend = _utilUtil.extend;
        }],
        execute: function () {
            Animation = (function () {
                function Animation(ele) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, Animation);

                    this.reset();
                    this._opts = extend({
                        renderDelay: 16
                    }, opts);
                    this.elements(ele);
                    if (!document.documentElement.animate) {
                        console.error('Web Animations polyfill missing');
                    }
                }

                /**
                 * @private
                **/

                _createClass(Animation, [{
                    key: 'reset',
                    value: function reset() {
                        this._el = [];
                        this._chld = [];
                        this._ani = [];
                        this._bfAdd = [];
                        this._bfSty = {};
                        this._bfRmv = [];
                        this._afAdd = [];
                        this._afRmv = [];
                        this._readys = [];
                        this._plays = [];
                        this._finishes = [];
                    }
                }, {
                    key: 'elements',
                    value: function elements(ele) {
                        if (ele) {
                            if (typeof ele === 'string') {
                                // string query selector
                                ele = document.querySelectorAll(ele);
                            }
                            if (ele.length) {
                                // array of elements
                                for (var i = 0; i < ele.length; i++) {
                                    this.addElement(ele[i]);
                                }
                            } else {
                                // single element
                                this.addElement(ele);
                            }
                        }
                        return this;
                    }
                }, {
                    key: 'addElement',
                    value: function addElement(ele) {
                        // ensure only HTML Element nodes
                        if (ele) {
                            if (ele.nativeElement) {
                                // angular ElementRef
                                ele = ele.nativeElement;
                            }
                            if (ele.nodeType === 1) {
                                this._el.push(ele);
                            }
                        }
                    }
                }, {
                    key: 'parent',
                    value: function parent(parentAnimation) {
                        this._parent = parentAnimation;
                        return this;
                    }
                }, {
                    key: 'add',
                    value: function add(childAnimations) {
                        var _childAnimations = Array.isArray(childAnimations) ? childAnimations : arguments;
                        for (var i = 0; i < _childAnimations.length; i++) {
                            _childAnimations[i].parent(this);
                            this._chld.push(_childAnimations[i]);
                        }
                        return this;
                    }
                }, {
                    key: 'duration',
                    value: function duration(value) {
                        if (arguments.length) {
                            this._duration = value;
                            return this;
                        }
                        return this._duration || this._parent && this._parent.duration() || 0;
                    }
                }, {
                    key: 'clearDuration',
                    value: function clearDuration() {
                        this._duration = null;
                        for (var i = 0, l = this._chld.length; i < l; i++) {
                            this._chld[i].clearDuration();
                        }
                    }
                }, {
                    key: 'easing',
                    value: function easing(name, opts) {
                        if (arguments.length) {
                            this._easing = {
                                name: name,
                                opts: opts
                            };
                            return this;
                        }
                        return this._easing || this._parent && this._parent.easing();
                    }
                }, {
                    key: 'playbackRate',
                    value: function playbackRate(value) {
                        if (arguments.length) {
                            this._rate = value;
                            var i = undefined;
                            for (i = 0; i < this._chld.length; i++) {
                                this._chld[i].playbackRate(value);
                            }
                            for (i = 0; i < this._ani.length; i++) {
                                this._ani[i].playbackRate(value);
                            }
                            return this;
                        }
                        return typeof this._rate !== 'undefined' ? this._rate : this._parent && this._parent.playbackRate();
                    }
                }, {
                    key: 'reverse',
                    value: function reverse() {
                        return this.playbackRate(-1);
                    }
                }, {
                    key: 'forward',
                    value: function forward() {
                        return this.playbackRate(1);
                    }
                }, {
                    key: 'from',
                    value: function from(property, value) {
                        if (!this._from) {
                            this._from = {};
                        }
                        this._from[property] = value;
                        return this;
                    }
                }, {
                    key: 'to',
                    value: function to(property, value) {
                        if (!this._to) {
                            this._to = {};
                        }
                        this._to[property] = value;
                        return this;
                    }
                }, {
                    key: 'fromTo',
                    value: function fromTo(property, from, to) {
                        return this.from(property, from).to(property, to);
                    }
                }, {
                    key: 'fadeIn',
                    value: function fadeIn() {
                        return this.fromTo('opacity', 0.001, 1);
                    }
                }, {
                    key: 'fadeOut',
                    value: function fadeOut() {
                        return this.fromTo('opacity', 0.999, 0);
                    }
                }, {
                    key: 'play',
                    value: function play(done) {
                        var self = this;
                        // the actual play() method which may or may not start async
                        function beginPlay(beginPlayDone) {
                            var tasks = [];
                            self._chld.forEach(function (childAnimation) {
                                tasks.push(function (taskDone) {
                                    childAnimation.play(taskDone);
                                });
                            });
                            self._ani.forEach(function (animation) {
                                tasks.push(function (taskDone) {
                                    animation.play(taskDone);
                                });
                            });
                            parallel(tasks, beginPlayDone);
                        }
                        if (!self._parent) {
                            var kickoff = function kickoff() {
                                // synchronously call all onPlay()'s before play()
                                self._onPlay();
                                beginPlay(function () {
                                    self._onFinish();
                                    done();
                                });
                            };

                            // this is the top level animation and is in full control
                            // of when the async play() should actually kick off
                            // stage all animations and child animations at their starting point
                            self.stage();
                            var promise = undefined;
                            if (!done) {
                                promise = new Promise(function (res) {
                                    done = res;
                                });
                            }

                            if (self._duration > 16 && self._opts.renderDelay > 0) {
                                // begin each animation when everything is rendered in their starting point
                                // give the browser some time to render everything in place before starting
                                rafFrames(self._opts.renderDelay / 16, kickoff);
                            } else {
                                // no need to render everything in there place before animating in
                                // just kick it off immediately to render them in their "to" locations
                                kickoff();
                            }
                            return promise;
                        }
                        // this is a child animation, it is told exactly when to
                        // start by the top level animation
                        beginPlay(done);
                    }
                }, {
                    key: 'stage',
                    value: function stage() {
                        // before the RENDER_DELAY
                        // before the animations have started
                        if (!this._isStaged) {
                            this._isStaged = true;
                            var i = undefined,
                                p = undefined,
                                l = undefined,
                                j = undefined,
                                ele = undefined,
                                animation = undefined;
                            for (i = 0, l = this._chld.length; i < l; i++) {
                                this._chld[i].stage();
                            }
                            for (i = 0; i < this._el.length; i++) {
                                ele = this._el[i];
                                for (j = 0; j < this._bfAdd.length; j++) {
                                    ele.classList.add(this._bfAdd[j]);
                                }
                                for (p in this._bfSty) {
                                    ele.style[p] = this._bfSty[p];
                                }
                                for (j = 0; j < this._bfRmv.length; j++) {
                                    ele.classList.remove(this._bfRmv[j]);
                                }
                            }
                            if (this._to) {
                                // only animate the elements if there are defined "to" effects
                                for (i = 0; i < this._el.length; i++) {
                                    animation = new Animate(this._el[i], this._from, this._to, this.duration(), this.easing(), this.playbackRate());
                                    if (animation.shouldAnimate) {
                                        this._ani.push(animation);
                                    }
                                }
                            }
                            for (i = 0; i < this._readys.length; i++) {
                                this._readys[i](this);
                            }
                        }
                    }
                }, {
                    key: '_onPlay',
                    value: function _onPlay() {
                        // after the RENDER_DELAY
                        // before the animations have started
                        var i = undefined;
                        this._isFinished = false;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i]._onPlay();
                        }
                        for (i = 0; i < this._plays.length; i++) {
                            this._plays[i](this);
                        }
                    }
                }, {
                    key: '_onFinish',
                    value: function _onFinish() {
                        // after the animations have finished
                        if (!this._isFinished && !this.isProgress) {
                            this._isFinished = true;
                            var i = undefined,
                                j = undefined,
                                ele = undefined;
                            for (i = 0; i < this._chld.length; i++) {
                                this._chld[i]._onFinish();
                            }
                            if (this.playbackRate() < 0) {
                                // reverse direction
                                for (i = 0; i < this._el.length; i++) {
                                    ele = this._el[i];
                                    for (j = 0; j < this._bfAdd.length; j++) {
                                        ele.classList.remove(this._bfAdd[j]);
                                    }
                                    for (j = 0; j < this._bfRmv.length; j++) {
                                        ele.classList.add(this._bfRmv[j]);
                                    }
                                }
                            } else {
                                // normal direction
                                for (i = 0; i < this._el.length; i++) {
                                    ele = this._el[i];
                                    for (j = 0; j < this._afAdd.length; j++) {
                                        ele.classList.add(this._afAdd[j]);
                                    }
                                    for (j = 0; j < this._afRmv.length; j++) {
                                        ele.classList.remove(this._afRmv[j]);
                                    }
                                }
                            }
                            for (i = 0; i < this._finishes.length; i++) {
                                this._finishes[i](this);
                            }
                        }
                    }
                }, {
                    key: 'pause',
                    value: function pause() {
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].pause();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].pause();
                        }
                    }
                }, {
                    key: 'progressStart',
                    value: function progressStart() {
                        this.isProgress = true;
                        for (var i = 0; i < this._chld.length; i++) {
                            this._chld[i].progressStart();
                        }
                        this.duration(1000);
                        this.play();
                        this.pause();
                    }
                }, {
                    key: 'progress',
                    value: function progress(value) {
                        value = Math.min(1, Math.max(0, value));
                        this.isProgress = true;
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].progress(value);
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].progress(value);
                        }
                    }

                    /**
                     * Get the current time of the first animation
                     * in the list. To get a specific time of an animation, call
                     * subAnimationInstance.getCurrentTime()
                     */
                }, {
                    key: 'getCurrentTime',
                    value: function getCurrentTime() {
                        if (this._chld.length > 0) {
                            return this._chld[0].getCurrentTime();
                        }
                        if (this._ani.length > 0) {
                            return this._ani[0].getCurrentTime();
                        }
                        return 0;
                    }
                }, {
                    key: 'progressEnd',
                    value: function progressEnd(shouldComplete) {
                        var rate = arguments.length <= 1 || arguments[1] === undefined ? 3 : arguments[1];

                        var promises = [];
                        this.isProgress = false;
                        for (var i = 0; i < this._chld.length; i++) {
                            promises.push(this._chld[i].progressEnd(shouldComplete));
                        }
                        this._ani.forEach(function (animation) {
                            if (shouldComplete) {
                                animation.playbackRate(rate);
                            } else {
                                animation.playbackRate(rate * -1);
                            }
                            promises.push(new Promise(function (resolve) {
                                animation.play(resolve);
                            }));
                        });
                        return Promise.all(promises);
                    }
                }, {
                    key: 'onReady',
                    value: function onReady(fn, clear) {
                        if (clear) {
                            this._readys = [];
                        }
                        this._readys.push(fn);
                        return this;
                    }
                }, {
                    key: 'onPlay',
                    value: function onPlay(fn, clear) {
                        if (clear) {
                            this._plays = [];
                        }
                        this._plays.push(fn);
                        return this;
                    }
                }, {
                    key: 'onFinish',
                    value: function onFinish(fn, clear) {
                        if (clear) {
                            this._finishes = [];
                        }
                        this._finishes.push(fn);
                        return this;
                    }
                }, {
                    key: 'clone',
                    value: function clone() {
                        function copy(dest, src) {
                            // undo what stage() may have already done
                            extend(dest, src);
                            dest._isFinished = dest._isStaged = dest.isProgress = false;
                            dest._chld = [];
                            dest._ani = [];
                            for (var i = 0; i < src._chld.length; i++) {
                                dest.add(copy(new Animation(), src._chld[i]));
                            }
                            return dest;
                        }
                        return copy(new Animation(), this);
                    }
                }, {
                    key: 'dispose',
                    value: function dispose(removeElement) {
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].dispose(removeElement);
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].dispose(removeElement);
                        }
                        if (removeElement) {
                            for (i = 0; i < this._el.length; i++) {
                                this._el[i].parentNode && this._el[i].parentNode.removeChild(this._el[i]);
                            }
                        }
                        this.reset();
                    }

                    /*
                     STATIC CLASSES
                     */
                }, {
                    key: 'before',
                    get: function get() {
                        var _this = this;

                        return {
                            addClass: function addClass(className) {
                                _this._bfAdd.push(className);
                                return _this;
                            },
                            removeClass: function removeClass(className) {
                                _this._bfRmv.push(className);
                                return _this;
                            },
                            setStyles: function setStyles(styles) {
                                _this._bfSty = styles;
                                return _this;
                            }
                        };
                    }
                }, {
                    key: 'after',
                    get: function get() {
                        var _this2 = this;

                        return {
                            addClass: function addClass(className) {
                                _this2._afAdd.push(className);
                                return _this2;
                            },
                            removeClass: function removeClass(className) {
                                _this2._afRmv.push(className);
                                return _this2;
                            }
                        };
                    }
                }], [{
                    key: 'create',
                    value: function create(element, name) {
                        var AnimationClass = AnimationRegistry[name];
                        if (!AnimationClass) {
                            // couldn't find an animation by the given name
                            // fallback to just the base Animation class
                            AnimationClass = Animation;
                        }
                        return new AnimationClass(element);
                    }
                }, {
                    key: 'createTransition',
                    value: function createTransition(enteringView, leavingView) {
                        var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        var TransitionClass = AnimationRegistry[opts.animation];
                        if (!TransitionClass) {
                            // didn't find a transition animation, default to ios-transition
                            TransitionClass = AnimationRegistry['ios-transition'];
                        }
                        return new TransitionClass(enteringView, leavingView, opts);
                    }
                }, {
                    key: 'register',
                    value: function register(name, AnimationClass) {
                        AnimationRegistry[name] = AnimationClass;
                    }
                }]);

                return Animation;
            })();

            _export('Animation', Animation);

            Animate = (function () {
                function Animate(ele, fromEffect, toEffect, duration, easingConfig, playbackRate) {
                    _classCallCheck(this, Animate);

                    // https://w3c.github.io/web-animations/
                    // not using the direct API methods because they're still in flux
                    // however, element.animate() seems locked in and uses the latest
                    // and correct API methods under the hood, so really doesn't matter
                    if (!fromEffect) {
                        return console.error(ele.tagName, 'animation fromEffect required, toEffect:', toEffect);
                    }
                    this.toEffect = parseEffect(toEffect);
                    this.shouldAnimate = duration > 32;
                    if (!this.shouldAnimate) {
                        return inlineStyle(ele, this.toEffect);
                    }
                    this.ele = ele;
                    // stage where the element will start from
                    this.fromEffect = parseEffect(fromEffect);
                    inlineStyle(ele, this.fromEffect);
                    this.duration = duration;
                    this.rate = typeof playbackRate !== 'undefined' ? playbackRate : 1;
                    this.easing = easingConfig && easingConfig.name || 'linear';
                    this.effects = [convertProperties(this.fromEffect)];
                    if (this.easing in EASING_FN) {
                        insertEffects(this.effects, this.fromEffect, this.toEffect, easingConfig);
                    } else if (this.easing in CUBIC_BEZIERS) {
                        this.easing = 'cubic-bezier(' + CUBIC_BEZIERS[this.easing] + ')';
                    }
                    this.effects.push(convertProperties(this.toEffect));
                }

                _createClass(Animate, [{
                    key: 'play',
                    value: function play(done) {
                        var self = this;
                        if (self.ani) {
                            self.ani.play();
                        } else {
                            // https://developers.google.com/web/updates/2014/05/Web-Animations---element-animate-is-now-in-Chrome-36
                            // https://w3c.github.io/web-animations/
                            // Future versions will use "new window.Animation" rather than "element.animate()"
                            self.ani = self.ele.animate(self.effects, {
                                duration: self.duration || 0,
                                easing: self.easing,
                                playbackRate: self.rate // old way of setting playbackRate, but still necessary
                            });
                            self.ani.playbackRate = self.rate;
                        }
                        self.ani.onfinish = function () {
                            // lock in where the element will stop at
                            // if the playbackRate is negative then it needs to return
                            // to its "from" effects
                            if (self.ani) {
                                inlineStyle(self.ele, self.rate < 0 ? self.fromEffect : self.toEffect);
                                self.ani = self.ani.onfinish = null;
                                done && done();
                            }
                        };
                    }
                }, {
                    key: 'pause',
                    value: function pause() {
                        this.ani && this.ani.pause();
                    }
                }, {
                    key: 'progress',
                    value: function progress(value) {
                        if (this.ani) {
                            // passed a number between 0 and 1
                            if (this.ani.playState !== 'paused') {
                                this.ani.pause();
                            }
                            // don't let the progress finish the animation
                            // leave it off JUST before it's finished
                            value = Math.min(0.999, Math.max(0.001, value));
                            this.ani.currentTime = this.duration * value;
                        }
                    }
                }, {
                    key: 'getCurrentTime',
                    value: function getCurrentTime() {
                        return this.ani && this.ani.currentTime || 0;
                    }
                }, {
                    key: 'playbackRate',
                    value: function playbackRate(value) {
                        this.rate = value;
                        if (this.ani) {
                            this.ani.playbackRate = value;
                        }
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        this.ele = this.ani = this.effects = this.toEffect = null;
                    }
                }]);

                return Animate;
            })();

            TRANSFORMS = ['translateX', 'translateY', 'translateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'perspective'];
            ANIMATE_PROPERTIES = TRANSFORMS.concat('opacity');

            // Robert Penner's Easing Functions
            // http://robertpenner.com/easing/
            CUBIC_BEZIERS = {
                // default browser suppored easing
                // ease
                // ease-in
                // ease-out
                // ease-in-out
                // Cubic
                'ease-in-cubic': '0.55,0.055,0.675,0.19',
                'ease-out-cubic': '0.215,0.61,0.355,1',
                'ease-in-Out-cubic': '0.645,0.045,0.355,1',
                // Circ
                'ease-in-circ': '0.6,0.04,0.98,0.335',
                'ease-out-circ': '0.075,0.82,0.165,1',
                'ease-in-out-circ': '0.785,0.135,0.15,0.86',
                // Expo
                'ease-in-expo': '0.95,0.05,0.795,0.035',
                'ease-out-expo': '0.19,1,0.22,1',
                'ease-in-out-expo': '1,0,0,1',
                // Quad
                'ease-in-quad': '0.55,0.085,0.68,0.53',
                'ease-out-quad': '0.25,0.46,0.45,0.94',
                'ease-in-out-quad': '0.455,0.03,0.515,0.955',
                // Quart
                'ease-in-quart': '0.895,0.03,0.685,0.22',
                'ease-out-quart': '0.165,0.84,0.44,1',
                'ease-in-out-quart': '0.77,0,0.175,1',
                // Quint
                'ease-in-quint': '0.755,0.05,0.855,0.06',
                'ease-out-quint': '0.23,1,0.32,1',
                'ease-in-out-quint': '0.86,0,0.07,1',
                // Sine
                'ease-in-sine': '0.47,0,0.745,0.715',
                'ease-out-sine': '0.39,0.575,0.565,1',
                'ease-in-out-sine': '0.445,0.05,0.55,0.95',
                // Back
                'ease-in-back': '0.6,-0.28,0.735,0.045',
                'ease-out-back': '0.175,0.885,0.32,1.275',
                'ease-in-out-back': '0.68,-0.55,0.265,1.55'
            };
            EASING_FN = {
                'elastic': function elastic(pos) {
                    return -1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
                },
                'swing-from-to': function swingFromTo(pos, opts) {
                    var s = opts.s || 1.70158;
                    return (pos /= 0.5) < 1 ? 0.5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : 0.5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
                },
                'swing-from': function swingFrom(pos, opts) {
                    var s = opts.s || 1.70158;
                    return pos * pos * ((s + 1) * pos - s);
                },
                'swing-to': function swingTo(pos, opts) {
                    var s = opts.s || 1.70158;
                    return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
                },
                'bounce': function bounce(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
                    }
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
                },
                'bounce-past': function bouncePast(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
                    } else if (pos < 2.5 / 2.75) {
                        return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
                    }
                    return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
                },
                'ease-out-bounce': function easeOutBounce(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
                    }
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
                },
                'ease-from-to': function easeFromTo(pos) {
                    if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 4);
                    return -0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
                },
                'ease-from': function easeFrom(pos, opts) {
                    return Math.pow(pos, opts.s || 4);
                },
                'ease-to': function easeTo(pos, opts) {
                    return Math.pow(pos, opts.s || 0.25);
                },
                /*
                 * scripty2, Thomas Fuchs (MIT Licence)
                 * https://raw.github.com/madrobby/scripty2/master/src/effects/transitions/transitions.js
                 */
                'spring': function spring(pos, opts) {
                    var damping = opts.damping || 4.5;
                    var elasticity = opts.elasticity || 6;
                    return 1 - Math.cos(pos * damping * Math.PI) * Math.exp(-pos * elasticity);
                },
                'sinusoidal': function sinusoidal(pos) {
                    return -Math.cos(pos * Math.PI) / 2 + 0.5;
                }
            };
            AnimationRegistry = {};
        }
    };
});
System.register('ionic/animations/builtins', ['./animation'], function (_export) {
    'use strict';

    var Animation, SlideIn, SlideOut, FadeIn, FadeOut;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_animation) {
            Animation = _animation.Animation;
        }],
        execute: function () {
            SlideIn = (function (_Animation) {
                _inherits(SlideIn, _Animation);

                function SlideIn(element) {
                    _classCallCheck(this, SlideIn);

                    _get(Object.getPrototypeOf(SlideIn.prototype), 'constructor', this).call(this, element);
                    this.easing('cubic-bezier(0.1,0.7,0.1,1)').duration(400).fromTo('translateY', '100%', '0%');
                }

                return SlideIn;
            })(Animation);

            Animation.register('slide-in', SlideIn);

            SlideOut = (function (_Animation2) {
                _inherits(SlideOut, _Animation2);

                function SlideOut(element) {
                    _classCallCheck(this, SlideOut);

                    _get(Object.getPrototypeOf(SlideOut.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-out').duration(250).fromTo('translateY', '0%', '100%');
                }

                return SlideOut;
            })(Animation);

            Animation.register('slide-out', SlideOut);

            FadeIn = (function (_Animation3) {
                _inherits(FadeIn, _Animation3);

                function FadeIn(element) {
                    _classCallCheck(this, FadeIn);

                    _get(Object.getPrototypeOf(FadeIn.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-in').duration(400).fadeIn();
                }

                return FadeIn;
            })(Animation);

            Animation.register('fade-in', FadeIn);

            FadeOut = (function (_Animation4) {
                _inherits(FadeOut, _Animation4);

                function FadeOut(element) {
                    _classCallCheck(this, FadeOut);

                    _get(Object.getPrototypeOf(FadeOut.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-out').duration(250).fadeOut();
                }

                return FadeOut;
            })(Animation);

            Animation.register('fade-out', FadeOut);
        }
    };
});
System.register('ionic/animations/ios-transition', ['./animation'], function (_export) {
    'use strict';

    var Animation, DURATION, EASING, OPACITY, TRANSLATEX, OFF_RIGHT, OFF_LEFT, CENTER, OFF_OPACITY, SHOW_BACK_BTN_CSS, IOSTransition;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_animation) {
            Animation = _animation.Animation;
        }],
        execute: function () {
            DURATION = 400;
            EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
            OPACITY = 'opacity';
            TRANSLATEX = 'translateX';
            OFF_RIGHT = '99.5%';
            OFF_LEFT = '-33%';
            CENTER = '0%';
            OFF_OPACITY = 0.8;
            SHOW_BACK_BTN_CSS = 'show-back-button';

            IOSTransition = (function (_Animation) {
                _inherits(IOSTransition, _Animation);

                function IOSTransition(enteringView, leavingView, opts) {
                    _classCallCheck(this, IOSTransition);

                    _get(Object.getPrototypeOf(IOSTransition.prototype), 'constructor', this).call(this, null, opts);
                    this.duration(DURATION);
                    this.easing(EASING);
                    // what direction is the transition going
                    var backDirection = opts.direction === 'back';
                    // do they have navbars?
                    var enteringHasNavbar = enteringView.hasNavbar();
                    var leavingHasNavbar = leavingView && leavingView.hasNavbar();
                    var enteringPage = new Animation(enteringView.pageRef());
                    enteringPage.before.addClass('show-page');
                    this.add(enteringPage);
                    // entering content
                    var enteringContent = new Animation(enteringView.contentRef());
                    this.add(enteringContent);
                    if (backDirection) {
                        // entering content, back direction
                        enteringContent.fromTo(TRANSLATEX, OFF_LEFT, CENTER).fromTo(OPACITY, OFF_OPACITY, 1);
                    } else {
                        // entering content, forward direction
                        enteringContent.fromTo(TRANSLATEX, OFF_RIGHT, CENTER).fromTo(OPACITY, 1, 1);
                    }
                    if (enteringHasNavbar) {
                        // entering page has a navbar
                        var enteringNavBar = new Animation(enteringView.navbarRef());
                        enteringNavBar.before.addClass('show-navbar');
                        this.add(enteringNavBar);
                        var enteringTitle = new Animation(enteringView.titleRef());
                        var enteringNavbarItems = new Animation(enteringView.navbarItemRefs());
                        var enteringNavbarBg = new Animation(enteringView.navbarBgRef());
                        var enteringBackButton = new Animation(enteringView.backBtnRef());
                        enteringNavBar.add(enteringTitle).add(enteringNavbarItems).add(enteringNavbarBg).add(enteringBackButton);
                        enteringTitle.fadeIn();
                        enteringNavbarItems.fadeIn();
                        // set properties depending on direction
                        if (backDirection) {
                            // entering navbar, back direction
                            enteringTitle.fromTo(TRANSLATEX, OFF_LEFT, CENTER);
                            if (enteringView.enableBack()) {
                                // back direction, entering page has a back button
                                enteringBackButton.before.addClass(SHOW_BACK_BTN_CSS).fadeIn();
                            }
                        } else {
                            // entering navbar, forward direction
                            enteringTitle.fromTo(TRANSLATEX, OFF_RIGHT, CENTER);
                            if (leavingHasNavbar) {
                                // entering navbar, forward direction, and there's a leaving navbar
                                // should just fade in, no sliding
                                enteringNavbarBg.fromTo(TRANSLATEX, CENTER, CENTER).fadeIn();
                            } else {
                                // entering navbar, forward direction, and there's no leaving navbar
                                // should just slide in, no fading in
                                enteringNavbarBg.fromTo(TRANSLATEX, OFF_RIGHT, CENTER).fromTo(OPACITY, 1, 1);
                            }
                            if (enteringView.enableBack()) {
                                // forward direction, entering page has a back button
                                enteringBackButton.before.addClass(SHOW_BACK_BTN_CSS).fadeIn();
                                var enteringBackBtnText = new Animation(enteringView.backBtnTextRef());
                                enteringBackBtnText.fromTo(TRANSLATEX, '100px', '0px');
                                enteringNavBar.add(enteringBackBtnText);
                            } else {
                                enteringBackButton.before.removeClass(SHOW_BACK_BTN_CSS);
                            }
                        }
                    }
                    // setup leaving view
                    if (leavingView) {
                        // leaving content
                        var leavingContent = new Animation(leavingView.contentRef());
                        this.add(leavingContent);
                        if (backDirection) {
                            // leaving content, back direction
                            leavingContent.fromTo(TRANSLATEX, CENTER, '100%').fromTo(OPACITY, 1, 1);
                        } else {
                            // leaving content, forward direction
                            leavingContent.fromTo(TRANSLATEX, CENTER, OFF_LEFT).fromTo(OPACITY, 1, OFF_OPACITY);
                        }
                        if (leavingHasNavbar) {
                            // leaving page has a navbar
                            var leavingNavBar = new Animation(leavingView.navbarRef());
                            var leavingBackButton = new Animation(leavingView.backBtnRef());
                            var leavingTitle = new Animation(leavingView.titleRef());
                            var leavingNavbarItems = new Animation(leavingView.navbarItemRefs());
                            var leavingNavbarBg = new Animation(leavingView.navbarBgRef());
                            leavingNavBar.add(leavingBackButton).add(leavingTitle).add(leavingNavbarItems).add(leavingNavbarBg);
                            this.add(leavingNavBar);
                            // fade out leaving navbar items
                            leavingBackButton.fadeOut();
                            leavingTitle.fadeOut();
                            leavingNavbarItems.fadeOut();
                            if (backDirection) {
                                // leaving navbar, back direction
                                leavingTitle.fromTo(TRANSLATEX, CENTER, '100%');
                                if (enteringHasNavbar) {
                                    // leaving navbar, back direction, and there's an entering navbar
                                    // should just fade out, no sliding
                                    leavingNavbarBg.fromTo(TRANSLATEX, CENTER, CENTER).fadeOut();
                                } else {
                                    // leaving navbar, back direction, and there's no entering navbar
                                    // should just slide out, no fading out
                                    leavingNavbarBg.fromTo(TRANSLATEX, CENTER, '100%').fromTo(OPACITY, 1, 1);
                                }
                                var leavingBackBtnText = new Animation(leavingView.backBtnTextRef());
                                leavingBackBtnText.fromTo(TRANSLATEX, CENTER, 300 + 'px');
                                leavingNavBar.add(leavingBackBtnText);
                            } else {
                                // leaving navbar, forward direction
                                leavingTitle.fromTo(TRANSLATEX, CENTER, OFF_LEFT);
                            }
                        }
                    }
                }

                return IOSTransition;
            })(Animation);

            Animation.register('ios-transition', IOSTransition);
        }
    };
});
System.register('ionic/animations/md-transition', ['./animation'], function (_export) {
    'use strict';

    var Animation, TRANSLATEY, OFF_BOTTOM, CENTER, SHOW_BACK_BTN_CSS, MDTransition;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_animation) {
            Animation = _animation.Animation;
        }],
        execute: function () {
            TRANSLATEY = 'translateY';
            OFF_BOTTOM = '40px';
            CENTER = '0px';
            SHOW_BACK_BTN_CSS = 'show-back-button';

            MDTransition = (function (_Animation) {
                _inherits(MDTransition, _Animation);

                function MDTransition(enteringView, leavingView, opts) {
                    _classCallCheck(this, MDTransition);

                    _get(Object.getPrototypeOf(MDTransition.prototype), 'constructor', this).call(this, null, opts);
                    // what direction is the transition going
                    var backDirection = opts.direction === 'back';
                    // do they have navbars?
                    var enteringHasNavbar = enteringView.hasNavbar();
                    var leavingHasNavbar = leavingView && leavingView.hasNavbar();
                    // entering content item moves in bottom to center
                    var enteringPage = new Animation(enteringView.pageRef());
                    enteringPage.before.addClass('show-page');
                    this.add(enteringPage);
                    if (backDirection) {
                        this.duration(200).easing('cubic-bezier(0.47,0,0.745,0.715)');
                        enteringPage.fromTo(TRANSLATEY, CENTER, CENTER);
                    } else {
                        this.duration(280).easing('cubic-bezier(0.36,0.66,0.04,1)');
                        enteringPage.fromTo(TRANSLATEY, OFF_BOTTOM, CENTER).fadeIn();
                    }
                    if (enteringHasNavbar) {
                        var enteringNavBar = new Animation(enteringView.navbarRef());
                        enteringNavBar.before.addClass('show-navbar');
                        this.add(enteringNavBar);
                        var enteringBackButton = new Animation(enteringView.backBtnRef());
                        this.add(enteringBackButton);
                        if (enteringView.enableBack()) {
                            enteringBackButton.before.addClass(SHOW_BACK_BTN_CSS);
                        } else {
                            enteringBackButton.before.removeClass(SHOW_BACK_BTN_CSS);
                        }
                    }
                    // setup leaving view
                    if (leavingView && backDirection) {
                        // leaving content
                        this.duration(200).easing('cubic-bezier(0.47,0,0.745,0.715)');
                        var leavingPage = new Animation(leavingView.pageRef());
                        this.add(leavingPage.fromTo(TRANSLATEY, CENTER, OFF_BOTTOM).fadeOut());
                    }
                }

                return MDTransition;
            })(Animation);

            Animation.register('md-transition', MDTransition);
        }
    };
});
System.register('ionic/animations/scroll-to', ['../util/dom'], function (_export) {
    'use strict';

    var raf, ScrollTo;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    // decelerating to zero velocity
    function easeOutCubic(t) {
        return --t * t * t + 1;
    }
    return {
        setters: [function (_utilDom) {
            raf = _utilDom.raf;
        }],
        execute: function () {
            ScrollTo = (function () {
                function ScrollTo(ele, x, y, duration) {
                    _classCallCheck(this, ScrollTo);

                    if (typeof ele === 'string') {
                        // string query selector
                        ele = document.querySelector(ele);
                    }
                    if (ele) {
                        if (ele.nativeElement) {
                            // angular ElementRef
                            ele = ele.nativeElement;
                        }
                        if (ele.nodeType === 1) {
                            this._el = ele;
                        }
                    }
                }

                _createClass(ScrollTo, [{
                    key: 'start',
                    value: function start(x, y, duration, tolerance) {
                        // scroll animation loop w/ easing
                        // credit https://gist.github.com/dezinezync/5487119
                        var self = this;
                        if (!self._el) {
                            // invalid element
                            return Promise.resolve();
                        }
                        x = x || 0;
                        y = y || 0;
                        tolerance = tolerance || 0;
                        var fromY = self._el.scrollTop;
                        var fromX = self._el.scrollLeft;
                        var xDistance = Math.abs(x - fromX);
                        var yDistance = Math.abs(y - fromY);
                        if (yDistance <= tolerance && xDistance <= tolerance) {
                            // prevent scrolling if already close to there
                            self._el = null;
                            return Promise.resolve();
                        }
                        return new Promise(function (resolve, reject) {
                            var start = undefined;
                            // start scroll loop
                            self.isPlaying = true;
                            // chill out for a frame first
                            raf(function () {
                                start = Date.now();
                                raf(step);
                            });
                            // scroll loop
                            function step() {
                                if (!self._el) {
                                    return resolve();
                                }
                                var time = Math.min(1, (Date.now() - start) / duration);
                                // where .5 would be 50% of time on a linear scale easedT gives a
                                // fraction based on the easing method
                                var easedT = easeOutCubic(time);
                                if (fromY != y) {
                                    self._el.scrollTop = Math.round(easedT * (y - fromY) + fromY);
                                }
                                if (fromX != x) {
                                    self._el.scrollLeft = Math.round(easedT * (x - fromX) + fromX);
                                }
                                if (time < 1 && self.isPlaying) {
                                    raf(step);
                                } else if (!self.isPlaying) {
                                    // stopped
                                    self._el = null;
                                    reject();
                                } else {
                                    // done
                                    self._el = null;
                                    resolve();
                                }
                            }
                        });
                    }
                }, {
                    key: 'stop',
                    value: function stop() {
                        this.isPlaying = false;
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        this.stop();
                        this._el = null;
                    }
                }]);

                return ScrollTo;
            })();

            _export('ScrollTo', ScrollTo);
        }
    };
});
System.register('ionic/config/bootstrap', ['angular2/core', 'angular2/router', 'angular2/http', '../components/app/app', './config', '../platform/platform', '../util/form', '../util/keyboard', '../util/events', '../components/nav/nav-registry', '../translation/translate', '../util/click-block', '../util/feature-detect', '../components/tap-click/tap-click', '../util/dom'], function (_export) {
    /**
     * @private
     */
    'use strict';

    var provide, ROUTER_PROVIDERS, LocationStrategy, HashLocationStrategy, HTTP_PROVIDERS, IonicApp, Config, Platform, Form, Keyboard, Events, NavRegistry, Translate, ClickBlock, FeatureDetect, TapClick, closest;

    _export('ionicProviders', ionicProviders);

    function ionicProviders() {
        var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        var platform = new Platform();
        var navRegistry = new NavRegistry(args.pages);
        var config = args.config;
        if (!(config instanceof Config)) {
            config = new Config(config);
        }
        platform.url(window.location.href);
        platform.userAgent(window.navigator.userAgent);
        platform.navigatorPlatform(window.navigator.platform);
        platform.load();
        config.setPlatform(platform);
        var clickBlock = new ClickBlock(config.get('clickBlock'));
        var events = new Events();
        var featureDetect = new FeatureDetect();
        setupDom(window, document, config, platform, clickBlock, featureDetect);
        bindEvents(window, document, platform, events);
        // prepare the ready promise to fire....when ready
        platform.prepareReady(config);
        return [IonicApp, provide(ClickBlock, { useValue: clickBlock }), provide(Config, { useValue: config }), provide(Platform, { useValue: platform }), provide(FeatureDetect, { useValue: featureDetect }), provide(Events, { useValue: events }), provide(NavRegistry, { useValue: navRegistry }), TapClick, Form, Keyboard, Translate, ROUTER_PROVIDERS, provide(LocationStrategy, { useClass: HashLocationStrategy }), HTTP_PROVIDERS];
    }

    function setupDom(window, document, config, platform, clickBlock, featureDetect) {
        var bodyEle = document.body;
        var mode = config.get('mode');
        // if dynamic mode links have been added the fire up the correct one
        var modeLinkAttr = mode + '-href';
        var linkEle = document.head.querySelector('link[' + modeLinkAttr + ']');
        if (linkEle) {
            var href = linkEle.getAttribute(modeLinkAttr);
            linkEle.removeAttribute(modeLinkAttr);
            linkEle.href = href;
        }
        // set the mode class name
        // ios/md
        bodyEle.classList.add(mode);
        // language and direction
        platform.setDir(document.documentElement.dir, false);
        platform.setLang(document.documentElement.lang, false);
        var versions = platform.versions();
        platform.platforms().forEach(function (platformName) {
            // platform-ios
            var platformClass = 'platform-' + platformName;
            bodyEle.classList.add(platformClass);
            var platformVersion = versions[platformName];
            if (platformVersion) {
                // platform-ios9
                platformClass += platformVersion.major;
                bodyEle.classList.add(platformClass);
                // platform-ios9_3
                bodyEle.classList.add(platformClass + '_' + platformVersion.minor);
            }
        });
        // touch devices should not use :hover CSS pseudo
        // enable :hover CSS when the "hoverCSS" setting is not false
        if (config.get('hoverCSS') !== false) {
            bodyEle.classList.add('enable-hover');
        }
        if (config.get('clickBlock')) {
            clickBlock.enable();
        }
        // run feature detection tests
        featureDetect.run(window, document);
    }
    /**
     * Bind some global events and publish on the 'app' channel
     */
    function bindEvents(window, document, platform, events) {
        window.addEventListener('online', function (ev) {
            events.publish('app:online', ev);
        }, false);
        window.addEventListener('offline', function (ev) {
            events.publish('app:offline', ev);
        }, false);
        window.addEventListener('orientationchange', function (ev) {
            events.publish('app:rotated', ev);
        });
        // When that status taps, we respond
        window.addEventListener('statusTap', function (ev) {
            // TODO: Make this more better
            var el = document.elementFromPoint(platform.width() / 2, platform.height() / 2);
            if (!el) {
                return;
            }
            var content = closest(el, 'scroll-content');
            if (content) {
                var scrollTo = new ScrollTo(content);
                scrollTo.start(0, 0, 300, 0);
            }
        });
        // start listening for resizes XXms after the app starts
        setTimeout(function () {
            window.addEventListener('resize', function () {
                platform.windowResize();
            });
        }, 2000);
    }
    return {
        setters: [function (_angular2Core) {
            provide = _angular2Core.provide;
        }, function (_angular2Router) {
            ROUTER_PROVIDERS = _angular2Router.ROUTER_PROVIDERS;
            LocationStrategy = _angular2Router.LocationStrategy;
            HashLocationStrategy = _angular2Router.HashLocationStrategy;
        }, function (_angular2Http) {
            HTTP_PROVIDERS = _angular2Http.HTTP_PROVIDERS;
        }, function (_componentsAppApp) {
            IonicApp = _componentsAppApp.IonicApp;
        }, function (_config) {
            Config = _config.Config;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }, function (_utilForm) {
            Form = _utilForm.Form;
        }, function (_utilKeyboard) {
            Keyboard = _utilKeyboard.Keyboard;
        }, function (_utilEvents) {
            Events = _utilEvents.Events;
        }, function (_componentsNavNavRegistry) {
            NavRegistry = _componentsNavNavRegistry.NavRegistry;
        }, function (_translationTranslate) {
            Translate = _translationTranslate.Translate;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_utilFeatureDetect) {
            FeatureDetect = _utilFeatureDetect.FeatureDetect;
        }, function (_componentsTapClickTapClick) {
            TapClick = _componentsTapClickTapClick.TapClick;
        }, function (_utilDom) {
            closest = _utilDom.closest;
        }],
        execute: function () {}
    };
});
System.register('ionic/config/config', ['../platform/platform', '../util/util'], function (_export) {
    /**
    * @ngdoc service
    * @name Config
    * @module ionic
    * @description
    * Config allows you to set the modes of your components
    */

    /**
     * @name Config
     * @demo /docs/v3/demos/config/
     * @description
     * Config lets you change multiple or a single value in an apps mode configuration. Things such as tab placement, icon changes, and view animations can be set here.
     *
     * ```ts
     * @App({
     *   template: `<ion-nav [root]="root"></ion-nav>`
     *   config: {
     *     backButtonText: 'Go Back',
     *     iconMode: 'ios',
     *     modalEnter: 'modal-slide-in',
     *     modalLeave: 'modal-slide-out',
     *     tabbarPlacement: 'bottom',
     *     pageTransition: 'ios',
     *   }
     * })
     * ```
     *
     * Config can be overwritting at multiple levels, allowing deeper configuration. Taking the example from earlier, we can override any setting we want based on a platform.
     * ```ts
     * @App({
     *   template: `<ion-nav [root]="root"></ion-nav>`
     *   config: {
     *     tabbarPlacement: 'bottom',
     *     platforms: {
     *      ios: {
     *        tabbarPlacement: 'top',
     *      }
     *     }
     *   }
     * })
     * ```
     *
     * We could also configure these values at a component level. Take `tabbarPlacement`, we can configure this as a property on our `ion-tabs`.
     *
     * ```html
     * <ion-tabs tabbarPlacement="top">
     *    <ion-tab tabTitle="Dash" tabIcon="pulse" [root]="tabRoot"></ion-tab>
     *  </ion-tabs>
     * ```
     *
     * The property will override anything else set in the apps.
     *
     * The last way we could configure is through URL query strings. This is useful for testing while in the browser.
     * Simply add `?ionic<PROPERTYNAME>=<value>` to the url.
     *
     * ```bash
     * http://localhost:8100/?ionicTabbarPlacement=bottom
     * ```
     *
     * Custom values can be added to config, and looked up at a later point in time.
     *
     * ``` javascript
     * config.set('ios', 'favoriteColor', 'green');
     * // from any page in your app:
     * config.get('favoriteColor'); // 'green'
     * ```
     *
     *
     * A config value can come from anywhere and be anything, but there are a default set of values.
     *
     *
     * | Config property            | Default iOS Value      | Default MD Value          |
     * |----------------------------|------------------------|---------------------------|
     * | activator                  | highlight              | ripple                    |
     * | actionSheetEnter           | action-sheet-slide-in  | action-sheet-md-slide-in  |
     * | actionSheetLeave           | action-sheet-slide-out | action-sheet-md-slide-out |
     * | alertEnter                 | alert-pop-in           | alert-md-pop-in           |
     * | alertLeave                 | alert-pop-out          | alert-md-pop-out          |
     * | backButtonText             | Back                   |                           |
     * | backButtonIcon             | ion-ios-arrow-back     | ion-md-arrow-back         |
     * | iconMode                   | ios                    | md                        |
     * | menuType                   | reveal                 | overlay                   |
     * | modalEnter                 | modal-slide-in         | modal-md-slide-in         |
     * | modalLeave                 | modal-slide-out        | modal-md-slide-out        |
     * | pageTransition             | ios-transition         | md-transition             |
     * | pageTransitionDelay        | 16                     | 120                       |
     * | tabbarPlacement            | bottom                 | top                       |
     * | tabbarHighlight            |                        | top                       |
     * | tabSubPage                 |                        | true                      |
     *
    **/
    'use strict';

    var Platform, isObject, isDefined, isFunction, isArray, Config, modeConfigs;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }, function (_utilUtil) {
            isObject = _utilUtil.isObject;
            isDefined = _utilUtil.isDefined;
            isFunction = _utilUtil.isFunction;
            isArray = _utilUtil.isArray;
        }],
        execute: function () {
            Config = (function () {
                function Config(config) {
                    _classCallCheck(this, Config);

                    this._s = config && isObject(config) && !isArray(config) ? config : {};
                    this._c = {}; // cached values
                }

                /**
                 * For setting and getting multiple config values
                 */
                /**
                 * @private
                 * @name settings()
                 * @description
                 */

                _createClass(Config, [{
                    key: 'settings',
                    value: function settings() {
                        var args = arguments;
                        switch (args.length) {
                            case 0:
                                return this._s;
                            case 1:
                                // settings({...})
                                this._s = args[0];
                                this._c = {}; // clear cache
                                break;
                            case 2:
                                // settings('ios', {...})
                                this._s.platforms = this._s.platforms || {};
                                this._s.platforms[args[0]] = args[1];
                                this._c = {}; // clear cache
                                break;
                        }
                        return this;
                    }

                    /**
                     * @name set
                     * @description
                     * Sets a single config value.
                     *
                     * @param {String} [platform] - The platform (either 'ios' or 'android') that the config value should apply to. Leaving this blank will apply the config value to all platforms.
                     * @param {String} [key] - The key used to look up the value at a later point in time.
                     * @param {String} [value] - The config value being stored.
                     */
                }, {
                    key: 'set',
                    value: function set() {
                        var args = arguments;
                        var arg0 = args[0];
                        var arg1 = args[1];
                        switch (args.length) {
                            case 2:
                                // set('key', 'value') = set key/value pair
                                // arg1 = value
                                this._s[arg0] = arg1;
                                delete this._c[arg0]; // clear cache
                                break;
                            case 3:
                                // setting('ios', 'key', 'value') = set key/value pair for platform
                                // arg0 = platform
                                // arg1 = key
                                // arg2 = value
                                this._s.platforms = this._s.platforms || {};
                                this._s.platforms[arg0] = this._s.platforms[arg0] || {};
                                this._s.platforms[arg0][arg1] = args[2];
                                delete this._c[arg1]; // clear cache
                                break;
                        }
                        return this;
                    }

                    /**
                     * @name get
                     * @description
                     * Returns a single config value, given a key.
                     *
                     * @param {String} [key] - the key for the config value
                     */
                }, {
                    key: 'get',
                    value: function get(key) {
                        if (!isDefined(this._c[key])) {
                            if (!isDefined(key)) {
                                throw 'config key is not defined';
                            }
                            // if the value was already set this will all be skipped
                            // if there was no user config then it'll check each of
                            // the user config's platforms, which already contains
                            // settings from default platform configs
                            var userPlatformValue = undefined;
                            var userDefaultValue = this._s[key];
                            var userPlatformModeValue = undefined;
                            var userDefaultModeValue = undefined;
                            var platformValue = undefined;
                            var platformModeValue = undefined;
                            var configObj = null;
                            if (this.platform) {
                                var queryStringValue = this.platform.query('ionic' + key.toLowerCase());
                                if (isDefined(queryStringValue)) {
                                    return this._c[key] = queryStringValue === 'true' ? true : queryStringValue === 'false' ? false : queryStringValue;
                                }
                                // check the platform settings object for this value
                                // loop though each of the active platforms
                                // array of active platforms, which also knows the hierarchy,
                                // with the last one the most important
                                var activePlatformKeys = this.platform.platforms();
                                // loop through all of the active platforms we're on
                                for (var i = 0, l = activePlatformKeys.length; i < l; i++) {
                                    // get user defined platform values
                                    if (this._s.platforms) {
                                        configObj = this._s.platforms[activePlatformKeys[i]];
                                        if (configObj) {
                                            if (isDefined(configObj[key])) {
                                                userPlatformValue = configObj[key];
                                            }
                                            configObj = Config.getModeConfig(configObj.mode);
                                            if (configObj && isDefined(configObj[key])) {
                                                userPlatformModeValue = configObj[key];
                                            }
                                        }
                                    }
                                    // get default platform's setting
                                    configObj = Platform.get(activePlatformKeys[i]);
                                    if (configObj && configObj.settings) {
                                        if (isDefined(configObj.settings[key])) {
                                            // found a setting for this platform
                                            platformValue = configObj.settings[key];
                                        }
                                        configObj = Config.getModeConfig(configObj.settings.mode);
                                        if (configObj && isDefined(configObj[key])) {
                                            // found setting for this platform's mode
                                            platformModeValue = configObj[key];
                                        }
                                    }
                                }
                            }
                            configObj = Config.getModeConfig(this._s.mode);
                            if (configObj && isDefined(configObj[key])) {
                                userDefaultModeValue = configObj[key];
                            }
                            // cache the value
                            this._c[key] = isDefined(userPlatformValue) ? userPlatformValue : isDefined(userDefaultValue) ? userDefaultValue : isDefined(userPlatformModeValue) ? userPlatformModeValue : isDefined(userDefaultModeValue) ? userDefaultModeValue : isDefined(platformValue) ? platformValue : isDefined(platformModeValue) ? platformModeValue : null;
                        }
                        // return key's value
                        // either it came directly from the user config
                        // or it was from the users platform configs
                        // or it was from the default platform configs
                        // in that order
                        if (isFunction(this._c[key])) {
                            return this._c[key](this.platform);
                        }
                        return this._c[key];
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'setPlatform',
                    value: function setPlatform(platform) {
                        this.platform = platform;
                    }
                }], [{
                    key: 'setModeConfig',
                    value: function setModeConfig(mode, config) {
                        modeConfigs[mode] = config;
                    }
                }, {
                    key: 'getModeConfig',
                    value: function getModeConfig(mode) {
                        return modeConfigs[mode] || null;
                    }
                }]);

                return Config;
            })();

            _export('Config', Config);

            modeConfigs = {};
        }
    };
});
System.register('ionic/config/directives', ['angular2/common', '../components/overlay/overlay', '../components/menu/menu', '../components/menu/menu-toggle', '../components/menu/menu-close', '../components/button/button', '../components/blur/blur', '../components/content/content', '../components/scroll/scroll', '../components/scroll/pull-to-refresh', '../components/slides/slides', '../components/tabs/tabs', '../components/tabs/tab', '../components/list/list', '../components/item/item', '../components/item/item-sliding', '../components/toolbar/toolbar', '../components/icon/icon', '../components/checkbox/checkbox', '../components/toggle/toggle', '../components/text-input/text-input', '../components/label/label', '../components/segment/segment', '../components/radio/radio', '../components/searchbar/searchbar', '../components/nav/nav', '../components/nav/nav-push', '../components/nav/nav-router', '../components/navbar/navbar', '../components/app/id', '../components/show-hide-when/show-hide-when'], function (_export) {
  /**
   * @name IONIC_DIRECTIVES
   * @private
   * @description
   * The core Ionic directives as well as Angular's CORE_DIRECTIVES and
   * FORM_DIRECTIVES.  Automatically available in every [@Page](../Page/) template.
   *
   * **Angular**
   * - CORE_DIRECTIVES
   * - FORM_DIRECTIVES
   *
   * **Content**
   * -  Menu
   * -  MenuToggle
   * -  MenuClose
   *
   * -  Button
   * -  Blur
   * -  Content
   * -  Scroll
   * -  Refresher
   *
   * **Lists**
   * -  List
   * -  ListHeader
   * -  Item
   * -  ItemSliding
   *
   * **Slides**
   * -  Slides
   * -  Slide
   * -  SlideLazy
   *
   * **Tabs**
   * -  Tabs
   * -  Tab
   *
   * **Toolbar**
   * -  Toolbar
   * -  ToolbarTitle
   * -  ToolbarItem
   *
   * **Media**
   * -  Icon
   *
   * **Forms**
   * -  Searchbar
   * -  Segment
   * -  SegmentButton
   * -  Checkbox
   * -  RadioGroup
   * -  RadioButton
   * -  Toggle
   * -  TextInput
   * -  TextInputElement
   * -  Label
   *
   * **Nav**
   * -  Nav
   * -  NavbarTemplate
   * -  Navbar
   * -  NavPush
   * -  NavPop
   * -  NavRouter
   * -  IdRef
   *
   * -  ShowWhen
   * -  HideWhen
   */
  'use strict';

  var CORE_DIRECTIVES, FORM_DIRECTIVES, OverlayNav, Menu, MenuToggle, MenuClose, Button, Blur, Content, Scroll, Refresher, Slides, Slide, SlideLazy, Tabs, Tab, List, ListHeader, Item, ItemSliding, Toolbar, ToolbarTitle, ToolbarItem, Icon, Checkbox, Toggle, TextInput, TextInputElement, Label, Segment, SegmentButton, RadioGroup, RadioButton, Searchbar, SearchbarInput, Nav, NavPush, NavPop, NavRouter, NavbarTemplate, Navbar, IdRef, ShowWhen, HideWhen, IONIC_DIRECTIVES;
  return {
    setters: [function (_angular2Common) {
      CORE_DIRECTIVES = _angular2Common.CORE_DIRECTIVES;
      FORM_DIRECTIVES = _angular2Common.FORM_DIRECTIVES;
    }, function (_componentsOverlayOverlay) {
      OverlayNav = _componentsOverlayOverlay.OverlayNav;
    }, function (_componentsMenuMenu) {
      Menu = _componentsMenuMenu.Menu;
    }, function (_componentsMenuMenuToggle) {
      MenuToggle = _componentsMenuMenuToggle.MenuToggle;
    }, function (_componentsMenuMenuClose) {
      MenuClose = _componentsMenuMenuClose.MenuClose;
    }, function (_componentsButtonButton) {
      Button = _componentsButtonButton.Button;
    }, function (_componentsBlurBlur) {
      Blur = _componentsBlurBlur.Blur;
    }, function (_componentsContentContent) {
      Content = _componentsContentContent.Content;
    }, function (_componentsScrollScroll) {
      Scroll = _componentsScrollScroll.Scroll;
    }, function (_componentsScrollPullToRefresh) {
      Refresher = _componentsScrollPullToRefresh.Refresher;
    }, function (_componentsSlidesSlides) {
      Slides = _componentsSlidesSlides.Slides;
      Slide = _componentsSlidesSlides.Slide;
      SlideLazy = _componentsSlidesSlides.SlideLazy;
    }, function (_componentsTabsTabs) {
      Tabs = _componentsTabsTabs.Tabs;
    }, function (_componentsTabsTab) {
      Tab = _componentsTabsTab.Tab;
    }, function (_componentsListList) {
      List = _componentsListList.List;
      ListHeader = _componentsListList.ListHeader;
    }, function (_componentsItemItem) {
      Item = _componentsItemItem.Item;
    }, function (_componentsItemItemSliding) {
      ItemSliding = _componentsItemItemSliding.ItemSliding;
    }, function (_componentsToolbarToolbar) {
      Toolbar = _componentsToolbarToolbar.Toolbar;
      ToolbarTitle = _componentsToolbarToolbar.ToolbarTitle;
      ToolbarItem = _componentsToolbarToolbar.ToolbarItem;
    }, function (_componentsIconIcon) {
      Icon = _componentsIconIcon.Icon;
    }, function (_componentsCheckboxCheckbox) {
      Checkbox = _componentsCheckboxCheckbox.Checkbox;
    }, function (_componentsToggleToggle) {
      Toggle = _componentsToggleToggle.Toggle;
    }, function (_componentsTextInputTextInput) {
      TextInput = _componentsTextInputTextInput.TextInput;
      TextInputElement = _componentsTextInputTextInput.TextInputElement;
    }, function (_componentsLabelLabel) {
      Label = _componentsLabelLabel.Label;
    }, function (_componentsSegmentSegment) {
      Segment = _componentsSegmentSegment.Segment;
      SegmentButton = _componentsSegmentSegment.SegmentButton;
    }, function (_componentsRadioRadio) {
      RadioGroup = _componentsRadioRadio.RadioGroup;
      RadioButton = _componentsRadioRadio.RadioButton;
    }, function (_componentsSearchbarSearchbar) {
      Searchbar = _componentsSearchbarSearchbar.Searchbar;
      SearchbarInput = _componentsSearchbarSearchbar.SearchbarInput;
    }, function (_componentsNavNav) {
      Nav = _componentsNavNav.Nav;
    }, function (_componentsNavNavPush) {
      NavPush = _componentsNavNavPush.NavPush;
      NavPop = _componentsNavNavPush.NavPop;
    }, function (_componentsNavNavRouter) {
      NavRouter = _componentsNavNavRouter.NavRouter;
    }, function (_componentsNavbarNavbar) {
      NavbarTemplate = _componentsNavbarNavbar.NavbarTemplate;
      Navbar = _componentsNavbarNavbar.Navbar;
    }, function (_componentsAppId) {
      IdRef = _componentsAppId.IdRef;
    }, function (_componentsShowHideWhenShowHideWhen) {
      ShowWhen = _componentsShowHideWhenShowHideWhen.ShowWhen;
      HideWhen = _componentsShowHideWhenShowHideWhen.HideWhen;
    }],
    execute: function () {
      IONIC_DIRECTIVES = [
      // Angular
      CORE_DIRECTIVES, FORM_DIRECTIVES,
      // Content
      OverlayNav, Menu, MenuToggle, MenuClose, Button, Blur, Content, Scroll, Refresher,
      // Lists
      List, ListHeader, Item, ItemSliding,
      // Slides
      Slides, Slide, SlideLazy,
      // Tabs
      Tabs, Tab,
      // Toolbar
      Toolbar, ToolbarTitle, ToolbarItem,
      // Media
      Icon,
      // Forms
      Searchbar, SearchbarInput, Segment, SegmentButton, Checkbox, RadioGroup, RadioButton, Toggle, TextInput, TextInputElement, Label,
      // Nav
      Nav, NavbarTemplate, Navbar, NavPush, NavPop, NavRouter, IdRef, ShowWhen, HideWhen];

      _export('IONIC_DIRECTIVES', IONIC_DIRECTIVES);
    }
  };
});
System.register('ionic/config/modes', ['./config'], function (_export) {
    // iOS Mode Settings
    'use strict';

    var Config;
    return {
        setters: [function (_config) {
            Config = _config.Config;
        }],
        execute: function () {
            Config.setModeConfig('ios', {
                activator: 'highlight',
                actionSheetEnter: 'action-sheet-slide-in',
                actionSheetLeave: 'action-sheet-slide-out',
                alertEnter: 'alert-pop-in',
                alertLeave: 'alert-pop-out',
                backButtonText: 'Back',
                backButtonIcon: 'ion-ios-arrow-back',
                iconMode: 'ios',
                menuType: 'reveal',
                modalEnter: 'modal-slide-in',
                modalLeave: 'modal-slide-out',
                pageTransition: 'ios-transition',
                pageTransitionDelay: 16,
                tabbarPlacement: 'bottom'
            });
            // Material Design Mode Settings
            Config.setModeConfig('md', {
                activator: 'ripple',
                actionSheetEnter: 'action-sheet-md-slide-in',
                actionSheetLeave: 'action-sheet-md-slide-out',
                alertEnter: 'alert-md-pop-in',
                alertLeave: 'alert-md-pop-out',
                backButtonText: '',
                backButtonIcon: 'ion-md-arrow-back',
                iconMode: 'md',
                menuType: 'overlay',
                modalEnter: 'modal-md-slide-in',
                modalLeave: 'modal-md-slide-out',
                pageTransition: 'md-transition',
                pageTransitionDelay: 120,
                tabbarHighlight: true,
                tabbarPlacement: 'top',
                tabSubPages: true
            });
        }
    };
});
System.register('ionic/decorators/app', ['angular2/core', 'angular2/platform/browser', '../components/tap-click/tap-click', '../config/bootstrap', '../config/directives'], function (_export) {
    /**
    * @name App
    * @description
    * App is an Ionic decorator that bootstraps an application. It can be passed a number of arguments, that act as global config variables for the app.
    * App can accept a `template` property that has an inline template or a `templateUrl` property that points to an external html template.
    *
    * @usage
    * ```ts
    * import {App} from 'ionic/ionic';
    *
    * @App({
    *   templateUrl: 'app/app.html'
    * })
    *
    * export class MyApp{
    *   // Anything we would want to do at the root of our app
    * }
    * ```
    *
    * @param {Object} [config] - the app's [../Config](Config) object
    * @param {String} [template] - the template to use for the app root
    * @param {String} [templateUrl] - a relative URL pointing to the template to use for the app root
    *
    */
    'use strict';

    var Component, bootstrap, TapClick, ionicProviders, IONIC_DIRECTIVES;

    _export('App', App);

    function App() {
        var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        return function (cls) {
            // get current annotations
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            args.selector = 'ion-app';
            // auto add Ionic directives
            args.directives = args.directives ? args.directives.concat(IONIC_DIRECTIVES) : IONIC_DIRECTIVES;
            // if no template was provided, default so it has a root <ion-nav>
            if (!args.templateUrl && !args.template) {
                args.template = '<ion-nav></ion-nav>';
            }
            // create @Component
            annotations.push(new Component(args));
            // redefine with added annotations
            Reflect.defineMetadata('annotations', annotations, cls);
            // define array of bootstrap providers
            var providers = ionicProviders(args).concat(args.providers || []);
            bootstrap(cls, providers).then(function (appRef) {
                appRef.injector.get(TapClick);
            });
            return cls;
        };
    }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
        }, function (_angular2PlatformBrowser) {
            bootstrap = _angular2PlatformBrowser.bootstrap;
        }, function (_componentsTapClickTapClick) {
            TapClick = _componentsTapClickTapClick.TapClick;
        }, function (_configBootstrap) {
            ionicProviders = _configBootstrap.ionicProviders;
        }, function (_configDirectives) {
            IONIC_DIRECTIVES = _configDirectives.IONIC_DIRECTIVES;
        }],
        execute: function () {}
    };
});
System.register('ionic/decorators/config-component', ['angular2/core'], function (_export) {
    /**
     * @private
     */
    'use strict';

    var Component;

    /**
     * @private
     */

    _export('ConfigComponent', ConfigComponent);

    function ConfigComponent(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Component(appendConfig(cls, config)));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function appendConfig(cls, config) {
        config.host = config.host || {};
        cls.defaultInputs = config.defaultInputs || {};
        config.inputs = config.inputs || [];
        for (var prop in cls.defaultInputs) {
            // add the property to the component "inputs"
            config.inputs.push(prop);
            // set the component "hostProperties", so the instance's
            // input value will be used to set the element's attribute
            config.host['[attr.' + prop + ']'] = prop;
        }
        cls.delegates = config.delegates;
        return config;
    }
    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
        }],
        execute: function () {}
    };
});
System.register('ionic/decorators/page', ['angular2/core', '../config/directives'], function (_export) {
    /**
     * @name Page
     * @description
     *For more information on how pages are created, see the [NavController API reference](../../components/nav/NavController/#creating_pages)
     *
     * The Page decorator indicates that the decorated class is an Ionic
     * navigation component, meaning it can be navigated to using a NavController.
     *
     * Pages have all `IONIC_DIRECTIVES`, which include all Ionic components and directives,
     * as well as Angular's [CORE_DIRECTIVES](https://angular.io/docs/js/latest/api/core/CORE_DIRECTIVES-const.html)
     * and [FORM_DIRECTIVES](https://angular.io/docs/js/latest/api/core/FORM_DIRECTIVES-const.html),
     * already provided to them, so you only need to supply custom components and directives to your pages:
     *
     * @usage
     *
     * ```ts
     * @Page({
     *   template: `
     *    <ion-content>
     *      I am a page!
     *    </ion-content>
     *   `
     * })
     * class MyPage {}
     * ```
     *
     * Here [Content](../../../components/content/Content/) will load because
     * it is in `IONIC_DIRECTIVES`, so there is no need to add a `directives` array.
     *
     *
     * Say you built a custom component that uses the already existing Ionic component.
     * In this case, you would add `IONIC_DIRECTIVES` to your directives array.
     *
     * ```ts
     * import {IONIC_DIRECTIVES} from 'ionic/ionic';
     * @Component({
     *   selector: 'my-component'
     *   template: `<div class="my-style">
     *   						  <ion-checkbox></ion-checkbox>
     *   						</div>`,
     *   directives: [IONIC_DIRECTIVES]
     * })
     * class MyCustomCheckbox {}
     *```
    
     * Alternatively, you could:
     *
     * ```ts
     * import {Checkbox, Icon} from 'ionic/ionic'
     * ```
     *
     * along with any other components and add them individually:
     *
     * ```
     * @Component({
     *   ...
     *   directives: [Checkbox, Icon]
     * })
     * ```
     *
     * However, using IONIC_DIRECTIVES will always *Just Work* with no
     * performance overhead, so there is really no reason to not always use it.
     *
     * Pages have their content automatically wrapped in `<ion-view>`, so although
     * you may see these tags if you inspect your markup, you don't need to include
     * them in your templates.
     */
    'use strict';

    var Component, IONIC_DIRECTIVES;

    _export('Page', Page);

    function Page() {
        var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        return function (cls) {
            config.selector = 'ion-page';
            config.directives = config.directives ? config.directives.concat(IONIC_DIRECTIVES) : IONIC_DIRECTIVES;
            config.host = config.host || {};
            config.host['[hidden]'] = '_hidden';
            config.host['[class.tab-subpage]'] = '_tabSubPage';
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Component(config));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
        }, function (_configDirectives) {
            IONIC_DIRECTIVES = _configDirectives.IONIC_DIRECTIVES;
        }],
        execute: function () {}
    };
});
System.register('ionic/platform/platform', ['../util/util', '../util/dom'], function (_export) {
    /**
     * @name Platform
     * @description
     * Platform returns the availble information about your current platform.
     * Platforms in Ionic 2 are much more complex then in V1, returns not just a single platform,
     * but a hierarchy of information, such as a devices OS, phone vs tablet, or mobile vs browser.
     * With this information you can completely custimize your app to fit any device and platform.
     *
     * @usage
     * ```ts
     * import {Platform} 'ionic/ionic';
     * export MyClass {
     *    constructor(platform: Platform){
     *      this.platform = platform;
     *    }
     * }
     * ```
     * @demo /docs/v3/demos/platform/
     */
    'use strict';

    var getQuerystring, extend, ready, windowDimensions, flushDimensionCache, Platform, PlatformNode, platformRegistry, platformDefault;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function insertSuperset(platformNode) {
        var supersetPlaformName = platformNode.superset();
        if (supersetPlaformName) {
            // add a platform in between two exist platforms
            // so we can build the correct hierarchy of active platforms
            var supersetPlatform = new PlatformNode(supersetPlaformName);
            supersetPlatform.parent(platformNode.parent());
            supersetPlatform.child(platformNode);
            if (supersetPlatform.parent()) {
                supersetPlatform.parent().child(supersetPlatform);
            }
            platformNode.parent(supersetPlatform);
        }
    }
    return {
        setters: [function (_utilUtil) {
            getQuerystring = _utilUtil.getQuerystring;
            extend = _utilUtil.extend;
        }, function (_utilDom) {
            ready = _utilDom.ready;
            windowDimensions = _utilDom.windowDimensions;
            flushDimensionCache = _utilDom.flushDimensionCache;
        }],
        execute: function () {
            Platform = (function () {
                function Platform() {
                    var _this = this;

                    var platforms = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

                    _classCallCheck(this, Platform);

                    this._platforms = platforms;
                    this._versions = {};
                    this._dir = null;
                    this._lang = null;
                    this._onResizes = [];
                    this._readyPromise = new Promise(function (res) {
                        _this._readyResolve = res;
                    });
                }

                // Methods
                // **********************************************
                /**
                 * @param {string} platformName
                 * @returns {bool} returns true/false based on platform you place
                 * @description
                 * Depending on the platform name, isPlatform will return true or flase
                 *
                 * ```
                 * import {Platform} 'ionic/ionic';
                 * export MyClass {
                 *    constructor(platform: Platform){
                 *      this.platform = platform;
                 *      if(this.platform.is('ios'){
                 *        // what ever you need to do for
                 *        // if the platfomr is ios
                 *      }
                 *    }
                 * }
                 * ```
                 */

                _createClass(Platform, [{
                    key: 'is',
                    value: function is(platformName) {
                        return this._platforms.indexOf(platformName) > -1;
                    }

                    /**
                     * @returns {array} the array of platforms
                     * @description
                     * Depending on what device you are on, `platforms` can return multiple values.
                     * Each possible value is a hierarchy of platforms. For example, on an iPhone,
                     * it would return mobile, ios, and iphone.
                     *
                     * ```
                     * import {Platform} 'ionic/ionic';
                     * export MyClass {
                     *    constructor(platform: Platform){
                     *      this.platform = platform;
                     *      console.log(this.platform.platforms());
                     *      // This will return an array of all the availble platforms
                     *      // From if your on mobile, to mobile os, and device name
                     *    }
                     * }
                     * ```
                     */
                }, {
                    key: 'platforms',
                    value: function platforms() {
                        // get the array of active platforms, which also knows the hierarchy,
                        // with the last one the most important
                        return this._platforms;
                    }

                    /**
                     * Returns an object containing information about the paltform
                     *
                     * ```
                     * import {Platform} 'ionic/ionic';
                     * export MyClass {
                     *    constructor(platform: Platform){
                     *      this.platform = platform;
                     *      console.log(this.platform.versions());
                     *    }
                     * }
                     * ```
                        * @param {string} [platformName] optional platformName
                     * @returns {object} An object with various platform info
                     *
                     */
                }, {
                    key: 'versions',
                    value: function versions(platformName) {
                        if (arguments.length) {
                            // get a specific platform's version
                            return this._versions[platformName];
                        }
                        // get all the platforms that have a valid parsed version
                        return this._versions;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'version',
                    value: function version() {
                        for (var platformName in this._versions) {
                            if (this._versions[platformName]) {
                                return this._versions[platformName];
                            }
                        }
                        return {};
                    }

                    /**
                     * Returns a promise when the platform is ready and native functionality can be called
                     *
                     * ```
                     * import {Platform} 'ionic/ionic';
                     * export MyClass {
                     *    constructor(platform: Platform){
                     *      this.platform = platform;
                     *      this.platform.ready().then(() => {
                     *        console.log('Platform ready');
                     *        // The platform is now ready, execute any native code you want
                     *       });
                     *    }
                     * }
                     * ```
                     * @returns {promise} Returns a promsie when device ready has fired
                     */
                }, {
                    key: 'ready',
                    value: function ready() {
                        return this._readyPromise;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'prepareReady',
                    value: function prepareReady(config) {
                        var self = this;
                        function resolve() {
                            self._readyResolve(config);
                        }
                        if (this._engineReady) {
                            // the engine provide a ready promise, use this instead
                            this._engineReady(resolve);
                        } else {
                            // there is no custom ready method from the engine
                            // use the default dom ready
                            ready(resolve);
                        }
                    }

                    /**
                    * Set the app's language direction, which will update the `dir` attribute
                    * on the app's root `<html>` element. We recommend the app's `index.html`
                    * file already has the correct `dir` attribute value set, such as
                    * `<html dir="ltr">` or `<html dir="rtl">`. This method is useful if the
                    * direction needs to be dynamically changed per user/session.
                    * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
                    * @param {string} dir  Examples: `rtl`, `ltr`
                    */
                }, {
                    key: 'setDir',
                    value: function setDir(dir, updateDocument) {
                        this._dir = (dir || '').toLowerCase();
                        if (updateDocument !== false) {
                            document.documentElement.setAttribute('dir', dir);
                        }
                    }

                    /**
                     * Returns app's language direction.
                     * We recommend the app's `index.html` file already has the correct `dir`
                     * attribute value set, such as `<html dir="ltr">` or `<html dir="rtl">`.
                     * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
                     * @returns {string}
                     */
                }, {
                    key: 'dir',
                    value: function dir() {
                        return this._dir;
                    }

                    /**
                     * Returns if this app is using right-to-left language direction or not.
                     * We recommend the app's `index.html` file already has the correct `dir`
                     * attribute value set, such as `<html dir="ltr">` or `<html dir="rtl">`.
                     * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
                     * @returns {boolean}
                     */
                }, {
                    key: 'isRTL',
                    value: function isRTL() {
                        return this._dir === 'rtl';
                    }

                    /**
                    * Set the app's language and optionally the country code, which will update
                    * the `lang` attribute on the app's root `<html>` element.
                    * We recommend the app's `index.html` file already has the correct `lang`
                    * attribute value set, such as `<html lang="en">`. This method is useful if
                    * the language needs to be dynamically changed per user/session.
                    * [W3C: Declaring language in HTML](http://www.w3.org/International/questions/qa-html-language-declarations)
                    * @param {string} language  Examples: `en-US`, `en-GB`, `ar`, `de`, `zh`, `es-MX`
                    */
                }, {
                    key: 'setLang',
                    value: function setLang(language, updateDocument) {
                        this._lang = language;
                        if (updateDocument !== false) {
                            document.documentElement.setAttribute('lang', language);
                        }
                    }

                    /**
                     * Returns app's language and optional country code.
                     * We recommend the app's `index.html` file already has the correct `lang`
                     * attribute value set, such as `<html lang="en">`.
                     * [W3C: Declaring language in HTML](http://www.w3.org/International/questions/qa-html-language-declarations)
                     * @returns {string}
                     */
                }, {
                    key: 'lang',
                    value: function lang() {
                        return this._lang;
                    }

                    // Methods meant to be overridden by the engine
                    // **********************************************
                    // Provided NOOP methods so they do not error when
                    // called by engines (the browser) doesn't provide them
                    /**
                    * @private
                    */
                }, {
                    key: 'on',
                    value: function on() {}

                    /**
                    * @private
                    */
                }, {
                    key: 'onHardwareBackButton',
                    value: function onHardwareBackButton() {}

                    /**
                    * @private
                    */
                }, {
                    key: 'registerBackButtonAction',
                    value: function registerBackButtonAction() {}

                    /**
                    * @private
                    */
                }, {
                    key: 'exitApp',
                    value: function exitApp() {}

                    /**
                    * @private
                    */
                }, {
                    key: 'fullScreen',
                    value: function fullScreen() {}

                    /**
                    * @private
                    */
                }, {
                    key: 'showStatusBar',
                    value: function showStatusBar() {}

                    // Getter/Setter Methods
                    // **********************************************
                    /**
                    * @private
                    */
                }, {
                    key: 'url',
                    value: function url(val) {
                        if (arguments.length) {
                            this._url = val;
                            this._qs = getQuerystring(val);
                        }
                        return this._url;
                    }

                    /**
                    * @private
                    */
                }, {
                    key: 'query',
                    value: function query(key) {
                        return (this._qs || {})[key];
                    }

                    /**
                    * @private
                    */
                }, {
                    key: 'userAgent',
                    value: function userAgent(val) {
                        if (arguments.length) {
                            this._ua = val;
                        }
                        return this._ua || '';
                    }

                    /**
                    * @private
                    */
                }, {
                    key: 'navigatorPlatform',
                    value: function navigatorPlatform(val) {
                        if (arguments.length) {
                            this._bPlt = val;
                        }
                        return this._bPlt || '';
                    }

                    /**
                    * @private
                    */
                }, {
                    key: 'width',
                    value: function width() {
                        return windowDimensions().width;
                    }

                    /**
                    * @private
                    */
                }, {
                    key: 'height',
                    value: function height() {
                        return windowDimensions().height;
                    }

                    /**
                    * @private
                    */
                }, {
                    key: 'isPortrait',
                    value: function isPortrait() {
                        return this.width() < this.height();
                    }

                    /**
                    * @private
                    */
                }, {
                    key: 'isLandscape',
                    value: function isLandscape() {
                        return !this.isPortrait();
                    }

                    /**
                    * @private
                    */
                }, {
                    key: 'windowResize',
                    value: function windowResize() {
                        var self = this;
                        clearTimeout(self._resizeTimer);
                        self._resizeTimer = setTimeout(function () {
                            flushDimensionCache();
                            for (var i = 0; i < self._onResizes.length; i++) {
                                try {
                                    self._onResizes[i]();
                                } catch (e) {
                                    console.error(e);
                                }
                            }
                        }, 250);
                    }

                    /**
                    * @private
                    */
                }, {
                    key: 'onResize',
                    value: function onResize(cb) {
                        this._onResizes.push(cb);
                    }

                    // Platform Registry
                    // **********************************************
                    /**
                     * @private
                     */
                }, {
                    key: 'testQuery',

                    /**
                     * @private
                     */
                    value: function testQuery(queryValue, queryTestValue) {
                        var valueSplit = queryValue.toLowerCase().split(';');
                        return valueSplit.indexOf(queryTestValue) > -1;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'testUserAgent',
                    value: function testUserAgent(userAgentExpression) {
                        var rgx = new RegExp(userAgentExpression, 'i');
                        return rgx.test(this._ua || '');
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'testNavigatorPlatform',
                    value: function testNavigatorPlatform(navigatorPlatformExpression) {
                        var rgx = new RegExp(navigatorPlatformExpression, 'i');
                        return rgx.test(this._bPlt);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'matchUserAgentVersion',
                    value: function matchUserAgentVersion(userAgentExpression) {
                        if (this._ua && userAgentExpression) {
                            var val = this._ua.match(userAgentExpression);
                            if (val) {
                                return {
                                    major: val[1],
                                    minor: val[2]
                                };
                            }
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'isPlatform',
                    value: function isPlatform(queryTestValue, userAgentExpression) {
                        if (!userAgentExpression) {
                            userAgentExpression = queryTestValue;
                        }
                        var queryValue = this.query('ionicplatform');
                        if (queryValue) {
                            return this.testQuery(queryValue, queryTestValue);
                        }
                        return this.testUserAgent(userAgentExpression);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'load',
                    value: function load(platformOverride) {
                        var rootPlatformNode = null;
                        var engineNode = null;
                        var self = this;
                        this.platformOverride = platformOverride;
                        // figure out the most specific platform and active engine
                        var tmpPlatform = null;
                        for (var platformName in platformRegistry) {
                            tmpPlatform = this.matchPlatform(platformName);
                            if (tmpPlatform) {
                                // we found a platform match!
                                // check if its more specific than the one we already have
                                if (tmpPlatform.isEngine) {
                                    // because it matched then this should be the active engine
                                    // you cannot have more than one active engine
                                    engineNode = tmpPlatform;
                                } else if (!rootPlatformNode || tmpPlatform.depth > rootPlatformNode.depth) {
                                    // only find the root node for platforms that are not engines
                                    // set this node as the root since we either don't already
                                    // have one, or this one is more specific that the current one
                                    rootPlatformNode = tmpPlatform;
                                }
                            }
                        }
                        if (!rootPlatformNode) {
                            rootPlatformNode = new PlatformNode(platformDefault);
                        }
                        // build a Platform instance filled with the
                        // hierarchy of active platforms and settings
                        if (rootPlatformNode) {
                            // check if we found an engine node (cordova/node-webkit/etc)
                            if (engineNode) {
                                // add the engine to the first in the platform hierarchy
                                // the original rootPlatformNode now becomes a child
                                // of the engineNode, which is not the new root
                                engineNode.child(rootPlatformNode);
                                rootPlatformNode.parent(engineNode);
                                rootPlatformNode = engineNode;
                                // add any events which the engine would provide
                                // for example, Cordova provides its own ready event
                                var engineMethods = engineNode.methods();
                                engineMethods._engineReady = engineMethods.ready;
                                delete engineMethods.ready;
                                extend(this, engineMethods);
                            }
                            var platformNode = rootPlatformNode;
                            while (platformNode) {
                                insertSuperset(platformNode);
                                platformNode = platformNode.child();
                            }
                            // make sure the root noot is actually the root
                            // incase a node was inserted before the root
                            platformNode = rootPlatformNode.parent();
                            while (platformNode) {
                                rootPlatformNode = platformNode;
                                platformNode = platformNode.parent();
                            }
                            platformNode = rootPlatformNode;
                            while (platformNode) {
                                // set the array of active platforms with
                                // the last one in the array the most important
                                this._platforms.push(platformNode.name());
                                // get the platforms version if a version parser was provided
                                this._versions[platformNode.name()] = platformNode.version(this);
                                // go to the next platform child
                                platformNode = platformNode.child();
                            }
                        }
                        if (this._platforms.indexOf('mobile') > -1 && this._platforms.indexOf('cordova') === -1) {
                            this._platforms.push('mobileweb');
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'matchPlatform',
                    value: function matchPlatform(platformName) {
                        // build a PlatformNode and assign config data to it
                        // use it's getRoot method to build up its hierarchy
                        // depending on which platforms match
                        var platformNode = new PlatformNode(platformName);
                        var rootNode = platformNode.getRoot(this, 0);
                        if (rootNode) {
                            rootNode.depth = 0;
                            var childPlatform = rootNode.child();
                            while (childPlatform) {
                                rootNode.depth++;
                                childPlatform = childPlatform.child();
                            }
                        }
                        return rootNode;
                    }
                }], [{
                    key: 'register',
                    value: function register(platformConfig) {
                        platformRegistry[platformConfig.name] = platformConfig;
                    }

                    /**
                    * @private
                    */
                }, {
                    key: 'registry',
                    value: function registry() {
                        return platformRegistry;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'get',
                    value: function get(platformName) {
                        return platformRegistry[platformName] || {};
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'setDefault',
                    value: function setDefault(platformName) {
                        platformDefault = platformName;
                    }
                }]);

                return Platform;
            })();

            _export('Platform', Platform);

            PlatformNode = (function () {
                function PlatformNode(platformName) {
                    _classCallCheck(this, PlatformNode);

                    this.c = Platform.get(platformName);
                    this.isEngine = this.c.isEngine;
                }

                _createClass(PlatformNode, [{
                    key: 'name',
                    value: function name() {
                        return this.c.name;
                    }
                }, {
                    key: 'settings',
                    value: function settings() {
                        return this.c.settings || {};
                    }
                }, {
                    key: 'superset',
                    value: function superset() {
                        return this.c.superset;
                    }
                }, {
                    key: 'methods',
                    value: function methods() {
                        return this.c.methods || {};
                    }
                }, {
                    key: 'parent',
                    value: function parent(val) {
                        if (arguments.length) {
                            this._parent = val;
                        }
                        return this._parent;
                    }
                }, {
                    key: 'child',
                    value: function child(val) {
                        if (arguments.length) {
                            this._child = val;
                        }
                        return this._child;
                    }
                }, {
                    key: 'isMatch',
                    value: function isMatch(p) {
                        if (p.platformOverride && !this.isEngine) {
                            return p.platformOverride === this.c.name;
                        } else if (!this.c.isMatch) {
                            return false;
                        }
                        return this.c.isMatch(p);
                    }
                }, {
                    key: 'version',
                    value: function version(p) {
                        if (this.c.versionParser) {
                            var v = this.c.versionParser(p);
                            if (v) {
                                var str = v.major + '.' + v.minor;
                                return {
                                    str: str,
                                    num: parseFloat(str),
                                    major: parseInt(v.major, 10),
                                    minor: parseInt(v.minor, 10)
                                };
                            }
                        }
                    }
                }, {
                    key: 'getRoot',
                    value: function getRoot(p) {
                        if (this.isMatch(p)) {
                            var parents = this.getSubsetParents(this.name());
                            if (!parents.length) {
                                return this;
                            }
                            var platform = null;
                            var rootPlatform = null;
                            for (var i = 0; i < parents.length; i++) {
                                platform = new PlatformNode(parents[i]);
                                platform.child(this);
                                rootPlatform = platform.getRoot(p);
                                if (rootPlatform) {
                                    this.parent(platform);
                                    return rootPlatform;
                                }
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getSubsetParents',
                    value: function getSubsetParents(subsetPlatformName) {
                        var platformRegistry = Platform.registry();
                        var parentPlatformNames = [];
                        var platform = null;
                        for (var platformName in platformRegistry) {
                            platform = platformRegistry[platformName];
                            if (platform.subsets && platform.subsets.indexOf(subsetPlatformName) > -1) {
                                parentPlatformNames.push(platformName);
                            }
                        }
                        return parentPlatformNames;
                    }
                }]);

                return PlatformNode;
            })();

            platformRegistry = {};
            platformDefault = null;
        }
    };
});
System.register('ionic/platform/registry', ['./platform', '../util/dom'], function (_export) {
    'use strict';

    var Platform, windowLoad;

    function isIOSDevice(p) {
        // shortcut function to be reused internally
        // checks navigator.platform to see if it's an actual iOS device
        // this does not use the user-agent string because it is often spoofed
        // an actual iPad will return true, a chrome dev tools iPad will return false
        return p.testNavigatorPlatform('iphone|ipad|ipod');
    }
    return {
        setters: [function (_platform) {
            Platform = _platform.Platform;
        }, function (_utilDom) {
            windowLoad = _utilDom.windowLoad;
        }],
        execute: function () {
            Platform.register({
                name: 'core',
                settings: {
                    mode: 'ios',
                    keyboardHeight: 290
                }
            });
            Platform.setDefault('core');
            Platform.register({
                name: 'mobile'
            });
            Platform.register({
                name: 'phablet',
                isMatch: function isMatch(p) {
                    var smallest = Math.min(p.width(), p.height());
                    var largest = Math.max(p.width(), p.height());
                    return smallest > 390 && smallest < 520 && largest > 620 && largest < 800;
                }
            });
            Platform.register({
                name: 'tablet',
                isMatch: function isMatch(p) {
                    var smallest = Math.min(p.width(), p.height());
                    var largest = Math.max(p.width(), p.height());
                    return smallest > 460 && smallest < 820 && largest > 780 && largest < 1400;
                }
            });
            Platform.register({
                name: 'android',
                superset: 'mobile',
                subsets: ['phablet', 'tablet'],
                settings: {
                    activator: function activator(p) {
                        // md mode defaults to use ripple activator
                        // however, under-powered devices shouldn't use ripple
                        // if this a linux device, and is using Android Chrome v36 (Android 5.0)
                        // or above then use ripple, otherwise do not use a ripple effect
                        if (p.testNavigatorPlatform('linux')) {
                            var chromeVersion = p.matchUserAgentVersion(/Chrome\/(\d+).(\d+)?/);
                            if (chromeVersion) {
                                // linux android device using modern android chrome browser gets ripple
                                return parseInt(chromeVersion.major, 10) < 36 ? 'none' : 'ripple';
                            }
                            // linux android device not using chrome browser checks just android's version
                            if (p.version().major < 5) {
                                return 'none';
                            }
                        }
                        // fallback to always use ripple
                        return 'ripple';
                    },
                    hoverCSS: false,
                    keyboardHeight: 300,
                    mode: 'md',
                    scrollAssist: true
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('android', 'android|silk');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/Android (\d+).(\d+)?/);
                }
            });
            Platform.register({
                name: 'ios',
                superset: 'mobile',
                subsets: ['ipad', 'iphone'],
                settings: {
                    clickBlock: true,
                    hoverCSS: false,
                    keyboardHeight: 300,
                    mode: 'ios',
                    scrollAssist: isIOSDevice,
                    swipeBackEnabled: isIOSDevice,
                    swipeBackThreshold: 40,
                    tapPolyfill: isIOSDevice
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('ios', 'iphone|ipad|ipod');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/OS (\d+)_(\d+)?/);
                }
            });
            Platform.register({
                name: 'ipad',
                superset: 'tablet',
                settings: {
                    keyboardHeight: 500
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('ipad');
                }
            });
            Platform.register({
                name: 'iphone',
                subsets: ['phablet'],
                isMatch: function isMatch(p) {
                    return p.isPlatform('iphone');
                }
            });
            Platform.register({
                name: 'windowsphone',
                superset: 'mobile',
                subsets: ['phablet', 'tablet'],
                settings: {
                    mode: 'md'
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('windowsphone', 'windows phone');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/Windows Phone (\d+).(\d+)?/);
                }
            });
            Platform.register({
                name: 'cordova',
                isEngine: true,
                methods: {
                    ready: function ready(resolve) {
                        function isReady() {
                            document.removeEventListener('deviceready', isReady);
                            resolve();
                        }
                        windowLoad(function () {
                            document.addEventListener('deviceready', isReady);
                        });
                    }
                },
                isMatch: function isMatch() {
                    return !!(window.cordova || window.PhoneGap || window.phonegap);
                }
            });
        }
    };
});
System.register('ionic/platform/storage', ['./storage/storage', './storage/local-storage', './storage/sql'], function (_export) {
  'use strict';

  return {
    setters: [function (_storageStorage) {
      for (var _key in _storageStorage) {
        if (_key !== 'default') _export(_key, _storageStorage[_key]);
      }
    }, function (_storageLocalStorage) {
      for (var _key2 in _storageLocalStorage) {
        if (_key2 !== 'default') _export(_key2, _storageLocalStorage[_key2]);
      }
    }, function (_storageSql) {
      for (var _key3 in _storageSql) {
        if (_key3 !== 'default') _export(_key3, _storageSql[_key3]);
      }
    }],
    execute: function () {}
  };
});
System.register("ionic/translation/translate", ["angular2/core"], function (_export) {
    /**
     * @private
     * Provide multi-language and i18n support in your app. Translate works by
     * mapping full strings to language translated ones. That means that you don't need
     * to provide strings for your default language, just new languages.
     *
     * @usage
     * ```js
     * Translate.translations({
     *   'de': {
     *     'Welcome to MyApp': 'Willkommen auf'
     *   }
     * })
     *
     * Changing the default language:
     *
     * Translate.setLanguage('de');
     * ```
     *
     * Usage in a template:
     *
     * ```js
     * <span>{{ 'Welcome to MyApp' | translate }}
     * ```
     */
    "use strict";

    var Injectable, __decorate, __metadata, Translate;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Injectable = _angular2Core.Injectable;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Translate = (function () {
                function Translate() {
                    _classCallCheck(this, Translate);

                    this._transMap = {};
                }

                _createClass(Translate, [{
                    key: "translations",
                    value: function translations(lang, map) {
                        this._transMap[lang] = map;
                    }
                }, {
                    key: "setLanguage",
                    value: function setLanguage(lang) {
                        this._language = lang;
                    }
                }, {
                    key: "getTranslations",
                    value: function getTranslations(lang) {
                        return this._transMap[lang];
                    }
                }, {
                    key: "translate",
                    value: function translate(key, lang) {
                        // If the language isn't specified and we have no overridden one, return the string passed.
                        if (!lang && !this._language) {
                            return key;
                        }
                        var setLanguage = lang || this._language;
                        var map = this.getTranslations(setLanguage);
                        if (!map) {
                            console.warn('I18N: No translation for key', key, 'using language', setLanguage);
                            return '';
                        }
                        return this._getTranslation(map, key);
                    }
                }, {
                    key: "_getTranslation",
                    value: function _getTranslation(map, key) {
                        return map && map[key] || '';
                    }
                }]);

                return Translate;
            })();

            _export("Translate", Translate);

            _export("Translate", Translate = __decorate([Injectable(), __metadata('design:paramtypes', [])], Translate));
        }
    };
});
System.register("ionic/translation/translate_pipe", ["angular2/core", "./translate"], function (_export) {
    /**
     * @private
     * The Translate pipe makes it easy to translate strings.
     *
     * @usage
     * Translate using the current language or language set through Translate.setLanguage
     * {{ 'Please enter your location' | translate }}
     *
     * Translate using a specific language
     * {{ 'Please enter your location' | translate:"de" }}
     */
    "use strict";

    var Injectable, Pipe, Translate, __decorate, __metadata, TranslatePipe, _a;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Injectable = _angular2Core.Injectable;
            Pipe = _angular2Core.Pipe;
        }, function (_translate) {
            Translate = _translate.Translate;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            TranslatePipe = (function () {
                function TranslatePipe(translate) {
                    _classCallCheck(this, TranslatePipe);

                    this.translate = translate;
                }

                _createClass(TranslatePipe, [{
                    key: "transform",
                    value: function transform(value, args) {
                        var lang = undefined;
                        if (args.length > 0) {
                            lang = args[0];
                        }
                        return this.translate.translate(value, lang);
                    }
                }, {
                    key: "supports",
                    value: function supports(obj) {
                        return true;
                    }
                }]);

                return TranslatePipe;
            })();

            _export("TranslatePipe", TranslatePipe);

            _export("TranslatePipe", TranslatePipe = __decorate([Pipe({ name: 'translate' }), Injectable(), __metadata('design:paramtypes', [typeof (_a = typeof Translate !== 'undefined' && Translate) === 'function' && _a || Object])], TranslatePipe));
        }
    };
});
System.register('ionic/gestures/drag-gesture', ['./gesture', '../util'], function (_export) {
    'use strict';

    var Gesture, util, DragGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_gesture) {
            Gesture = _gesture.Gesture;
        }, function (_util) {
            util = _util;
        }],
        execute: function () {
            DragGesture = (function (_Gesture) {
                _inherits(DragGesture, _Gesture);

                function DragGesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, DragGesture);

                    util.defaults(opts, {});
                    _get(Object.getPrototypeOf(DragGesture.prototype), 'constructor', this).call(this, element, opts);
                }

                _createClass(DragGesture, [{
                    key: 'listen',
                    value: function listen() {
                        var _this = this;

                        _get(Object.getPrototypeOf(DragGesture.prototype), 'listen', this).call(this);
                        this.on('panstart', function (ev) {
                            if (_this.onDragStart(ev) !== false) {
                                _this.dragging = true;
                            }
                        });
                        this.on('panmove', function (ev) {
                            if (!_this.dragging) return;
                            if (_this.onDrag(ev) === false) {
                                _this.dragging = false;
                            }
                        });
                        this.on('panend', function (ev) {
                            if (!_this.dragging) return;
                            _this.onDragEnd(ev);
                            _this.dragging = false;
                        });
                        this.hammertime.get('pan').set(this._options);
                    }
                }, {
                    key: 'onDrag',
                    value: function onDrag() {}
                }, {
                    key: 'onDragStart',
                    value: function onDragStart() {}
                }, {
                    key: 'onDragEnd',
                    value: function onDragEnd() {}
                }]);

                return DragGesture;
            })(Gesture);

            _export('DragGesture', DragGesture);
        }
    };
});
System.register('ionic/gestures/gesture', ['../util', './hammer'], function (_export) {
    /**
     * A gesture recognizer class.
     *
     * TODO(mlynch): Re-enable the DOM event simulation that was causing issues (or verify hammer does this already, it might);
     */
    'use strict';

    var util, Hammer, Gesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_util) {
            util = _util;
        }, function (_hammer) {
            Hammer = _hammer.Hammer;
        }],
        execute: function () {
            Gesture = (function () {
                function Gesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, Gesture);

                    util.defaults(opts, {
                        domEvents: true
                    });
                    this.element = element;
                    // Map 'x' or 'y' string to hammerjs opts
                    this.direction = opts.direction || 'x';
                    opts.direction = this.direction === 'x' ? Hammer.DIRECTION_HORIZONTAL : Hammer.DIRECTION_VERTICAL;
                    this._options = opts;
                    this._callbacks = {};
                }

                _createClass(Gesture, [{
                    key: 'options',
                    value: function options() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        util.extend(this._options, opts);
                    }
                }, {
                    key: 'on',
                    value: function on(type, cb) {
                        if (type == 'pinch' || type == 'rotate') {
                            this.hammertime.get('pinch').set({ enable: true });
                        }
                        this.hammertime.on(type, cb);
                        (this._callbacks[type] || (this._callbacks[type] = [])).push(cb);
                    }
                }, {
                    key: 'off',
                    value: function off(type, cb) {
                        this.hammertime.off(type, this._callbacks[type] ? cb : null);
                    }
                }, {
                    key: 'listen',
                    value: function listen() {
                        this.hammertime = Hammer(this.element, this._options);
                    }
                }, {
                    key: 'unlisten',
                    value: function unlisten() {
                        if (this.hammertime) {
                            for (var type in this._callbacks) {
                                for (var i = 0; i < this._callbacks[type].length; i++) {
                                    this.hammertime.off(type, this._callbacks[type]);
                                }
                            }
                            this.hammertime.destroy();
                            this.hammertime = null;
                            this._callbacks = {};
                        }
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.unlisten();
                    }
                }]);

                return Gesture;
            })();

            _export('Gesture', Gesture);
        }
    };
});
System.register('ionic/gestures/hammer', [], function (_export) {
    /*! Hammer.JS - v2.0.4 - 2014-09-28
     * http://hammerjs.github.io/
     *
     * Copyright (c) 2014 Jorik Tangelder;
     * Licensed under the MIT license */
    'use strict';

    var VENDOR_PREFIXES, TEST_ELEMENT, TYPE_FUNCTION, round, abs, now, _uniqueId, MOBILE_REGEX, SUPPORT_TOUCH, SUPPORT_POINTER_EVENTS, SUPPORT_ONLY_TOUCH, INPUT_TYPE_TOUCH, INPUT_TYPE_PEN, INPUT_TYPE_MOUSE, INPUT_TYPE_KINECT, COMPUTE_INTERVAL, INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, DIRECTION_NONE, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, PROPS_XY, PROPS_CLIENT_XY, MOUSE_INPUT_MAP, MOUSE_ELEMENT_EVENTS, MOUSE_WINDOW_EVENTS, POINTER_INPUT_MAP, IE10_POINTER_TYPE_ENUM, POINTER_ELEMENT_EVENTS, POINTER_WINDOW_EVENTS, SINGLE_TOUCH_INPUT_MAP, SINGLE_TOUCH_TARGET_EVENTS, SINGLE_TOUCH_WINDOW_EVENTS, TOUCH_INPUT_MAP, TOUCH_TARGET_EVENTS, PREFIXED_TOUCH_ACTION, NATIVE_TOUCH_ACTION, TOUCH_ACTION_COMPUTE, TOUCH_ACTION_AUTO, TOUCH_ACTION_MANIPULATION, TOUCH_ACTION_NONE, TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_ENDED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, STOP, FORCED_STOP;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;
        if (!obj) {
            return;
        }
        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }
    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge]
     * @returns {Object} dest
     */
    function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }
    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    function merge(dest, src) {
        return extend(dest, src, true);
    }
    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
            extend(childP, properties);
        }
    }
    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }
    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            //console.debug('hammer addEventListener', type, target.tagName);
            target.addEventListener(type, handler, false);
        });
    }
    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            //console.debug('hammer removeEventListener', type, target.tagName);
            target.removeEventListener(type, handler, false);
        });
    }
    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }
    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }
        return results;
    }
    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }
    /**
     * get a unique id
     * @returns {number} uniqueId
     */

    function uniqueId() {
        return _uniqueId++;
    }
    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument;
        return doc.defaultView || doc.parentWindow;
    }

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function (ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };
        this.init();
    }

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
    }
    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
            manager.session = {};
        }
        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;
        // compute scale, rotation etc
        computeInputData(manager, input);
        // emit secret event
        manager.emit('hammer.input', input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }
        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        computeIntervalInputData(session, input);
        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity,
            velocityX,
            velocityY,
            direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = last.deltaX - input.deltaX;
            var deltaY = last.deltaY - input.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;
        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }
        var x = 0,
            y = 0,
            i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.allow = true; // used by Input.TouchMouse to disable mouse events
        this.pressed = false; // mousedown state
        Input.apply(this, arguments);
    }

    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }
        return [all, changed];
    }

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }
        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;
        // get target touches from touches
        targetTouches = allTouches.filter(function (touch) {
            return hasParent(touch.target, target);
        });
        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }
            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }
        if (!changedTargetTouches.length) {
            return;
        }
        return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
    }
    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
    }

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        // pan-x and pan-y can be combined
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
        }
        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
    }
    /**
     * Recognizer flow explained; *
     * All recognizers have the initial state of POSSIBLE when a input session starts.
     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
     * Example session for mouse-input: mousedown -> mousemove -> mouseup
     *
     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
     * which determines with state it should be.
     *
     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
     * POSSIBLE to give it another change on the next cycle.
     *
     *               Possible
     *                  |
     *            +-----+---------------+
     *            |                     |
     *      +-----+-----+               |
     *      |           |               |
     *   Failed      Cancelled          |
     *                          +-------+------+
     *                          |              |
     *                      Recognized       Began
     *                                         |
     *                                      Changed
     *                                         |
     *                                  Ended/Recognized
     */

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.id = uniqueId();
        this.manager = null;
        this.options = merge(options || {}, this.defaults);
        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }
    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }
    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }
    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    /**
     * Simple way to create an manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }
    /**
     * @const {string}
     */

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        options = options || {};
        this.options = merge(options, Hammer.defaults);
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(options.recognizers, function (item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        each(manager.options.cssProps, function (value, name) {
            element.style[prefixed(element.style, name)] = add ? value : '';
        });
    }
    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    return {
        setters: [],
        execute: function () {
            VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
            TEST_ELEMENT = document.createElement('div');
            TYPE_FUNCTION = 'function';
            round = Math.round;
            abs = Math.abs;
            now = Date.now;
            _uniqueId = 1;
            MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
            SUPPORT_TOUCH = 'ontouchstart' in window;
            SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
            SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
            INPUT_TYPE_TOUCH = 'touch';
            INPUT_TYPE_PEN = 'pen';
            INPUT_TYPE_MOUSE = 'mouse';
            INPUT_TYPE_KINECT = 'kinect';
            COMPUTE_INTERVAL = 25;
            INPUT_START = 1;
            INPUT_MOVE = 2;
            INPUT_END = 4;
            INPUT_CANCEL = 8;
            DIRECTION_NONE = 1;
            DIRECTION_LEFT = 2;
            DIRECTION_RIGHT = 4;
            DIRECTION_UP = 8;
            DIRECTION_DOWN = 16;
            DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
            DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
            DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
            PROPS_XY = ['x', 'y'];
            PROPS_CLIENT_XY = ['clientX', 'clientY'];
            Input.prototype = {
                /**
                 * should handle the inputEvent data and trigger the callback
                 * @virtual
                 */
                handler: function handler() {},
                /**
                 * bind the events
                 */
                init: function init() {
                    //console.debug('hammer Input init')
                    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                },
                /**
                 * unbind the events
                 */
                destroy: function destroy() {
                    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                }
            };MOUSE_INPUT_MAP = {
                mousedown: INPUT_START,
                mousemove: INPUT_MOVE,
                mouseup: INPUT_END
            };
            MOUSE_ELEMENT_EVENTS = 'mousedown';
            MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
            inherit(MouseInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function MEhandler(ev) {
                    var eventType = MOUSE_INPUT_MAP[ev.type];
                    // on start we want to have the left mouse button down
                    if (eventType & INPUT_START && ev.button === 0) {
                        this.pressed = true;
                    }
                    if (eventType & INPUT_MOVE && ev.which !== 1) {
                        eventType = INPUT_END;
                    }
                    // mouse must be down, and mouse events are allowed (see the TouchMouse input)
                    if (!this.pressed || !this.allow) {
                        return;
                    }
                    if (eventType & INPUT_END) {
                        this.pressed = false;
                    }
                    this.callback(this.manager, eventType, {
                        pointers: [ev],
                        changedPointers: [ev],
                        pointerType: INPUT_TYPE_MOUSE,
                        srcEvent: ev
                    });
                }
            });
            POINTER_INPUT_MAP = {
                pointerdown: INPUT_START,
                pointermove: INPUT_MOVE,
                pointerup: INPUT_END,
                pointercancel: INPUT_CANCEL,
                pointerout: INPUT_CANCEL
            };

            // in IE10 the pointer types is defined as an enum
            IE10_POINTER_TYPE_ENUM = {
                2: INPUT_TYPE_TOUCH,
                3: INPUT_TYPE_PEN,
                4: INPUT_TYPE_MOUSE,
                5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
            };
            POINTER_ELEMENT_EVENTS = 'pointerdown';
            POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

            // IE10 has prefixed support, and case-sensitive
            if (window.MSPointerEvent) {
                POINTER_ELEMENT_EVENTS = 'MSPointerDown';
                POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
            }inherit(PointerEventInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function PEhandler(ev) {
                    var store = this.store;
                    var removePointer = false;
                    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
                    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
                    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
                    var isTouch = pointerType == INPUT_TYPE_TOUCH;
                    // get index of the event in the store
                    var storeIndex = inArray(store, ev.pointerId, 'pointerId');
                    // start and mouse must be down
                    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                        if (storeIndex < 0) {
                            store.push(ev);
                            storeIndex = store.length - 1;
                        }
                    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                        removePointer = true;
                    }
                    // it not found, so the pointer hasn't been down (so it's probably a hover)
                    if (storeIndex < 0) {
                        return;
                    }
                    // update the event in the store
                    store[storeIndex] = ev;
                    this.callback(this.manager, eventType, {
                        pointers: store,
                        changedPointers: [ev],
                        pointerType: pointerType,
                        srcEvent: ev
                    });
                    if (removePointer) {
                        // remove from the store
                        store.splice(storeIndex, 1);
                    }
                }
            });
            SINGLE_TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
            SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
            inherit(SingleTouchInput, Input, {
                handler: function TEhandler(ev) {
                    var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
                    // should we handle the touch events?
                    if (type === INPUT_START) {
                        this.started = true;
                    }
                    if (!this.started) {
                        return;
                    }
                    var touches = normalizeSingleTouches.call(this, ev, type);
                    // when done, reset the started state
                    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                        this.started = false;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
            inherit(TouchInput, Input, {
                handler: function MTEhandler(ev) {
                    var type = TOUCH_INPUT_MAP[ev.type];
                    var touches = getTouches.call(this, ev, type);
                    if (!touches) {
                        return;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });inherit(TouchMouseInput, Input, {
                /**
                 * handle mouse and touch events
                 * @param {Hammer} manager
                 * @param {String} inputEvent
                 * @param {Object} inputData
                 */
                handler: function TMEhandler(manager, inputEvent, inputData) {
                    var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
                        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
                    // when we're in a touch event, so  block all upcoming mouse events
                    // most mobile browser also emit mouseevents, right after touchstart
                    if (isTouch) {
                        this.mouse.allow = false;
                    } else if (isMouse && !this.mouse.allow) {
                        return;
                    }
                    // reset the allowMouse when we're done
                    if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
                        this.mouse.allow = true;
                    }
                    this.callback(manager, inputEvent, inputData);
                },
                /**
                 * remove the event listeners
                 */
                destroy: function destroy() {
                    this.touch.destroy();
                    this.mouse.destroy();
                }
            });
            PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
            NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

            // magical touchAction value
            TOUCH_ACTION_COMPUTE = 'compute';
            TOUCH_ACTION_AUTO = 'auto';
            TOUCH_ACTION_MANIPULATION = 'manipulation';
            // not implemented
            TOUCH_ACTION_NONE = 'none';
            TOUCH_ACTION_PAN_X = 'pan-x';
            TOUCH_ACTION_PAN_Y = 'pan-y';
            TouchAction.prototype = {
                /**
                 * set the touchAction value on the element or enable the polyfill
                 * @param {String} value
                 */
                set: function set(value) {
                    // find out the touch-action by the event handlers
                    if (value == TOUCH_ACTION_COMPUTE) {
                        value = this.compute();
                    }
                    if (NATIVE_TOUCH_ACTION) {
                        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                    }
                    this.actions = value.toLowerCase().trim();
                },
                /**
                 * just re-set the touchAction value
                 */
                update: function update() {
                    this.set(this.manager.options.touchAction);
                },
                /**
                 * compute the value for the touchAction property based on the recognizer's settings
                 * @returns {String} value
                 */
                compute: function compute() {
                    var actions = [];
                    each(this.manager.recognizers, function (recognizer) {
                        if (boolOrFn(recognizer.options.enable, [recognizer])) {
                            actions = actions.concat(recognizer.getTouchAction());
                        }
                    });
                    return cleanTouchActions(actions.join(' '));
                },
                /**
                 * this method is called on each input cycle and provides the preventing of the browser behavior
                 * @param {Object} input
                 */
                preventDefaults: function preventDefaults(input) {
                    // not needed with native support for the touchAction property
                    if (NATIVE_TOUCH_ACTION) {
                        return;
                    }
                    var srcEvent = input.srcEvent;
                    var direction = input.offsetDirection;
                    // if the touch action did prevented once this session
                    if (this.manager.session.prevented) {
                        srcEvent.preventDefault();
                        return;
                    }
                    var actions = this.actions;
                    var hasNone = inStr(actions, TOUCH_ACTION_NONE);
                    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
                    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
                    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                        return this.preventSrc(srcEvent);
                    }
                },
                /**
                 * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
                 * @param {Object} srcEvent
                 */
                preventSrc: function preventSrc(srcEvent) {
                    this.manager.session.prevented = true;
                    srcEvent.preventDefault();
                }
            };STATE_POSSIBLE = 1;
            STATE_BEGAN = 2;
            STATE_CHANGED = 4;
            STATE_ENDED = 8;
            STATE_RECOGNIZED = STATE_ENDED;
            STATE_CANCELLED = 16;
            STATE_FAILED = 32;
            Recognizer.prototype = {
                /**
                 * @virtual
                 * @type {Object}
                 */
                defaults: {},
                /**
                 * set options
                 * @param {Object} options
                 * @return {Recognizer}
                 */
                set: function set(options) {
                    extend(this.options, options);
                    // also update the touchAction, in case something changed about the directions/enabled state
                    this.manager && this.manager.touchAction.update();
                    return this;
                },
                /**
                 * recognize simultaneous with an other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                recognizeWith: function recognizeWith(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                        return this;
                    }
                    var simultaneous = this.simultaneous;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (!simultaneous[otherRecognizer.id]) {
                        simultaneous[otherRecognizer.id] = otherRecognizer;
                        otherRecognizer.recognizeWith(this);
                    }
                    return this;
                },
                /**
                 * drop the simultaneous link. it doesnt remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    delete this.simultaneous[otherRecognizer.id];
                    return this;
                },
                /**
                 * recognizer can only run when an other is failing
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                requireFailure: function requireFailure(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                        return this;
                    }
                    var requireFail = this.requireFail;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (inArray(requireFail, otherRecognizer) === -1) {
                        requireFail.push(otherRecognizer);
                        otherRecognizer.requireFailure(this);
                    }
                    return this;
                },
                /**
                 * drop the requireFailure link. it does not remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRequireFailure: function dropRequireFailure(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    var index = inArray(this.requireFail, otherRecognizer);
                    if (index > -1) {
                        this.requireFail.splice(index, 1);
                    }
                    return this;
                },
                /**
                 * has require failures boolean
                 * @returns {boolean}
                 */
                hasRequireFailures: function hasRequireFailures() {
                    return this.requireFail.length > 0;
                },
                /**
                 * if the recognizer can recognize simultaneous with an other recognizer
                 * @param {Recognizer} otherRecognizer
                 * @returns {Boolean}
                 */
                canRecognizeWith: function canRecognizeWith(otherRecognizer) {
                    return !!this.simultaneous[otherRecognizer.id];
                },
                /**
                 * You should use `tryEmit` instead of `emit` directly to check
                 * that all the needed recognizers has failed before emitting.
                 * @param {Object} input
                 */
                emit: function emit(input) {
                    var self = this;
                    var state = this.state;
                    function emit(withState) {
                        self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
                    }
                    // 'panstart' and 'panmove'
                    if (state < STATE_ENDED) {
                        emit(true);
                    }
                    emit(); // simple 'eventName' events
                    // panend and pancancel
                    if (state >= STATE_ENDED) {
                        emit(true);
                    }
                },
                /**
                 * Check that all the require failure recognizers has failed,
                 * if true, it emits a gesture event,
                 * otherwise, setup the state to FAILED.
                 * @param {Object} input
                 */
                tryEmit: function tryEmit(input) {
                    if (this.canEmit()) {
                        return this.emit(input);
                    }
                    // it's failing anyway
                    this.state = STATE_FAILED;
                },
                /**
                 * can we emit?
                 * @returns {boolean}
                 */
                canEmit: function canEmit() {
                    var i = 0;
                    while (i < this.requireFail.length) {
                        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                            return false;
                        }
                        i++;
                    }
                    return true;
                },
                /**
                 * update the recognizer
                 * @param {Object} inputData
                 */
                recognize: function recognize(inputData) {
                    // make a new copy of the inputData
                    // so we can change the inputData without messing up the other recognizers
                    var inputDataClone = extend({}, inputData);
                    // is is enabled and allow recognizing?
                    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                        this.reset();
                        this.state = STATE_FAILED;
                        return;
                    }
                    // reset when we've reached the end
                    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                        this.state = STATE_POSSIBLE;
                    }
                    this.state = this.process(inputDataClone);
                    // the recognizer has recognized a gesture
                    // so trigger an event
                    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                        this.tryEmit(inputDataClone);
                    }
                },
                /**
                 * return the state of the recognizer
                 * the actual recognizing happens in this method
                 * @virtual
                 * @param {Object} inputData
                 * @returns {Const} STATE
                 */
                process: function process(inputData) {},
                /**
                 * return the preferred touch-action
                 * @virtual
                 * @returns {Array}
                 */
                getTouchAction: function getTouchAction() {},
                /**
                 * called when the gesture isn't allowed to recognize
                 * like when another is being recognized or it is disabled
                 * @virtual
                 */
                reset: function reset() {}
            };inherit(AttrRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof AttrRecognizer
                 */
                defaults: {
                    /**
                     * @type {Number}
                     * @default 1
                     */
                    pointers: 1
                },
                /**
                 * Used to check if it the recognizer receives valid input, like input.distance > 10.
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {Boolean} recognized
                 */
                attrTest: function attrTest(input) {
                    var optionPointers = this.options.pointers;
                    return optionPointers === 0 || input.pointers.length === optionPointers;
                },
                /**
                 * Process the input and return the state for the recognizer
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {*} State
                 */
                process: function process(input) {
                    var state = this.state;
                    var eventType = input.eventType;
                    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                    var isValid = this.attrTest(input);
                    // on cancel input and we've recognized before, return STATE_CANCELLED
                    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                        return state | STATE_CANCELLED;
                    } else if (isRecognized || isValid) {
                        if (eventType & INPUT_END) {
                            return state | STATE_ENDED;
                        } else if (!(state & STATE_BEGAN)) {
                            return STATE_BEGAN;
                        }
                        return state | STATE_CHANGED;
                    }
                    return STATE_FAILED;
                }
            });inherit(PanRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PanRecognizer
                 */
                defaults: {
                    event: 'pan',
                    threshold: 10,
                    pointers: 1,
                    direction: DIRECTION_ALL
                },
                getTouchAction: function getTouchAction() {
                    var direction = this.options.direction;
                    var actions = [];
                    if (direction & DIRECTION_HORIZONTAL) {
                        actions.push(TOUCH_ACTION_PAN_Y);
                    }
                    if (direction & DIRECTION_VERTICAL) {
                        actions.push(TOUCH_ACTION_PAN_X);
                    }
                    return actions;
                },
                directionTest: function directionTest(input) {
                    var options = this.options;
                    var hasMoved = true;
                    var distance = input.distance;
                    var direction = input.direction;
                    var x = input.deltaX;
                    var y = input.deltaY;
                    // lock to axis?
                    if (!(direction & options.direction)) {
                        if (options.direction & DIRECTION_HORIZONTAL) {
                            direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                            hasMoved = x != this.pX;
                            distance = Math.abs(input.deltaX);
                        } else {
                            direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                            hasMoved = y != this.pY;
                            distance = Math.abs(input.deltaY);
                        }
                    }
                    input.direction = direction;
                    return hasMoved && distance > options.threshold && direction & options.direction;
                },
                attrTest: function attrTest(input) {
                    return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
                },
                emit: function emit(input) {
                    this.pX = input.deltaX;
                    this.pY = input.deltaY;
                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }
                    this._super.emit.call(this, input);
                }
            });inherit(PinchRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'pinch',
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_NONE];
                },
                attrTest: function attrTest(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
                },
                emit: function emit(input) {
                    this._super.emit.call(this, input);
                    if (input.scale !== 1) {
                        var inOut = input.scale < 1 ? 'in' : 'out';
                        this.manager.emit(this.options.event + inOut, input);
                    }
                }
            });inherit(PressRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PressRecognizer
                 */
                defaults: {
                    event: 'press',
                    pointers: 1,
                    time: 500,
                    threshold: 5 // a minimal movement is ok, but keep it low
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_AUTO];
                },
                process: function process(input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTime = input.deltaTime > options.time;
                    this._input = input;
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                        this.reset();
                    } else if (input.eventType & INPUT_START) {
                        this.reset();
                        this._timer = setTimeoutContext(function () {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.time, this);
                    } else if (input.eventType & INPUT_END) {
                        return STATE_RECOGNIZED;
                    }
                    return STATE_FAILED;
                },
                reset: function reset() {
                    clearTimeout(this._timer);
                },
                emit: function emit(input) {
                    if (this.state !== STATE_RECOGNIZED) {
                        return;
                    }
                    if (input && input.eventType & INPUT_END) {
                        this.manager.emit(this.options.event + 'up', input);
                    } else {
                        this._input.timeStamp = now();
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });inherit(RotateRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof RotateRecognizer
                 */
                defaults: {
                    event: 'rotate',
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_NONE];
                },
                attrTest: function attrTest(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
                }
            });inherit(SwipeRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof SwipeRecognizer
                 */
                defaults: {
                    event: 'swipe',
                    threshold: 10,
                    velocity: 0.65,
                    direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                    pointers: 1
                },
                getTouchAction: function getTouchAction() {
                    return PanRecognizer.prototype.getTouchAction.call(this);
                },
                attrTest: function attrTest(input) {
                    var direction = this.options.direction;
                    var velocity;
                    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                        velocity = input.velocity;
                    } else if (direction & DIRECTION_HORIZONTAL) {
                        velocity = input.velocityX;
                    } else if (direction & DIRECTION_VERTICAL) {
                        velocity = input.velocityY;
                    }
                    return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
                },
                emit: function emit(input) {
                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }
                    this.manager.emit(this.options.event, input);
                }
            });inherit(TapRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'tap',
                    pointers: 1,
                    taps: 1,
                    interval: 300,
                    time: 250,
                    threshold: 2,
                    posThreshold: 10 // a multi-tap can be a bit off the initial position
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_MANIPULATION];
                },
                process: function process(input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTouchTime = input.deltaTime < options.time;
                    this.reset();
                    if (input.eventType & INPUT_START && this.count === 0) {
                        return this.failTimeout();
                    }
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (validMovement && validTouchTime && validPointers) {
                        if (input.eventType != INPUT_END) {
                            return this.failTimeout();
                        }
                        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                        this.pTime = input.timeStamp;
                        this.pCenter = input.center;
                        if (!validMultiTap || !validInterval) {
                            this.count = 1;
                        } else {
                            this.count += 1;
                        }
                        this._input = input;
                        // if tap count matches we have recognized it,
                        // else it has began recognizing...
                        var tapCount = this.count % options.taps;
                        if (tapCount === 0) {
                            // no failing requirements, immediately trigger the tap event
                            // or wait as long as the multitap interval to trigger
                            if (!this.hasRequireFailures()) {
                                return STATE_RECOGNIZED;
                            } else {
                                this._timer = setTimeoutContext(function () {
                                    this.state = STATE_RECOGNIZED;
                                    this.tryEmit();
                                }, options.interval, this);
                                return STATE_BEGAN;
                            }
                        }
                    }
                    return STATE_FAILED;
                },
                failTimeout: function failTimeout() {
                    this._timer = setTimeoutContext(function () {
                        this.state = STATE_FAILED;
                    }, this.options.interval, this);
                    return STATE_FAILED;
                },
                reset: function reset() {
                    clearTimeout(this._timer);
                },
                emit: function emit() {
                    if (this.state == STATE_RECOGNIZED) {
                        this._input.tapCount = this.count;
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });Hammer.VERSION = '2.0.4';
            /**
             * default settings
             * @namespace
             */
            Hammer.defaults = {
                /**
                 * set if DOM events are being triggered.
                 * But this is slower and unused by simple implementations, so disabled by default.
                 * @type {Boolean}
                 * @default false
                 */
                domEvents: false,
                /**
                 * The value for the touchAction property/fallback.
                 * When set to `compute` it will magically set the correct value based on the added recognizers.
                 * @type {String}
                 * @default compute
                 */
                touchAction: TOUCH_ACTION_COMPUTE,
                /**
                 * @type {Boolean}
                 * @default true
                 */
                enable: true,
                /**
                 * EXPERIMENTAL FEATURE -- can be removed/changed
                 * Change the parent input target element.
                 * If Null, then it is being set the to main element.
                 * @type {Null|EventTarget}
                 * @default null
                 */
                inputTarget: null,
                /**
                 * force an input class
                 * @type {Null|Function}
                 * @default null
                 */
                inputClass: null,
                /**
                 * Default recognizer setup when calling `Hammer()`
                 * When creating a new Manager these will be skipped.
                 * @type {Array}
                 */
                preset: [
                // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
                [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],
                /**
                 * Some CSS properties can be used to improve the working of Hammer.
                 * Add them to this method and they will be set when creating a new Manager.
                 * @namespace
                 */
                cssProps: {
                    /**
                     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userSelect: 'none',
                    /**
                     * Disable the Windows Phone grippers when pressing an element.
                     * @type {String}
                     * @default 'none'
                     */
                    touchSelect: 'none',
                    /**
                     * Disables the default callout shown when you touch and hold a touch target.
                     * On iOS, when you touch and hold a touch target such as a link, Safari displays
                     * a callout containing information about the link. This property allows you to disable that callout.
                     * @type {String}
                     * @default 'none'
                     */
                    touchCallout: 'none',
                    /**
                     * Specifies whether zooming is enabled. Used by IE10>
                     * @type {String}
                     * @default 'none'
                     */
                    contentZooming: 'none',
                    /**
                     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userDrag: 'none',
                    /**
                     * Overrides the highlight color shown when the user taps a link or a JavaScript
                     * clickable element in iOS. This property obeys the alpha value, if specified.
                     * @type {String}
                     * @default 'rgba(0,0,0,0)'
                     */
                    tapHighlightColor: 'rgba(0,0,0,0)'
                }
            };
            STOP = 1;
            FORCED_STOP = 2;
            Manager.prototype = {
                /**
                 * set options
                 * @param {Object} options
                 * @returns {Manager}
                 */
                set: function set(options) {
                    extend(this.options, options);
                    // Options that need a little more setup
                    if (options.touchAction) {
                        this.touchAction.update();
                    }
                    if (options.inputTarget) {
                        // Clean up existing event listeners and reinitialize
                        this.input.destroy();
                        this.input.target = options.inputTarget;
                        this.input.init();
                    }
                    return this;
                },
                /**
                 * stop recognizing for this session.
                 * This session will be discarded, when a new [input]start event is fired.
                 * When forced, the recognizer cycle is stopped immediately.
                 * @param {Boolean} [force]
                 */
                stop: function stop(force) {
                    this.session.stopped = force ? FORCED_STOP : STOP;
                },
                /**
                 * run the recognizers!
                 * called by the inputHandler function on every movement of the pointers (touches)
                 * it walks through all the recognizers and tries to detect the gesture that is being made
                 * @param {Object} inputData
                 */
                recognize: function recognize(inputData) {
                    var session = this.session;
                    if (session.stopped) {
                        return;
                    }
                    // run the touch-action polyfill
                    this.touchAction.preventDefaults(inputData);
                    var recognizer;
                    var recognizers = this.recognizers;
                    // this holds the recognizer that is being recognized.
                    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
                    // if no recognizer is detecting a thing, it is set to `null`
                    var curRecognizer = session.curRecognizer;
                    // reset when the last recognizer is recognized
                    // or when we're in a new session
                    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                        curRecognizer = session.curRecognizer = null;
                    }
                    var i = 0;
                    while (i < recognizers.length) {
                        recognizer = recognizers[i];
                        // find out if we are allowed try to recognize the input for this one.
                        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                        //      that is being recognized.
                        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                        //      this can be setup with the `recognizeWith()` method on the recognizer.
                        if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                            recognizer.recognize(inputData);
                        } else {
                            recognizer.reset();
                        }
                        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                        // current active recognizer. but only if we don't already have an active recognizer
                        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                            curRecognizer = session.curRecognizer = recognizer;
                        }
                        i++;
                    }
                },
                /**
                 * get a recognizer by its event name.
                 * @param {Recognizer|String} recognizer
                 * @returns {Recognizer|Null}
                 */
                get: function get(recognizer) {
                    if (recognizer instanceof Recognizer) {
                        return recognizer;
                    }
                    var recognizers = this.recognizers;
                    for (var i = 0; i < recognizers.length; i++) {
                        if (recognizers[i].options.event == recognizer) {
                            return recognizers[i];
                        }
                    }
                    return null;
                },
                /**
                 * add a recognizer to the manager
                 * existing recognizers with the same event name will be removed
                 * @param {Recognizer} recognizer
                 * @returns {Recognizer|Manager}
                 */
                add: function add(recognizer) {
                    if (invokeArrayArg(recognizer, 'add', this)) {
                        return this;
                    }
                    // remove existing
                    var existing = this.get(recognizer.options.event);
                    if (existing) {
                        this.remove(existing);
                    }
                    this.recognizers.push(recognizer);
                    recognizer.manager = this;
                    this.touchAction.update();
                    return recognizer;
                },
                /**
                 * remove a recognizer by name or instance
                 * @param {Recognizer|String} recognizer
                 * @returns {Manager}
                 */
                remove: function remove(recognizer) {
                    if (invokeArrayArg(recognizer, 'remove', this)) {
                        return this;
                    }
                    var recognizers = this.recognizers;
                    recognizer = this.get(recognizer);
                    recognizers.splice(inArray(recognizers, recognizer), 1);
                    this.touchAction.update();
                    return this;
                },
                /**
                 * bind event
                 * @param {String} events
                 * @param {Function} handler
                 * @returns {EventEmitter} this
                 */
                on: function on(events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        handlers[event] = handlers[event] || [];
                        handlers[event].push(handler);
                    });
                    return this;
                },
                /**
                 * unbind event, leave emit blank to remove all handlers
                 * @param {String} events
                 * @param {Function} [handler]
                 * @returns {EventEmitter} this
                 */
                off: function off(events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        if (!handler) {
                            delete handlers[event];
                        } else {
                            handlers[event].splice(inArray(handlers[event], handler), 1);
                        }
                    });
                    return this;
                },
                /**
                 * emit event to the listeners
                 * @param {String} event
                 * @param {Object} data
                 */
                emit: function emit(event, data) {
                    // we also want to trigger dom events
                    if (this.options.domEvents) {
                        triggerDomEvent(event, data);
                    }
                    // no handlers, so skip it all
                    var handlers = this.handlers[event] && this.handlers[event].slice();
                    if (!handlers || !handlers.length) {
                        return;
                    }
                    data.type = event;
                    data.preventDefault = function () {
                        data.srcEvent.preventDefault();
                    };
                    var i = 0;
                    while (i < handlers.length) {
                        handlers[i](data);
                        i++;
                    }
                },
                /**
                 * destroy the manager and unbinds all events
                 * it doesn't unbind dom events, that is the user own responsibility
                 */
                destroy: function destroy() {
                    this.element && toggleCssProps(this, false);
                    this.handlers = {};
                    this.session = {};
                    this.input.destroy();
                    this.element = null;
                }
            };extend(Hammer, {
                INPUT_START: INPUT_START,
                INPUT_MOVE: INPUT_MOVE,
                INPUT_END: INPUT_END,
                INPUT_CANCEL: INPUT_CANCEL,
                STATE_POSSIBLE: STATE_POSSIBLE,
                STATE_BEGAN: STATE_BEGAN,
                STATE_CHANGED: STATE_CHANGED,
                STATE_ENDED: STATE_ENDED,
                STATE_RECOGNIZED: STATE_RECOGNIZED,
                STATE_CANCELLED: STATE_CANCELLED,
                STATE_FAILED: STATE_FAILED,
                DIRECTION_NONE: DIRECTION_NONE,
                DIRECTION_LEFT: DIRECTION_LEFT,
                DIRECTION_RIGHT: DIRECTION_RIGHT,
                DIRECTION_UP: DIRECTION_UP,
                DIRECTION_DOWN: DIRECTION_DOWN,
                DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
                DIRECTION_VERTICAL: DIRECTION_VERTICAL,
                DIRECTION_ALL: DIRECTION_ALL,
                Manager: Manager,
                Input: Input,
                TouchAction: TouchAction,
                TouchInput: TouchInput,
                MouseInput: MouseInput,
                PointerEventInput: PointerEventInput,
                TouchMouseInput: TouchMouseInput,
                SingleTouchInput: SingleTouchInput,
                Recognizer: Recognizer,
                AttrRecognizer: AttrRecognizer,
                Tap: TapRecognizer,
                Pan: PanRecognizer,
                Swipe: SwipeRecognizer,
                Pinch: PinchRecognizer,
                Rotate: RotateRecognizer,
                Press: PressRecognizer,
                on: addEventListeners,
                off: removeEventListeners,
                each: each,
                merge: merge,
                extend: extend,
                inherit: inherit,
                bindFn: bindFn,
                prefixed: prefixed
            });
            // attach to window for angular2 gesture listeners
            window.Hammer = Hammer;

            _export('Hammer', Hammer);
        }
    };
});
System.register('ionic/gestures/slide-edge-gesture', ['./slide-gesture', '../util/util', '../util/dom'], function (_export) {
    'use strict';

    var SlideGesture, defaults, windowDimensions, SlideEdgeGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_slideGesture) {
            SlideGesture = _slideGesture.SlideGesture;
        }, function (_utilUtil) {
            defaults = _utilUtil.defaults;
        }, function (_utilDom) {
            windowDimensions = _utilDom.windowDimensions;
        }],
        execute: function () {
            SlideEdgeGesture = (function (_SlideGesture) {
                _inherits(SlideEdgeGesture, _SlideGesture);

                function SlideEdgeGesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, SlideEdgeGesture);

                    defaults(opts, {
                        edge: 'left',
                        threshold: 50
                    });
                    _get(Object.getPrototypeOf(SlideEdgeGesture.prototype), 'constructor', this).call(this, element, opts);
                    // Can check corners through use of eg 'left top'
                    this.edges = opts.edge.split(' ');
                    this.threshold = opts.threshold;
                }

                _createClass(SlideEdgeGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        var _this = this;

                        this._d = this.getContainerDimensions();
                        return this.edges.every(function (edge) {
                            return _this._checkEdge(edge, ev.center);
                        });
                    }
                }, {
                    key: 'getContainerDimensions',
                    value: function getContainerDimensions() {
                        return {
                            left: 0,
                            top: 0,
                            width: windowDimensions().width,
                            height: windowDimensions().height
                        };
                    }
                }, {
                    key: '_checkEdge',
                    value: function _checkEdge(edge, pos) {
                        switch (edge) {
                            case 'left':
                                return pos.x <= this._d.left + this.threshold;
                            case 'right':
                                return pos.x >= this._d.width - this.threshold;
                            case 'top':
                                return pos.y <= this._d.top + this.threshold;
                            case 'bottom':
                                return pos.y >= this._d.height - this.threshold;
                        }
                    }
                }]);

                return SlideEdgeGesture;
            })(SlideGesture);

            _export('SlideEdgeGesture', SlideEdgeGesture);
        }
    };
});
System.register('ionic/gestures/slide-gesture', ['./drag-gesture', '../util'], function (_export) {
    'use strict';

    var DragGesture, util, SlideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_dragGesture) {
            DragGesture = _dragGesture.DragGesture;
        }, function (_util) {
            util = _util;
        }],
        execute: function () {
            SlideGesture = (function (_DragGesture) {
                _inherits(SlideGesture, _DragGesture);

                function SlideGesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, SlideGesture);

                    _get(Object.getPrototypeOf(SlideGesture.prototype), 'constructor', this).call(this, element, opts);
                    this.element = element;
                }

                /*
                 * Get the min and max for the slide. pageX/pageY.
                 * Only called on dragstart.
                 */

                _createClass(SlideGesture, [{
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries(slide, ev) {
                        return {
                            min: 0,
                            max: this.element.offsetWidth
                        };
                    }

                    /*
                     * Get the element's pos when the drag starts.
                     * For example, an open side menu starts at 100% and a closed
                     * sidemenu starts at 0%.
                     */
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return 0;
                    }
                }, {
                    key: 'canStart',
                    value: function canStart() {
                        return true;
                    }
                }, {
                    key: 'onDragStart',
                    value: function onDragStart(ev) {
                        var _this = this;

                        if (!this.canStart(ev)) return false;
                        this.slide = {};
                        var promise = this.onSlideBeforeStart(this.slide, ev) || Promise.resolve();
                        promise.then(function () {
                            var _getSlideBoundaries = _this.getSlideBoundaries(_this.slide, ev);

                            var min = _getSlideBoundaries.min;
                            var max = _getSlideBoundaries.max;

                            _this.slide.min = min;
                            _this.slide.max = max;
                            _this.slide.elementStartPos = _this.getElementStartPos(_this.slide, ev);
                            _this.slide.pointerStartPos = ev.center[_this.direction];
                            _this.slide.started = true;
                            _this.onSlideStart(_this.slide, ev);
                        })['catch'](function () {
                            _this.slide = null;
                        });
                    }
                }, {
                    key: 'onDrag',
                    value: function onDrag(ev) {
                        if (!this.slide || !this.slide.started) return;
                        this.slide.pos = ev.center[this.direction];
                        this.slide.distance = util.clamp(this.slide.min, this.slide.pos - this.slide.pointerStartPos + this.slide.elementStartPos, this.slide.max);
                        this.slide.delta = this.slide.pos - this.slide.pointerStartPos;
                        this.onSlide(this.slide, ev);
                    }
                }, {
                    key: 'onDragEnd',
                    value: function onDragEnd(ev) {
                        if (!this.slide || !this.slide.started) return;
                        this.onSlideEnd(this.slide, ev);
                        this.slide = null;
                    }
                }, {
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart() {}
                }, {
                    key: 'onSlideStart',
                    value: function onSlideStart() {}
                }, {
                    key: 'onSlide',
                    value: function onSlide() {}
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd() {}
                }]);

                return SlideGesture;
            })(DragGesture);

            _export('SlideGesture', SlideGesture);
        }
    };
});
System.register('ionic/util/click-block', [], function (_export) {
    'use strict';

    var CSS_CLICK_BLOCK, DEFAULT_EXPIRE, cbEle, fallbackTimerId, isShowing, ClickBlock;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _show(expire) {
        clearTimeout(fallbackTimerId);
        fallbackTimerId = setTimeout(hide, expire || DEFAULT_EXPIRE);
        if (!isShowing) {
            cbEle.classList.add(CSS_CLICK_BLOCK);
            isShowing = true;
        }
    }
    function hide() {
        clearTimeout(fallbackTimerId);
        if (isShowing) {
            cbEle.classList.remove(CSS_CLICK_BLOCK);
            isShowing = false;
        }
    }
    return {
        setters: [],
        execute: function () {
            CSS_CLICK_BLOCK = 'click-block-active';
            DEFAULT_EXPIRE = 330;
            cbEle = undefined;
            fallbackTimerId = undefined;
            isShowing = false;

            /**
             * @private
             */

            ClickBlock = (function () {
                function ClickBlock() {
                    _classCallCheck(this, ClickBlock);
                }

                _createClass(ClickBlock, [{
                    key: 'enable',
                    value: function enable() {
                        cbEle = document.createElement('click-block');
                        document.body.appendChild(cbEle);
                        cbEle.addEventListener('touchmove', function (ev) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        });
                        this._enabled = true;
                    }
                }, {
                    key: 'show',
                    value: function show(shouldShow, expire) {
                        if (this._enabled) {
                            if (shouldShow) {
                                _show(expire);
                            } else {
                                hide();
                            }
                        }
                    }
                }]);

                return ClickBlock;
            })();

            _export('ClickBlock', ClickBlock);
        }
    };
});
System.register('ionic/util/dom', [], function (_export) {
    // requestAnimationFrame is polyfilled for old Android
    // within the web-animations polyfill
    'use strict';

    var raf, CSS, matchesFn, dimensionCache, dimensionIds;

    _export('rafFrames', rafFrames);

    _export('transitionEnd', transitionEnd);

    _export('animationStart', animationStart);

    _export('animationEnd', animationEnd);

    _export('ready', ready);

    _export('windowLoad', windowLoad);

    _export('pointerCoord', pointerCoord);

    _export('hasPointerMoved', hasPointerMoved);

    _export('isActive', isActive);

    _export('hasFocus', hasFocus);

    _export('isTextInput', isTextInput);

    _export('hasFocusedTextInput', hasFocusedTextInput);

    _export('closest', closest);

    /**
     * Get the element offsetWidth and offsetHeight. Values are cached
     * to reduce DOM reads. Cache is cleared on a window resize.
     * @param {TODO} ele  TODO
     */

    _export('removeElement', removeElement);

    _export('getDimensions', getDimensions);

    _export('windowDimensions', windowDimensions);

    _export('flushDimensionCache', flushDimensionCache);

    _export('parentOffsetEl', parentOffsetEl);

    /**
    * Get the current coordinates of the element, relative to the document.
    * Read-only equivalent of [jQuery's offset function](http://api.jquery.com/offset/).
    * @param {element} element The element to get the offset of.
    * @returns {object} Returns an object containing the properties top, left, width and height.
    */

    _export('position', position);

    _export('offset', offset);

    function rafFrames(framesToWait, callback) {
        framesToWait = Math.ceil(framesToWait);
        if (framesToWait < 2) {
            raf(callback);
        } else {
            setTimeout(function () {
                raf(callback);
            }, (framesToWait - 1) * 17);
        }
    }

    function transitionEnd(el) {
        return cssPromise(el, CSS.transitionEnd);
    }

    function animationStart(el, animationName) {
        return cssPromise(el, CSS.animationStart, animationName);
    }

    function animationEnd(el, animationName) {
        return cssPromise(el, CSS.animationEnd, animationName);
    }

    function cssPromise(el, eventNames, animationName) {
        return new Promise(function (resolve) {
            eventNames.split(' ').forEach(function (eventName) {
                el.addEventListener(eventName, onEvent);
            });
            function onEvent(ev) {
                if (ev.animationName && animationName) {
                    // do not resolve if a bubbled up ev.animationName
                    // is not the same as the passed in animationName arg
                    if (ev.animationName !== animationName) {
                        return;
                    }
                } else if (ev.target !== el) {
                    // do not resolve if the event's target element is not
                    // the same as the element the listener was added to
                    return;
                }
                ev.stopPropagation();
                eventNames.split(' ').forEach(function (eventName) {
                    el.removeEventListener(eventName, onEvent);
                });
                resolve(ev);
            }
        });
    }

    function ready(callback) {
        var promise = null;
        if (!callback) {
            // a callback wasn't provided, so let's return a promise instead
            promise = new Promise(function (resolve) {
                callback = resolve;
            });
        }
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            callback();
        } else {
            (function () {
                var completed = function completed() {
                    document.removeEventListener('DOMContentLoaded', completed, false);
                    window.removeEventListener('load', completed, false);
                    callback();
                };

                document.addEventListener('DOMContentLoaded', completed, false);
                window.addEventListener('load', completed, false);
            })();
        }
        return promise;
    }

    function windowLoad(callback) {
        var promise = null;
        if (!callback) {
            // a callback wasn't provided, so let's return a promise instead
            promise = new Promise(function (resolve) {
                callback = resolve;
            });
        }
        if (document.readyState === 'complete') {
            callback();
        } else {
            (function () {
                var completed = function completed() {
                    window.removeEventListener('load', completed, false);
                    callback();
                };

                window.addEventListener('load', completed, false);
            })();
        }
        return promise;
    }

    function pointerCoord(ev) {
        // get coordinates for either a mouse click
        // or a touch depending on the given event
        var c = { x: 0, y: 0 };
        if (ev) {
            var touches = ev.touches && ev.touches.length ? ev.touches : [ev];
            var e = ev.changedTouches && ev.changedTouches[0] || touches[0];
            if (e) {
                c.x = e.clientX || e.pageX || 0;
                c.y = e.clientY || e.pageY || 0;
            }
        }
        return c;
    }

    function hasPointerMoved(threshold, startCoord, endCoord) {
        return startCoord && endCoord && (Math.abs(startCoord.x - endCoord.x) > threshold || Math.abs(startCoord.y - endCoord.y) > threshold);
    }

    function isActive(ele) {
        return !!(ele && document.activeElement === ele);
    }

    function hasFocus(ele) {
        return isActive(ele) && ele.parentElement.querySelector(':focus') === ele;
    }

    function isTextInput(ele) {
        return !!ele && (ele.tagName == 'TEXTAREA' || ele.contentEditable === 'true' || ele.tagName == 'INPUT' && !/^(radio|checkbox|range|file|submit|reset|color|image|button)$/i.test(ele.type));
    }

    function hasFocusedTextInput() {
        var ele = document.activeElement;
        if (isTextInput(ele)) {
            return ele.parentElement.querySelector(':focus') === ele;
        }
        return false;
    }

    function closest(ele, selector, checkSelf) {
        if (ele && matchesFn) {
            // traverse parents
            ele = checkSelf ? ele : ele.parentElement;
            while (ele !== null) {
                if (ele[matchesFn](selector)) {
                    return ele;
                }
                ele = ele.parentElement;
            }
        }
        return null;
    }

    function removeElement(ele) {
        ele && ele.parentNode && ele.parentNode.removeChild(ele);
    }

    function getDimensions(ion, ele) {
        if (!ion._dimId) {
            ion._dimId = ++dimensionIds;
            if (ion._dimId % 1000 === 0) {
                // periodically flush dimensions
                flushDimensionCache();
            }
        }
        var dimensions = dimensionCache[ion._dimId];
        if (!dimensions) {
            var _ele = ion.getNativeElement();
            // make sure we got good values before caching
            if (_ele.offsetWidth && _ele.offsetHeight) {
                dimensions = dimensionCache[ion._dimId] = {
                    width: _ele.offsetWidth,
                    height: _ele.offsetHeight,
                    left: _ele.offsetLeft,
                    top: _ele.offsetTop
                };
            } else {
                // do not cache bad values
                return { width: 0, height: 0, left: 0, top: 0 };
            }
        }
        return dimensions;
    }

    function windowDimensions() {
        if (!dimensionCache.win) {
            // make sure we got good values before caching
            if (window.innerWidth && window.innerHeight) {
                dimensionCache.win = {
                    width: window.innerWidth,
                    height: window.innerHeight
                };
            } else {
                // do not cache bad values
                return { width: 0, height: 0 };
            }
        }
        return dimensionCache.win;
    }

    function flushDimensionCache() {
        dimensionCache = {};
    }

    function isStaticPositioned(element) {
        return (element.style.position || 'static') === 'static';
    }
    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */

    function parentOffsetEl(element) {
        var offsetParent = element.offsetParent || document;
        while (offsetParent && offsetParent !== document && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || document;
    }

    /**
     * Get the current coordinates of the element, relative to the offset parent.
     * Read-only equivalent of [jQuery's position function](http://api.jquery.com/position/).
     * @param {element} element The element to get the position of.
     * @returns {object} Returns an object containing the properties top, left, width and height.
     */

    function position(element) {
        var elBCR = offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element);
        if (offsetParentEl != document) {
            offsetParentBCR = offset(offsetParentEl);
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
            offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }
        var boundingClientRect = element.getBoundingClientRect();
        return {
            width: boundingClientRect.width || element.offsetWidth,
            height: boundingClientRect.height || element.offsetHeight,
            top: elBCR.top - offsetParentBCR.top,
            left: elBCR.left - offsetParentBCR.left
        };
    }

    function offset(element) {
        var boundingClientRect = element.getBoundingClientRect();
        return {
            width: boundingClientRect.width || element.offsetWidth,
            height: boundingClientRect.height || element.offsetHeight,
            top: boundingClientRect.top + (window.pageYOffset || document.documentElement.scrollTop),
            left: boundingClientRect.left + (window.pageXOffset || document.documentElement.scrollLeft)
        };
    }

    return {
        setters: [],
        execute: function () {
            raf = window.requestAnimationFrame;

            _export('raf', raf);

            CSS = {};

            _export('CSS', CSS);

            (function () {
                // transform
                var i,
                    keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform', '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform', 'msTransform'];
                for (i = 0; i < keys.length; i++) {
                    if (document.documentElement.style[keys[i]] !== undefined) {
                        CSS.transform = keys[i];
                        break;
                    }
                }
                // transition
                keys = ['webkitTransition', 'mozTransition', 'msTransition', 'transition'];
                for (i = 0; i < keys.length; i++) {
                    if (document.documentElement.style[keys[i]] !== undefined) {
                        CSS.transition = keys[i];
                        break;
                    }
                }
                // The only prefix we care about is webkit for transitions.
                var isWebkit = CSS.transition.indexOf('webkit') > -1;
                CSS.prefix = isWebkit ? '-webkit-' : '';
                // transition duration
                CSS.transitionDuration = (isWebkit ? '-webkit-' : '') + 'transition-duration';
                // To be sure transitionend works everywhere, include *both* the webkit and non-webkit events
                CSS.transitionEnd = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
            })();
            if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
                CSS.animation = 'WebkitAnimation';
                CSS.animationStart = 'webkitAnimationStart animationstart';
                CSS.animationEnd = 'webkitAnimationEnd animationend';
            } else {
                CSS.animation = 'animation';
                CSS.animationStart = 'animationstart';
                CSS.animationEnd = 'animationend';
            }
            matchesFn = undefined;

            ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector'].some(function (fn) {
                if (typeof document.documentElement[fn] == 'function') {
                    matchesFn = fn;
                }
            });
            dimensionCache = {};
            dimensionIds = 0;

            ;
        }
    };
});
System.register("ionic/util/events", ["angular2/core"], function (_export) {
    /**
     * Events is a pub/sub style event system for sending and responding to application-level
     * events across your app.
     * @usage
     * ```ts
     * // first page (publish an event when a user is created)
     * function createUser(user) {
     *   console.log('User created!')
     *   events.publish('user:created', user);
     * }
     *
     * // second page (listen for the user created event)
     * events.subscribe('user:created', (user) => {
     *   console.log('Welcome', user);
     * });
     *
     * ```
     */
    "use strict";

    var Injectable, __decorate, __metadata, Events;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Injectable = _angular2Core.Injectable;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Events = (function () {
                function Events() {
                    _classCallCheck(this, Events);

                    this.channels = [];
                }

                /**
                 * Subscribe to an event topic. Events that get posted to that topic
                 * will trigger the provided handler.
                 *
                 * @param topic the topic to subscribe to
                 * @param handler the event handler
                 */

                _createClass(Events, [{
                    key: "subscribe",
                    value: function subscribe(topic) {
                        var _this = this;

                        if (!this.channels[topic]) {
                            this.channels[topic] = [];
                        }

                        for (var _len = arguments.length, handlers = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                            handlers[_key - 1] = arguments[_key];
                        }

                        handlers.forEach(function (handler) {
                            _this.channels[topic].push(handler);
                        });
                    }

                    /**
                     * Unsubscribe from the given topic. Your handler will
                     * no longer receive events published to this topic.
                     *
                     * @param topic the topic to unsubscribe from
                     * @param handler the event handler
                     *
                     * @return true if a handler was removed
                     */
                }, {
                    key: "unsubscribe",
                    value: function unsubscribe(topic, handler) {
                        var t = this.channels[topic];
                        if (!t) {
                            // Wasn't found, wasn't removed
                            return false;
                        }
                        if (!handler) {
                            // Remove all handlers for this topic
                            delete this.channels[topic];
                            return true;
                        }
                        // We need to find and remove a specific handler
                        var i = t.indexOf(handler);
                        if (i < 0) {
                            // Wasn't found, wasn't removed
                            return false;
                        }
                        t.splice(i, 1);
                        // If the channel is empty now, remove it from the channel map
                        if (!t.length) {
                            delete this.channels[topic];
                        }
                        return true;
                    }

                    /**
                     * Publish an event to the given topic.
                     *
                     * @param topic the topic to publish to
                     * @param eventData the data to send as the event
                     */
                }, {
                    key: "publish",
                    value: function publish(topic) {
                        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                            args[_key2 - 1] = arguments[_key2];
                        }

                        var t = this.channels[topic];
                        if (!t) {
                            return null;
                        }
                        var responses = [];
                        t.forEach(function (handler) {
                            responses.push(handler(args));
                        });
                        return responses;
                    }
                }]);

                return Events;
            })();

            _export("Events", Events);

            _export("Events", Events = __decorate([Injectable(), __metadata('design:paramtypes', [])], Events));
        }
    };
});
System.register('ionic/util/feature-detect', [], function (_export) {
    'use strict';

    var FeatureDetect, featureDetects;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            FeatureDetect = (function () {
                function FeatureDetect() {
                    _classCallCheck(this, FeatureDetect);
                }

                _createClass(FeatureDetect, [{
                    key: 'run',
                    value: function run(window, document) {
                        this._results = {};
                        for (var _name in featureDetects) {
                            this._results[_name] = featureDetects[_name](window, document, document.body);
                        }
                    }
                }, {
                    key: 'has',
                    value: function has(featureName) {
                        return !!this._results[featureName];
                    }
                }], [{
                    key: 'add',
                    value: function add(name, fn) {
                        featureDetects[name] = fn;
                    }
                }]);

                return FeatureDetect;
            })();

            _export('FeatureDetect', FeatureDetect);

            featureDetects = {};

            // FeatureDetect.add('sticky', function(window, document) {
            //   // css position sticky
            //   let ele = document.createElement('div');
            //   ele.style.cssText = 'position:-webkit-sticky;position:sticky';
            //   return ele.style.position.indexOf('sticky') > -1;
            // });
            FeatureDetect.add('hairlines', function (window, document, body) {
                /**
                * Hairline Shim
                * Add the "hairline" CSS class name to the body tag
                * if the browser supports subpixels.
                */
                var canDo = false;
                if (window.devicePixelRatio >= 2) {
                    var hairlineEle = document.createElement('div');
                    hairlineEle.style.border = '.5px solid transparent';
                    body.appendChild(hairlineEle);
                    if (hairlineEle.offsetHeight === 1) {
                        body.classList.add('hairlines');
                        canDo = true;
                    }
                    body.removeChild(hairlineEle);
                }
                return canDo;
            });
        }
    };
});
System.register("ionic/util/form", ["angular2/core"], function (_export) {
    /**
     * The Input component is used to focus text input elements.
     *
     * @usage
     * ```html
     * <ion-input>
     *   <ion-label>Name</ion-label>
     *   <input value="Name" type="text">
     * </ion-input>
     * ```
     */
    "use strict";

    var Injectable, __decorate, __metadata, Form;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Injectable = _angular2Core.Injectable;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Form = (function () {
                function Form() {
                    _classCallCheck(this, Form);

                    this._inputs = [];
                    this._ids = -1;
                    this._focused = null;
                    this.focusCtrl(document);
                }

                _createClass(Form, [{
                    key: "register",
                    value: function register(input) {
                        this._inputs.push(input);
                    }
                }, {
                    key: "deregister",
                    value: function deregister(input) {
                        var index = this._inputs.indexOf(input);
                        if (index > -1) {
                            this._inputs.splice(index, 1);
                        }
                        if (input === this._focused) {
                            this._focused = null;
                        }
                    }
                }, {
                    key: "focusCtrl",
                    value: function focusCtrl(document) {
                        // raw DOM fun
                        var focusCtrl = document.createElement('focus-ctrl');
                        focusCtrl.setAttribute('aria-hidden', true);
                        this._blur = document.createElement('button');
                        this._blur.tabIndex = -1;
                        focusCtrl.appendChild(this._blur);
                        document.body.appendChild(focusCtrl);
                    }
                }, {
                    key: "focusOut",
                    value: function focusOut() {
                        console.debug('focusOut');
                        document.activeElement && document.activeElement.blur();
                        this._blur.focus();
                    }
                }, {
                    key: "setAsFocused",
                    value: function setAsFocused(input) {
                        this._focused = input;
                    }

                    /**
                     * Focuses the next input element, if it exists.
                     */
                }, {
                    key: "focusNext",
                    value: function focusNext(currentInput) {
                        console.debug('focusNext');
                        var index = this._inputs.indexOf(currentInput);
                        if (index > -1 && index + 1 < this._inputs.length) {
                            var nextInput = this._inputs[index + 1];
                            if (nextInput !== this._focused) {
                                return nextInput.initFocus();
                            }
                        }
                        index = this._inputs.indexOf(this._focused);
                        if (index > 0) {
                            var previousInput = this._inputs[index - 1];
                            if (previousInput) {
                                previousInput.initFocus();
                            }
                        }
                    }
                }, {
                    key: "nextId",
                    value: function nextId() {
                        return ++this._ids;
                    }
                }]);

                return Form;
            })();

            _export("Form", Form);

            _export("Form", Form = __decorate([Injectable(), __metadata('design:paramtypes', [])], Form));
        }
    };
});
System.register("ionic/util/keyboard", ["angular2/core", "../config/config", "./form", "./dom"], function (_export) {
    /**
     * @name Keyboard
     * @description
     * The `Keyboard` class allows you to work with the keyboard events provide by the Ionic keyboard plugin.
     *
     * @usage
     * ```ts
     * export class MyClass{
     *  constructor(keyboard: Keyboard){
     *    this.keyboard = keyboard;
     *  }
     * }
     *
     * ```
     */
    "use strict";

    var Injectable, NgZone, Config, Form, hasFocusedTextInput, raf, rafFrames, __decorate, __metadata, Keyboard, KEYBOARD_CLOSE_POLLING, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Injectable = _angular2Core.Injectable;
            NgZone = _angular2Core.NgZone;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_form) {
            Form = _form.Form;
        }, function (_dom) {
            hasFocusedTextInput = _dom.hasFocusedTextInput;
            raf = _dom.raf;
            rafFrames = _dom.rafFrames;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Keyboard = (function () {
                function Keyboard(config, form, zone) {
                    var _this = this;

                    _classCallCheck(this, Keyboard);

                    this.form = form;
                    this.zone = zone;
                    zone.runOutsideAngular(function () {
                        _this.focusOutline(config.get('focusOutline'), document);
                    });
                }

                /**
                 * Chech to see if the keyboard is open or not.
                 *
                 * ```ts
                 * export class MyClass{
                 *  constructor(keyboard: Keyboard){
                 *    this.keyboard = keyboard;
                 *  }
                 *  keyboardCheck(){
                 *    setTimeout(()  => console.log('is the keyboard open ', this.keyboard.isOpen()));
                 *  }
                 * }
                 *
                 * ```
                 *
                 * @return {Bool} returns a true or flase value if the keyboard is open or not
                 */

                _createClass(Keyboard, [{
                    key: "isOpen",
                    value: function isOpen() {
                        return hasFocusedTextInput();
                    }

                    /**
                     * When the keyboard is closed, call any methods you want
                     *
                     * ```ts
                     * export class MyClass{
                     *  constructor(keyboard: Keyboard){
                     *    this.keyboard = keyboard;
                     *    this.keyboard.onClose(this.closeCallback);
                     *  }
                     *  closeCallback(){
                     *     // call what ever functionality you want on keyboard close
                     *     console.log('Closing time");
                     *  }
                     * }
                     *
                     * ```
                     * @param {Function} callback method you want to call when the keyboard has been closed
                     * @return {Function} returns a callback that gets fired when the keyboard is closed
                     */
                }, {
                    key: "onClose",
                    value: function onClose(callback) {
                        var pollingInternval = arguments.length <= 1 || arguments[1] === undefined ? KEYBOARD_CLOSE_POLLING : arguments[1];

                        console.debug('keyboard onClose');
                        var self = this;
                        var checks = 0;
                        var promise = null;
                        if (!callback) {
                            // a callback wasn't provided, so let's return a promise instead
                            promise = new Promise(function (resolve) {
                                callback = resolve;
                            });
                        }
                        self.zone.runOutsideAngular(function () {
                            function checkKeyboard() {
                                console.debug('keyboard isOpen', self.isOpen(), checks);
                                if (!self.isOpen() || checks > 100) {
                                    rafFrames(30, function () {
                                        self.zone.run(function () {
                                            console.debug('keyboard closed');
                                            callback();
                                        });
                                    });
                                } else {
                                    setTimeout(checkKeyboard, pollingInternval);
                                }
                                checks++;
                            }
                            setTimeout(checkKeyboard, pollingInternval);
                        });
                        return promise;
                    }

                    /**
                     * Progamatically close they keyboard
                     *
                     */
                }, {
                    key: "close",
                    value: function close() {
                        var _this2 = this;

                        console.debug('keyboard close()');
                        raf(function () {
                            if (hasFocusedTextInput()) {
                                // only focus out when a text input has focus
                                _this2.form.focusOut();
                            }
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "focusOutline",
                    value: function focusOutline(setting, document) {
                        /* Focus Outline
                         * --------------------------------------------------
                         * By default, when a keydown event happens from a tab key, then
                         * the 'focus-outline' css class is added to the body element
                         * so focusable elements have an outline. On a mousedown or
                         * touchstart event, then the 'focus-outline' css class is removed.
                         *
                         * Config default overrides:
                         * focusOutline: true     - Always add the focus-outline
                         * focusOutline: false    - Do not add the focus-outline
                         */
                        var self = this;
                        var isKeyInputEnabled = false;
                        function cssClass() {
                            raf(function () {
                                document.body.classList[isKeyInputEnabled ? 'add' : 'remove']('focus-outline');
                            });
                        }
                        if (setting === true) {
                            isKeyInputEnabled = true;
                            return cssClass();
                        } else if (setting === false) {
                            return;
                        }
                        // default is to add the focus-outline when the tab key is used
                        function keyDown(ev) {
                            if (!isKeyInputEnabled && ev.keyCode == 9) {
                                isKeyInputEnabled = true;
                                enableKeyInput();
                            }
                        }
                        function pointerDown() {
                            isKeyInputEnabled = false;
                            enableKeyInput();
                        }
                        function enableKeyInput() {
                            cssClass();
                            self.zone.runOutsideAngular(function () {
                                document.removeEventListener('mousedown', pointerDown);
                                document.removeEventListener('touchstart', pointerDown);
                                if (isKeyInputEnabled) {
                                    document.addEventListener('mousedown', pointerDown);
                                    document.addEventListener('touchstart', pointerDown);
                                }
                            });
                        }
                        document.addEventListener('keydown', keyDown);
                    }
                }]);

                return Keyboard;
            })();

            _export("Keyboard", Keyboard);

            _export("Keyboard", Keyboard = __decorate([Injectable(), __metadata('design:paramtypes', [typeof (_a = typeof Config !== 'undefined' && Config) === 'function' && _a || Object, typeof (_b = typeof Form !== 'undefined' && Form) === 'function' && _b || Object, typeof (_c = typeof NgZone !== 'undefined' && NgZone) === 'function' && _c || Object])], Keyboard));
            KEYBOARD_CLOSE_POLLING = 150;
        }
    };
});
System.register('ionic/util/util', [], function (_export) {
    // Simple noop function
    'use strict';

    var isBoolean, isString, isNumber, isFunction, isDefined, isUndefined, isBlank, isObject, isArray, isTrueProperty, uid, array;

    _export('noop', noop);

    /**
     * Extend the destination with an arbitrary number of other objects.
     * @param dst the destination
     * @param ... the param objects
     */

    _export('clamp', clamp);

    /**
     * Do a deep extend (merge).
     * @param dst the destination
     * @param ... the param objects
     */

    _export('extend', extend);

    _export('merge', merge);

    /**
     * Apply default arguments if they don't exist in
     * the first object.
     * @param the destination to apply defaults to.
     */

    _export('debounce', debounce);

    _export('defaults', defaults);

    _export('pascalCaseToDashCase', pascalCaseToDashCase);

    _export('nextUid', nextUid);

    /**
     * Throttle the given fun, only allowing it to be
     * called at most every `wait` ms.
     */

    _export('getQuerystring', getQuerystring);

    _export('throttle', throttle);

    function noop() {}

    /**
     * Given a min and max, restrict the given number
     * to the range.
     * @param min the minimum
     * @param n the value
     * @param max the maximum
     */

    function clamp(min, n, max) {
        return Math.max(min, Math.min(n, max));
    }

    function extend(dst) {
        return _baseExtend(dst, [].slice.call(arguments, 1), false);
    }

    function merge(dst) {
        return _baseExtend(dst, [].slice.call(arguments, 1), true);
    }

    function _baseExtend(dst, objs, deep) {
        for (var i = 0, ii = objs.length; i < ii; ++i) {
            var obj = objs[i];
            if (!obj || !isObject(obj) && !isFunction(obj)) continue;
            var keys = Object.keys(obj);
            for (var j = 0, jj = keys.length; j < jj; j++) {
                var key = keys[j];
                var src = obj[key];
                if (deep && isObject(src)) {
                    if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
                    _baseExtend(dst[key], [src], true);
                } else {
                    dst[key] = src;
                }
            }
        }
        return dst;
    }

    function debounce(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        return function () {
            context = this;
            args = arguments;
            timestamp = new Date();
            var later = function later() {
                var last = new Date() - timestamp;
                if (last < wait) {
                    timeout = setTimeout(later, wait - last);
                } else {
                    timeout = null;
                    if (!immediate) result = func.apply(context, args);
                }
            };
            var callNow = immediate && !timeout;
            if (!timeout) {
                timeout = setTimeout(later, wait);
            }
            if (callNow) result = func.apply(context, args);
            return result;
        };
    }

    function defaults(dest) {
        for (var i = arguments.length - 1; i >= 1; i--) {
            var source = arguments[i] || {};
            for (var key in source) {
                if (source.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {
                    dest[key] = source[key];
                }
            }
        }
        return dest;
    }

    /**
     * Convert a string in the format thisIsAString to a slug format this-is-a-string
     */

    function pascalCaseToDashCase() {
        var str = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

        return str.charAt(0).toLowerCase() + str.substring(1).replace(/[A-Z]/g, function (match) {
            return '-' + match.toLowerCase();
        });
    }

    function nextUid() {
        return ++uid;
    }

    /**
     * Grab the query string param value for the given key.
     * @param key the key to look for
     */

    function getQuerystring(url, key) {
        var queryParams = {};
        if (url) {
            var startIndex = url.indexOf('?');
            if (startIndex !== -1) {
                var queries = url.slice(startIndex + 1).split('&');
                queries.forEach(function (param) {
                    var split = param.split('=');
                    queryParams[split[0].toLowerCase()] = split[1].split('#')[0];
                });
            }
            if (key) {
                return queryParams[key] || '';
            }
        }
        return queryParams;
    }

    function throttle(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        options || (options = {});
        var later = function later() {
            previous = options.leading === false ? 0 : Date.now();
            timeout = null;
            result = func.apply(context, args);
        };
        return function () {
            var now = Date.now();
            if (!previous && options.leading === false) previous = now;
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                result = func.apply(context, args);
            } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    }

    return {
        setters: [],
        execute: function () {
            ;
            isBoolean = function isBoolean(val) {
                return typeof val === 'boolean';
            };

            _export('isBoolean', isBoolean);

            isString = function isString(val) {
                return typeof val === 'string';
            };

            _export('isString', isString);

            isNumber = function isNumber(val) {
                return typeof val === 'number';
            };

            _export('isNumber', isNumber);

            isFunction = function isFunction(val) {
                return typeof val === 'function';
            };

            _export('isFunction', isFunction);

            isDefined = function isDefined(val) {
                return typeof val !== 'undefined';
            };

            _export('isDefined', isDefined);

            isUndefined = function isUndefined(val) {
                return typeof val === 'undefined';
            };

            _export('isUndefined', isUndefined);

            isBlank = function isBlank(val) {
                return val === undefined || val === null;
            };

            _export('isBlank', isBlank);

            isObject = function isObject(val) {
                return typeof val === 'object';
            };

            _export('isObject', isObject);

            isArray = Array.isArray;

            _export('isArray', isArray);

            isTrueProperty = function isTrueProperty(val) {
                return typeof val !== 'undefined' && val !== "false";
            };

            _export('isTrueProperty', isTrueProperty);

            uid = 0;
            array = {
                find: function find(arr, cb) {
                    for (var i = 0, ii = arr.length; i < ii; i++) {
                        if (cb(arr[i], i)) return arr[i];
                    }
                },
                remove: function remove(arr, itemOrIndex) {
                    var index = -1;
                    if (isNumber(itemOrIndex)) {
                        index = itemOrIndex;
                    } else {
                        index = arr.indexOf(itemOrIndex);
                    }
                    if (index < 0) {
                        return false;
                    }
                    arr.splice(index, 1);
                    return true;
                }
            };

            _export('array', array);
        }
    };
});
System.register("ionic/components/action-sheet/action-sheet", ["angular2/core", "angular2/common", "../nav/nav-controller", "../nav/view-controller", "../../config/config", "../icon/icon", "../../animations/animation"], function (_export) {
    /**
     * @name ActionSheet
     * @description
     * An Action Sheet is a dialog that lets the user choose from a set of
     * options. It appears on top of the app's content, and must be manually
     * dismissed by the user before they can resume interaction with the app.
     * Dangerous (destructive) options are made obvious. There are easy
     * ways to cancel out of the action sheet, such as tapping the backdrop or
     * hitting the escape key on desktop.
     *
     * An action sheet is created from an array of `buttons`, with each button
     * including properties for its `text`, and optionally a `style` and `handler`.
     * If a handler returns `false` then the action sheet will not be dismissed. An
     * action sheet can also optionally have a `title` and a `subTitle`.
     *
     * A button's `style` property can either be `destructive` or `cancel`. Buttons
     * without a style property will have a default style for its platform. Buttons
     * with the `cancel` style will always load as the bottom button, no matter where
     * it shows up in the array. All other buttons will show up in the order they
     * have been added to the `buttons` array. Note: We recommend that `destructive`
     * buttons show be the first button in the array, making it the button on top.
     *
     * Its shorthand is to add all the action sheet's options from within the
     * `ActionSheet.create(opts)` first argument. Otherwise the action sheet's
     * instance has methods to add options, such as `setTitle()` or `addButton()`.
     *
     * @usage
     * ```ts
     * constructor(nav: NavController) {
     *   this.nav = nav;
     * }
     *
     * presentActionSheet() {
     *   let actionSheet = ActionSheet.create({
     *     title: 'Modify your album',
     *     buttons: [
     *       {
     *         text: 'Destructive',
     *         style: 'destructive',
     *         handler: () => {
     *           console.log('Destructive clicked');
     *         }
     *       },
     *       {
     *         text: 'Archive',
     *         handler: () => {
     *           console.log('Archive clicked');
     *         }
     *       },
     *       {
     *         text: 'Cancel',
     *         style: 'cancel',
     *         handler: () => {
     *           console.log('Cancel clicked');
     *         }
     *       }
     *     ]
     *   });
     *
     *   this.nav.present(actionSheet);
     * }
     * ```
     *
     * @demo /docs/v3/demos/action-sheet/
     * @see {@link /docs/v3/components#action-sheets ActionSheet Component Docs}
     */
    "use strict";

    var Component, Renderer, NgFor, NgIf, NavParams, ViewController, Config, Icon, Animation, __decorate, __metadata, ActionSheet, ActionSheetCmp, ActionSheetSlideIn, ActionSheetSlideOut, ActionSheetMdSlideIn, ActionSheetMdSlideOut, _a, _b, _c, _d;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            Renderer = _angular2Core.Renderer;
        }, function (_angular2Common) {
            NgFor = _angular2Common.NgFor;
            NgIf = _angular2Common.NgIf;
        }, function (_navNavController) {
            NavParams = _navNavController.NavParams;
        }, function (_navViewController) {
            ViewController = _navViewController.ViewController;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_iconIcon) {
            Icon = _iconIcon.Icon;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ActionSheet = (function (_ViewController) {
                _inherits(ActionSheet, _ViewController);

                function ActionSheet() {
                    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                    _classCallCheck(this, ActionSheet);

                    opts.buttons = opts.buttons || [];
                    _get(Object.getPrototypeOf(ActionSheet.prototype), "constructor", this).call(this, ActionSheetCmp, opts);
                    this.viewType = 'action-sheet';
                }

                /**
                * @private
                */

                /**
                * @private
                */

                _createClass(ActionSheet, [{
                    key: "getTransitionName",
                    value: function getTransitionName(direction) {
                        var key = 'actionSheet' + (direction === 'back' ? 'Leave' : 'Enter');
                        return this._nav && this._nav.config.get(key);
                    }

                    /**
                     * @param {string} title Action sheet title
                     */
                }, {
                    key: "setTitle",
                    value: function setTitle(title) {
                        this.data.title = title;
                    }

                    /**
                     * @param {string} subTitle Action sheet subtitle
                     */
                }, {
                    key: "setSubTitle",
                    value: function setSubTitle(subTitle) {
                        this.data.subTitle = subTitle;
                    }

                    /**
                     * @param {Object} button Action sheet button
                     */
                }, {
                    key: "addButton",
                    value: function addButton(button) {
                        this.data.buttons.push(button);
                    }

                    /**
                     * @param {Object} opts Action sheet options
                     */
                }], [{
                    key: "create",
                    value: function create() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        return new ActionSheet(opts);
                    }
                }]);

                return ActionSheet;
            })(ViewController);

            _export("ActionSheet", ActionSheet);

            ActionSheetCmp = (function () {
                function ActionSheetCmp(_viewCtrl, _config, params, renderer) {
                    _classCallCheck(this, ActionSheetCmp);

                    this._viewCtrl = _viewCtrl;
                    this._config = _config;
                    this.d = params.data;
                    if (this.d.cssClass) {
                        renderer.setElementClass(elementRef, this.d.cssClass, true);
                    }
                }

                _createClass(ActionSheetCmp, [{
                    key: "click",
                    value: function click(button) {
                        var _this = this;

                        var shouldDismiss = true;
                        if (button.handler) {
                            // a handler has been provided, execute it
                            if (button.handler() === false) {
                                // if the return value of the handler is false then do not dismiss
                                shouldDismiss = false;
                            }
                        }
                        if (shouldDismiss) {
                            setTimeout(function () {
                                _this.dismiss();
                            }, this._config.get('pageTransitionDelay'));
                        }
                    }
                }, {
                    key: "dismiss",
                    value: function dismiss() {
                        this._viewCtrl.dismiss();
                    }
                }, {
                    key: "onPageLoaded",
                    value: function onPageLoaded() {
                        var _this2 = this;

                        // normalize the data
                        var buttons = [];
                        this.d.buttons.forEach(function (button) {
                            if (typeof button === 'string') {
                                button = { text: button };
                            }
                            if (!button.cssClass) {
                                button.cssClass = '';
                            }
                            if (button.style === 'cancel') {
                                _this2.d.cancelButton = button;
                            } else {
                                if (button.style === 'destructive') {
                                    button.cssClass = (button.cssClass + ' ' || '') + 'action-sheet-destructive';
                                }
                                buttons.push(button);
                            }
                        });
                        this.d.buttons = buttons;
                        var self = this;
                        self.keyUp = function (ev) {
                            if (ev.keyCode === 27) {
                                console.debug('actionsheet escape');
                                self.dismiss();
                            }
                        };
                        document.addEventListener('keyup', this.keyUp);
                    }
                }, {
                    key: "onPageDidLeave",
                    value: function onPageDidLeave() {
                        document.removeEventListener('keyup', this.keyUp);
                    }
                }]);

                return ActionSheetCmp;
            })();

            ActionSheetCmp = __decorate([Component({
                selector: 'ion-action-sheet',
                template: '<div (click)="dismiss()" tappable disable-activated class="backdrop" role="presentation"></div>' + '<div class="action-sheet-wrapper">' + '<div class="action-sheet-container">' + '<div class="action-sheet-group">' + '<div class="action-sheet-title" *ngIf="d.title">{{d.title}}</div>' + '<div class="action-sheet-sub-title" *ngIf="d.subTitle">{{d.subTitle}}</div>' + '<button (click)="click(b)" *ngFor="#b of d.buttons" class="action-sheet-button disable-hover" [ngClass]="b.cssClass">' + '<ion-icon [name]="b.icon" *ngIf="b.icon" class="action-sheet-icon"></ion-icon> ' + '{{b.text}}' + '</button>' + '</div>' + '<div class="action-sheet-group" *ngIf="d.cancelButton">' + '<button (click)="click(d.cancelButton)" class="action-sheet-button action-sheet-cancel disable-hover" [ngClass]="d.cancelButton.cssClass">' + '<ion-icon [name]="d.cancelButton.icon" *ngIf="d.cancelButton.icon" class="action-sheet-icon"></ion-icon> ' + '{{d.cancelButton.text}}' + '</button>' + '</div>' + '</div>' + '</div>',
                host: {
                    'role': 'dialog'
                },
                directives: [NgFor, NgIf, Icon]
            }), __metadata('design:paramtypes', [typeof (_a = typeof ViewController !== 'undefined' && ViewController) === 'function' && _a || Object, typeof (_b = typeof Config !== 'undefined' && Config) === 'function' && _b || Object, typeof (_c = typeof NavParams !== 'undefined' && NavParams) === 'function' && _c || Object, typeof (_d = typeof Renderer !== 'undefined' && Renderer) === 'function' && _d || Object])], ActionSheetCmp);

            ActionSheetSlideIn = (function (_Animation) {
                _inherits(ActionSheetSlideIn, _Animation);

                function ActionSheetSlideIn(enteringView, leavingView, opts) {
                    _classCallCheck(this, ActionSheetSlideIn);

                    _get(Object.getPrototypeOf(ActionSheetSlideIn.prototype), "constructor", this).call(this, null, opts);
                    var ele = enteringView.pageRef().nativeElement;
                    var backdrop = new Animation(ele.querySelector('.backdrop'));
                    var wrapper = new Animation(ele.querySelector('.action-sheet-wrapper'));
                    backdrop.fromTo('opacity', 0.01, 0.4);
                    wrapper.fromTo('translateY', '100%', '0%');
                    this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add([backdrop, wrapper]);
                }

                return ActionSheetSlideIn;
            })(Animation);

            Animation.register('action-sheet-slide-in', ActionSheetSlideIn);

            ActionSheetSlideOut = (function (_Animation2) {
                _inherits(ActionSheetSlideOut, _Animation2);

                function ActionSheetSlideOut(enteringView, leavingView, opts) {
                    _classCallCheck(this, ActionSheetSlideOut);

                    _get(Object.getPrototypeOf(ActionSheetSlideOut.prototype), "constructor", this).call(this, null, opts);
                    var ele = leavingView.pageRef().nativeElement;
                    var backdrop = new Animation(ele.querySelector('.backdrop'));
                    var wrapper = new Animation(ele.querySelector('.action-sheet-wrapper'));
                    backdrop.fromTo('opacity', 0.4, 0);
                    wrapper.fromTo('translateY', '0%', '100%');
                    this.easing('cubic-bezier(.36,.66,.04,1)').duration(300).add([backdrop, wrapper]);
                }

                return ActionSheetSlideOut;
            })(Animation);

            Animation.register('action-sheet-slide-out', ActionSheetSlideOut);

            ActionSheetMdSlideIn = (function (_Animation3) {
                _inherits(ActionSheetMdSlideIn, _Animation3);

                function ActionSheetMdSlideIn(enteringView, leavingView, opts) {
                    _classCallCheck(this, ActionSheetMdSlideIn);

                    _get(Object.getPrototypeOf(ActionSheetMdSlideIn.prototype), "constructor", this).call(this, null, opts);
                    var ele = enteringView.pageRef().nativeElement;
                    var backdrop = new Animation(ele.querySelector('.backdrop'));
                    var wrapper = new Animation(ele.querySelector('.action-sheet-wrapper'));
                    backdrop.fromTo('opacity', 0.01, 0.26);
                    wrapper.fromTo('translateY', '100%', '0%');
                    this.easing('cubic-bezier(.36,.66,.04,1)').duration(450).add([backdrop, wrapper]);
                }

                return ActionSheetMdSlideIn;
            })(Animation);

            Animation.register('action-sheet-md-slide-in', ActionSheetMdSlideIn);

            ActionSheetMdSlideOut = (function (_Animation4) {
                _inherits(ActionSheetMdSlideOut, _Animation4);

                function ActionSheetMdSlideOut(enteringView, leavingView, opts) {
                    _classCallCheck(this, ActionSheetMdSlideOut);

                    _get(Object.getPrototypeOf(ActionSheetMdSlideOut.prototype), "constructor", this).call(this, null, opts);
                    var ele = leavingView.pageRef().nativeElement;
                    var backdrop = new Animation(ele.querySelector('.backdrop'));
                    var wrapper = new Animation(ele.querySelector('.action-sheet-wrapper'));
                    backdrop.fromTo('opacity', 0.26, 0);
                    wrapper.fromTo('translateY', '0%', '100%');
                    this.easing('cubic-bezier(.36,.66,.04,1)').duration(450).add([backdrop, wrapper]);
                }

                return ActionSheetMdSlideOut;
            })(Animation);

            Animation.register('action-sheet-md-slide-out', ActionSheetMdSlideOut);
        }
    };
});
System.register("ionic/components/alert/alert", ["angular2/core", "angular2/common", "../nav/nav-controller", "../nav/view-controller", "../../config/config", "../../animations/animation", "../../util/util"], function (_export) {
    /**
     * @name Alert
     * @description
     * An Alert is a dialog that presents users with either information, or used
     * to receive information from the user using inputs. An alert appears on top
     * of the app's content, and must be manually dismissed by the user before
     * they can resume interaction with the app.
     *
     * An alert is created from an array of `buttons` and optionally an array of
     * `inputs`. Each button includes properties for its `text`, and optionally a
     * `handler`. If a handler returns `false` then the alert will not be dismissed.
     * An alert can also optionally have a `title`, `subTitle` and `body`.
     *
     * All buttons will show up in the order they have been added to the `buttons`
     * array, from left to right. Note: The right most button (the last one in the
     * array) is the main button.
     *
     * Alerts can also include inputs whos data can be passed back to the app.
     * Inputs can be used to prompt users for information.
     *
     * Its shorthand is to add all the alert's options from within the
     * `Alert.create(opts)` first argument. Otherwise the alert's
     * instance has methods to add options, such as `setTitle()` or `addButton()`.
     *
     * @usage
     * ```ts
     * constructor(nav: NavController) {
     *   this.nav = nav;
     * }
     *
     * presentAlert() {
     *   let alert = Alert.create({
     *     title: 'Low battery',
     *     subTitle: '10% of battery remaining',
     *     buttons: ['Dismiss']
     *   });
     *   this.nav.present(alert);
     * }
     *
     * presentConfirm() {
     *   let alert = Alert.create({
     *     title: 'Confirm purchase',
     *     body: 'Do you want to buy this book?',
     *     buttons: [
     *       {
     *         text: 'Cancel',
     *         handler: () => {
     *           console.log('Cancel clicked');
     *         }
     *       },
     *       {
     *         text: 'Buy',
     *         handler: () => {
     *           console.log('Buy clicked');
     *         }
     *       }
     *     ]
     *   });
     *   this.nav.present(alert);
     * }
     *
     * presentPrompt() {
     *   let alert = Alert.create({
     *     title: 'Login',
     *     inputs: [
     *       {
     *         name: 'username',
     *         placeholder: 'Username'
     *       },
     *       {
     *         name: 'password',
     *         placeholder: 'Password',
     *         type: 'password'
     *       }
     *     ],
     *     buttons: [
     *       {
     *         text: 'Cancel',
     *         handler: data => {
     *           console.log('Cancel clicked');
     *         }
     *       },
     *       {
     *         text: 'Login',
     *         handler: data => {
     *           if (User.isValid(data.username, data.password)) {
     *             // logged in!
     *           } else {
     *             // invalid login
     *             return false;
     *           }
     *         }
     *       }
     *     ]
     *   });
     *   this.nav.present(alert);
     * }
     * ```
     *
     */
    "use strict";

    var Component, ElementRef, Renderer, NgClass, NgIf, NgFor, NavParams, ViewController, Config, Animation, isDefined, __decorate, __metadata, Alert, AlertCmp, AlertPopIn, AlertPopOut, AlertMdPopIn, AlertMdPopOut, _a, _b, _c, _d, _e;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            ElementRef = _angular2Core.ElementRef;
            Renderer = _angular2Core.Renderer;
        }, function (_angular2Common) {
            NgClass = _angular2Common.NgClass;
            NgIf = _angular2Common.NgIf;
            NgFor = _angular2Common.NgFor;
        }, function (_navNavController) {
            NavParams = _navNavController.NavParams;
        }, function (_navViewController) {
            ViewController = _navViewController.ViewController;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_utilUtil) {
            isDefined = _utilUtil.isDefined;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Alert = (function (_ViewController) {
                _inherits(Alert, _ViewController);

                function Alert() {
                    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                    _classCallCheck(this, Alert);

                    opts.inputs = opts.inputs || [];
                    opts.buttons = opts.buttons || [];
                    _get(Object.getPrototypeOf(Alert.prototype), "constructor", this).call(this, AlertCmp, opts);
                    this.viewType = 'alert';
                }

                /**
                * @private
                */

                /**
                * @private
                */

                _createClass(Alert, [{
                    key: "getTransitionName",
                    value: function getTransitionName(direction) {
                        var key = direction === 'back' ? 'alertLeave' : 'alertEnter';
                        return this._nav && this._nav.config.get(key);
                    }

                    /**
                     * @param {string} title Alert title
                     */
                }, {
                    key: "setTitle",
                    value: function setTitle(title) {
                        this.data.title = title;
                    }

                    /**
                     * @param {string} subTitle Alert subtitle
                     */
                }, {
                    key: "setSubTitle",
                    value: function setSubTitle(subTitle) {
                        this.data.subTitle = subTitle;
                    }

                    /**
                     * @param {string} body Alert body content
                     */
                }, {
                    key: "setBody",
                    value: function setBody(body) {
                        this.data.body = body;
                    }

                    /**
                     * @param {Object} input Alert input
                     */
                }, {
                    key: "addInput",
                    value: function addInput(input) {
                        this.data.inputs.push(input);
                    }

                    /**
                     * @param {Object} button Alert button
                     */
                }, {
                    key: "addButton",
                    value: function addButton(button) {
                        this.data.buttons.push(button);
                    }

                    /**
                     * @param {Object} opts Alert options
                     */
                }], [{
                    key: "create",
                    value: function create() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        return new Alert(opts);
                    }
                }]);

                return Alert;
            })(ViewController);

            _export("Alert", Alert);

            AlertCmp = (function () {
                function AlertCmp(_viewCtrl, _elementRef, _config, params, renderer) {
                    _classCallCheck(this, AlertCmp);

                    this._viewCtrl = _viewCtrl;
                    this._elementRef = _elementRef;
                    this._config = _config;
                    this.d = params.data;
                    if (this.d.cssClass) {
                        renderer.setElementClass(_elementRef, this.d.cssClass, true);
                    }
                }

                _createClass(AlertCmp, [{
                    key: "click",
                    value: function click(button) {
                        var _this = this;

                        var shouldDismiss = true;
                        if (button.handler) {
                            // a handler has been provided, execute it
                            // pass the handler the values from the inputs
                            if (button.handler(this.getValues()) === false) {
                                // if the return value of the handler is false then do not dismiss
                                shouldDismiss = false;
                            }
                        }
                        if (shouldDismiss) {
                            setTimeout(function () {
                                _this.dismiss();
                            }, this._config.get('pageTransitionDelay'));
                        }
                    }
                }, {
                    key: "dismiss",
                    value: function dismiss() {
                        this._viewCtrl.dismiss(this.getValues());
                    }
                }, {
                    key: "getValues",
                    value: function getValues() {
                        var values = {};
                        this.d.inputs.forEach(function (input) {
                            values[input.name] = input.value;
                        });
                        return values;
                    }
                }, {
                    key: "onPageLoaded",
                    value: function onPageLoaded() {
                        // normalize the data
                        this.d.buttons = this.d.buttons.map(function (button) {
                            if (typeof button === 'string') {
                                return { text: button };
                            }
                            return button;
                        });
                        this.d.inputs = this.d.inputs.map(function (input, index) {
                            return {
                                name: isDefined(input.name) ? input.name : index,
                                placeholder: isDefined(input.placeholder) ? input.placeholder : '',
                                type: input.type || 'text',
                                value: isDefined(input.value) ? input.value : ''
                            };
                        });
                        var self = this;
                        self.keyUp = function (ev) {
                            if (ev.keyCode === 13) {
                                // enter
                                console.debug('alert enter');
                                var button = self.d.buttons[self.d.buttons.length - 1];
                                self.click(button);
                            } else if (ev.keyCode === 27) {
                                console.debug('alert escape');
                                self.dismiss();
                            }
                        };
                        document.addEventListener('keyup', this.keyUp);
                    }
                }, {
                    key: "onPageDidEnter",
                    value: function onPageDidEnter() {
                        document.activeElement && document.activeElement.blur();
                        if (this.d.inputs.length) {
                            var firstInput = this._elementRef.nativeElement.querySelector('input');
                            if (firstInput) {
                                firstInput.focus();
                            }
                        }
                    }
                }, {
                    key: "onPageDidLeave",
                    value: function onPageDidLeave() {
                        document.removeEventListener('keyup', this.keyUp);
                    }
                }]);

                return AlertCmp;
            })();

            AlertCmp = __decorate([Component({
                selector: 'ion-alert',
                template: '<div (click)="dismiss()" tappable disable-activated class="backdrop" role="presentation"></div>' + '<div class="alert-wrapper">' + '<div class="alert-head">' + '<h2 class="alert-title" *ngIf="d.title">{{d.title}}</h2>' + '<h3 class="alert-sub-title" *ngIf="d.subTitle">{{d.subTitle}}</h3>' + '</div>' + '<div class="alert-body" *ngIf="d.body">{{d.body}}</div>' + '<div class="alert-body alert-inputs" *ngIf="d.inputs.length">' + '<div class="alert-input-wrapper" *ngFor="#i of d.inputs">' + '<input [placeholder]="i.placeholder" [(ngModel)]="i.value" [type]="i.type" class="alert-input">' + '</div>' + '</div>' + '<div class="alert-buttons">' + '<button *ngFor="#b of d.buttons" (click)="click(b)" [ngClass]="b.cssClass" class="alert-button">' + '{{b.text}}' + '</button>' + '</div>' + '</div>',
                host: {
                    'role': 'dialog'
                },
                directives: [NgClass, NgIf, NgFor]
            }), __metadata('design:paramtypes', [typeof (_a = typeof ViewController !== 'undefined' && ViewController) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof Config !== 'undefined' && Config) === 'function' && _c || Object, typeof (_d = typeof NavParams !== 'undefined' && NavParams) === 'function' && _d || Object, typeof (_e = typeof Renderer !== 'undefined' && Renderer) === 'function' && _e || Object])], AlertCmp);
            /**
             * Animations for alerts
             */

            AlertPopIn = (function (_Animation) {
                _inherits(AlertPopIn, _Animation);

                function AlertPopIn(enteringView, leavingView, opts) {
                    _classCallCheck(this, AlertPopIn);

                    _get(Object.getPrototypeOf(AlertPopIn.prototype), "constructor", this).call(this, null, opts);
                    var ele = enteringView.pageRef().nativeElement;
                    var backdrop = new Animation(ele.querySelector('.backdrop'));
                    var wrapper = new Animation(ele.querySelector('.alert-wrapper'));
                    wrapper.fromTo('opacity', '0.01', '1').fromTo('scale', '1.1', '1');
                    backdrop.fromTo('opacity', '0.01', '0.3');
                    this.easing('ease-in-out').duration(200).add(backdrop, wrapper);
                }

                return AlertPopIn;
            })(Animation);

            Animation.register('alert-pop-in', AlertPopIn);

            AlertPopOut = (function (_Animation2) {
                _inherits(AlertPopOut, _Animation2);

                function AlertPopOut(enteringView, leavingView, opts) {
                    _classCallCheck(this, AlertPopOut);

                    _get(Object.getPrototypeOf(AlertPopOut.prototype), "constructor", this).call(this, null, opts);
                    var ele = leavingView.pageRef().nativeElement;
                    var backdrop = new Animation(ele.querySelector('.backdrop'));
                    var wrapper = new Animation(ele.querySelector('.alert-wrapper'));
                    wrapper.fromTo('opacity', '1', '0').fromTo('scale', '1', '0.9');
                    backdrop.fromTo('opacity', '0.3', '0');
                    this.easing('ease-in-out').duration(200).add(backdrop, wrapper);
                }

                return AlertPopOut;
            })(Animation);

            Animation.register('alert-pop-out', AlertPopOut);

            AlertMdPopIn = (function (_Animation3) {
                _inherits(AlertMdPopIn, _Animation3);

                function AlertMdPopIn(enteringView, leavingView, opts) {
                    _classCallCheck(this, AlertMdPopIn);

                    _get(Object.getPrototypeOf(AlertMdPopIn.prototype), "constructor", this).call(this, null, opts);
                    var ele = enteringView.pageRef().nativeElement;
                    var backdrop = new Animation(ele.querySelector('.backdrop'));
                    var wrapper = new Animation(ele.querySelector('.alert-wrapper'));
                    wrapper.fromTo('opacity', '0.01', '1').fromTo('scale', '1.1', '1');
                    backdrop.fromTo('opacity', '0.01', '0.5');
                    this.easing('ease-in-out').duration(200).add(backdrop, wrapper);
                }

                return AlertMdPopIn;
            })(Animation);

            Animation.register('alert-md-pop-in', AlertMdPopIn);

            AlertMdPopOut = (function (_Animation4) {
                _inherits(AlertMdPopOut, _Animation4);

                function AlertMdPopOut(enteringView, leavingView, opts) {
                    _classCallCheck(this, AlertMdPopOut);

                    _get(Object.getPrototypeOf(AlertMdPopOut.prototype), "constructor", this).call(this, null, opts);
                    var ele = leavingView.pageRef().nativeElement;
                    var backdrop = new Animation(ele.querySelector('.backdrop'));
                    var wrapper = new Animation(ele.querySelector('.alert-wrapper'));
                    wrapper.fromTo('opacity', '1', '0').fromTo('scale', '1', '0.9');
                    backdrop.fromTo('opacity', '0.5', '0');
                    this.easing('ease-in-out').duration(200).add(backdrop, wrapper);
                }

                return AlertMdPopOut;
            })(Animation);

            Animation.register('alert-md-pop-out', AlertMdPopOut);
        }
    };
});
System.register("ionic/components/app/app", ["angular2/core", "angular2/platform/browser", "../../config/config", "../../util/click-block", "../../util/dom"], function (_export) {
    /**
     * @private
     * Component registry service.  For more information on registering
     * components see the [IdRef API reference](../id/IdRef/).
     */
    "use strict";

    var Injectable, NgZone, Title, Config, ClickBlock, rafFrames, __decorate, __metadata, IonicApp, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Injectable = _angular2Core.Injectable;
            NgZone = _angular2Core.NgZone;
        }, function (_angular2PlatformBrowser) {
            Title = _angular2PlatformBrowser.Title;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_utilDom) {
            rafFrames = _utilDom.rafFrames;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            IonicApp = (function () {
                function IonicApp(_config, _clickBlock, _zone) {
                    _classCallCheck(this, IonicApp);

                    this._config = _config;
                    this._clickBlock = _clickBlock;
                    this._zone = _zone;
                    this._titleSrv = new Title();
                    this._title = '';
                    this._disTime = 0;
                    this._scrollTime = 0;
                    // Our component registry map
                    this.components = {};
                }

                /**
                 * Sets the document title.
                 * @param {string} val  Value to set the document title to.
                 */

                _createClass(IonicApp, [{
                    key: "setTitle",
                    value: function setTitle(val) {
                        var self = this;
                        if (val !== self._title) {
                            self._title = val;
                            this._zone.runOutsideAngular(function () {
                                function setAppTitle() {
                                    self._titleSrv.setTitle(self._title);
                                }
                                rafFrames(4, setAppTitle);
                            });
                        }
                    }

                    /**
                     * @private
                     * Sets if the app is currently enabled or not, meaning if it's
                     * available to accept new user commands. For example, this is set to `false`
                     * while views transition, a modal slides up, an action-sheet
                     * slides up, etc. After the transition completes it is set back to `true`.
                     * @param {bool} isEnabled
                     * @param {bool} fallback  When `isEnabled` is set to `false`, this argument
                     * is used to set the maximum number of milliseconds that app will wait until
                     * it will automatically enable the app again. It's basically a fallback incase
                     * something goes wrong during a transition and the app wasn't re-enabled correctly.
                     */
                }, {
                    key: "setEnabled",
                    value: function setEnabled(isEnabled) {
                        var duration = arguments.length <= 1 || arguments[1] === undefined ? 700 : arguments[1];

                        this._disTime = isEnabled ? 0 : Date.now() + duration;
                        if (duration > 32 || isEnabled) {
                            // only do a click block if the duration is longer than XXms
                            this._clickBlock.show(!isEnabled, duration + 64);
                        }
                    }

                    /**
                     * @private
                     * Boolean if the app is actively enabled or not.
                     * @return {bool}
                     */
                }, {
                    key: "isEnabled",
                    value: function isEnabled() {
                        return this._disTime < Date.now();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setScrolling",
                    value: function setScrolling() {
                        this._scrollTime = Date.now();
                    }

                    /**
                     * @private
                     * Boolean if the app is actively scrolling or not.
                     * @return {bool}
                     */
                }, {
                    key: "isScrolling",
                    value: function isScrolling() {
                        return this._scrollTime + 64 > Date.now();
                    }

                    /**
                     * @private
                     * Register a known component with a key, for easy lookups later.
                     * @param {TODO} id  The id to use to register the component
                     * @param {TODO} component  The component to register
                     */
                }, {
                    key: "register",
                    value: function register(id, component) {
                        if (this.components[id] && this.components[id] !== component) {}
                        this.components[id] = component;
                    }

                    /**
                     * @private
                     * Unregister a known component with a key.
                     * @param {TODO} id  The id to use to unregister
                     */
                }, {
                    key: "unregister",
                    value: function unregister(id) {
                        delete this.components[id];
                    }

                    /**
                     * @private
                     * Get a registered component with the given type (returns the first)
                     * @param {Object} cls the type to search for
                     * @return the matching component, or undefined if none was found
                     */
                }, {
                    key: "getRegisteredComponent",
                    value: function getRegisteredComponent(cls) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var component = _step.value;

                                if (component instanceof cls) {
                                    return component;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }

                    /**
                     * @private
                     * Get the component for the given key.
                     * @param {TODO} key  TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "getComponent",
                    value: function getComponent(id) {
                        return this.components[id];
                    }
                }]);

                return IonicApp;
            })();

            _export("IonicApp", IonicApp);

            _export("IonicApp", IonicApp = __decorate([Injectable(), __metadata('design:paramtypes', [typeof (_a = typeof Config !== 'undefined' && Config) === 'function' && _a || Object, typeof (_b = typeof ClickBlock !== 'undefined' && ClickBlock) === 'function' && _b || Object, typeof (_c = typeof NgZone !== 'undefined' && NgZone) === 'function' && _c || Object])], IonicApp));
        }
    };
});
System.register("ionic/components/app/id", ["angular2/core", "./app"], function (_export) {
    /**
     * @name Id
     * @description
     * IdRef is an easy way to identify unique components in an app and access them
     * no matter where in the UI heirarchy you are. For example, this makes toggling
     * a global side menu feasible from any place in the application.
     *
     * See the [Menu section](https://ionicframework.com/docs/v3/components/#menus) of
     * the Component docs for an example of how Menus rely on ID's.
     *
     * @usage
     * To give any component an ID, simply set its `id` property:
     * ```html
     * <ion-checkbox id="myCheckbox"></ion-checkbox>
     * ```
     *
     * To get a reference to the registered component, inject the [IonicApp](../app/IonicApp/)
     * service:
     * ```ts
     * constructor(app: IonicApp) {
     *    this.app = app
     * }
     * ngAfterViewInit{
     *  var checkbox = this.app.getComponent("myCheckbox");
     *  if (checkbox.checked) {
     *    console.log('checkbox is checked');
     *  }
     * }
     * ```
     *
     * *NOTE:* It is not recommended to use ID's across Pages, as there is often no
     * guarantee that the registered component has not been destroyed if its Page
     * has been navigated away from.
     */
    "use strict";

    var AppViewManager, ElementRef, Directive, Renderer, IonicApp, __decorate, __metadata, IdRef, Attr, _a, _b, _c, _d, _e;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            AppViewManager = _angular2Core.AppViewManager;
            ElementRef = _angular2Core.ElementRef;
            Directive = _angular2Core.Directive;
            Renderer = _angular2Core.Renderer;
        }, function (_app2) {
            IonicApp = _app2.IonicApp;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            IdRef = (function () {
                function IdRef(_app, _elementRef, _appViewManager) {
                    _classCallCheck(this, IdRef);

                    this._app = _app;
                    this._elementRef = _elementRef;
                    this._appViewManager = _appViewManager;
                    // Grab the component this directive is attached to
                    this.component = _appViewManager.getComponent(_elementRef);
                }

                /**
                 * @private
                 */

                _createClass(IdRef, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        this._app.register(this.id, this.component);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "ngOnDestroy",
                    value: function ngOnDestroy() {
                        this._app.unregister(this.id);
                    }
                }]);

                return IdRef;
            })();

            _export("IdRef", IdRef);

            _export("IdRef", IdRef = __decorate([Directive({
                selector: '[id]',
                inputs: ['id']
            }), __metadata('design:paramtypes', [typeof (_a = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof AppViewManager !== 'undefined' && AppViewManager) === 'function' && _c || Object])], IdRef));
            /**
             * @name Attr
             * @description
             * Attr allows you to dynamically add or remove an attribute based on the value of an expression or variable.
             * @usage
             * ```html
             * // toggle the no-lines attributes based on whether isAndroid is true or false
             * <ion-list [attr.no-lines]="isAndroid ? '' : null">
             * ```
             * @demo /docs/v3/demos/attr/
             */

            Attr = (function () {
                function Attr(_renderer, _elementRef) {
                    _classCallCheck(this, Attr);

                    this._renderer = _renderer;
                    this._elementRef = _elementRef;
                }

                /**
                 * @private
                 */

                _createClass(Attr, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        this._renderer.setElementAttribute(this._elementRef, this.attr, '');
                    }
                }]);

                return Attr;
            })();

            _export("Attr", Attr);

            _export("Attr", Attr = __decorate([Directive({
                selector: '[attr]',
                inputs: ['attr']
            }), __metadata('design:paramtypes', [typeof (_d = typeof Renderer !== 'undefined' && Renderer) === 'function' && _d || Object, typeof (_e = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _e || Object])], Attr));
        }
    };
});
System.register("ionic/components/blur/blur", ["angular2/core"], function (_export) {
    /**
     * @name Blur
     * @description
     * The blur attribute applies the CSS blur attribute to an element. If the CSS attribute is not supported,
     * it will fall back to applying a semi-transparent background color to the element.
     *
     * @usage
     * ```html
     * <ion-card blur>
     *    This card will blur the content behind it.
     * </ion-card>
     * ```
     *
     * @demo /docs/v3/demos/blur/
     */
    "use strict";

    var Directive, Renderer, ElementRef, __decorate, __metadata, Blur, _a, _b;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            Renderer = _angular2Core.Renderer;
            ElementRef = _angular2Core.ElementRef;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Blur = function Blur(_elementRef, _renderer) {
                _classCallCheck(this, Blur);

                this._elementRef = _elementRef;
                this._renderer = _renderer;
                _renderer.setElementStyle(_elementRef, '-webkit-backdrop-filter', 'blur(10px)');
            };

            _export("Blur", Blur);

            _export("Blur", Blur = __decorate([Directive({
                selector: '[blur]'
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof Renderer !== 'undefined' && Renderer) === 'function' && _b || Object])], Blur));
        }
    };
});
System.register("ionic/components/button/button", ["angular2/core", "../../config/config"], function (_export) {
    /**
      * @name Button
      * @module ionic
      * @property [outline] - for an unfilled outline button
      * @property [clear] - for a transparent button that only shows text and icons
      * @property [round] - for a button with rounded corners
      * @property [block] - for a block button that fills it's parent container
      * @property [full] - for a full width button
      * @property [small] - sets button size to small
      * @property [large] - sets button size to large
      * @property [disabled] - disables the button
      * @property [fab] - for a floating action button
      * @property [fab-left] - position a fab button to the left
      * @property [fab-right] - position a fab button to the right
      * @property [fab-center] - position a fab button towards the center
      * @property [fab-top] - position a fab button towards the top
      * @property [fab-bottom] - position a fab button towards the bottom
      * @property [color] - Dynamically set which color attribute this button should use.
      * @description
      * Buttons are simple components in Ionic, can consist of text, an icon, or both, and can be enhanced with a wide range of attributes.
      * @demo /docs/v3/demos/buttons/
      * @see {@link /docs/v3/components#buttons Button Component Docs}
    
     */
    "use strict";

    var Directive, ElementRef, Renderer, Attribute, Config, __decorate, __metadata, __param, Button, BUTTON_SIZE_ATTRS, BUTTON_STYLE_ATTRS, BUTTON_SHAPE_ATTRS, BUTTON_DISPLAY_ATTRS, IGNORE_ATTRS, TEXT, ICON, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            ElementRef = _angular2Core.ElementRef;
            Renderer = _angular2Core.Renderer;
            Attribute = _angular2Core.Attribute;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Button = (function () {
                function Button(config, _elementRef, _renderer, ionItem) {
                    _classCallCheck(this, Button);

                    this._elementRef = _elementRef;
                    this._renderer = _renderer;
                    this._role = 'button'; // bar-button/item-button
                    this._size = null; // large/small
                    this._style = 'default'; // outline/clear/solid
                    this._shape = null; // round/fab
                    this._display = null; // block/full
                    this._lastColor = null;
                    this._colors = []; // primary/secondary
                    this._icon = null; // left/right/only
                    this._disabled = false; // disabled
                    this.isItem = ionItem === '';
                    var element = _elementRef.nativeElement;
                    if (config.get('hoverCSS') === false) {
                        _renderer.setElementClass(_elementRef, 'disable-hover', true);
                    }
                    if (element.hasAttribute('ion-item')) {
                        // no need to put on these classes for an ion-item
                        this._role = null;
                        return;
                    }
                    if (element.hasAttribute('disabled')) {
                        this._disabled = true;
                    }
                    this._readAttrs(element);
                    this._readIcon(element);
                }

                /**
                 * @private
                 */

                _createClass(Button, [{
                    key: "ngAfterContentInit",
                    value: function ngAfterContentInit() {
                        this._lastColor = this.color;
                        if (this.color) {
                            this._colors = [this.color];
                        }
                        this._assignCss(true);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "ngAfterContentChecked",
                    value: function ngAfterContentChecked() {
                        if (this._lastColor !== this.color) {
                            this._assignCss(false);
                            this._lastColor = this.color;
                            this._colors = [this.color];
                            this._assignCss(true);
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "addClass",
                    value: function addClass(className) {
                        this._renderer.setElementClass(this._elementRef, className, true);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setRole",
                    value: function setRole(val) {
                        this._role = val;
                    }
                }, {
                    key: "_readIcon",
                    value: function _readIcon(element) {
                        // figure out if and where the icon lives in the button
                        var childNodes = element.childNodes;
                        var childNode = undefined;
                        var nodes = [];
                        for (var i = 0, l = childNodes.length; i < l; i++) {
                            childNode = childNodes[i];
                            if (childNode.nodeType === 3) {
                                // text node
                                if (childNode.textContent.trim() !== '') {
                                    nodes.push(TEXT);
                                }
                            } else if (childNode.nodeType === 1) {
                                if (childNode.nodeName === 'ION-ICON') {
                                    // icon element node
                                    nodes.push(ICON);
                                } else {
                                    // element other than an <ion-icon>
                                    nodes.push(TEXT);
                                }
                            }
                        }
                        if (nodes.length > 1) {
                            if (nodes[0] === ICON && nodes[1] === TEXT) {
                                this._icon = 'icon-left';
                            } else if (nodes[0] === TEXT && nodes[1] === ICON) {
                                this._icon = 'icon-right';
                            }
                        } else if (nodes.length === 1 && nodes[0] === ICON) {
                            this._icon = 'icon-only';
                        }
                    }
                }, {
                    key: "_readAttrs",
                    value: function _readAttrs(element) {
                        var elementAttrs = element.attributes;
                        var attrName = undefined;
                        for (var i = 0, l = elementAttrs.length; i < l; i++) {
                            if (elementAttrs[i].value !== '') continue;
                            attrName = elementAttrs[i].name;
                            if (BUTTON_STYLE_ATTRS.indexOf(attrName) > -1) {
                                this._style = attrName;
                            } else if (BUTTON_DISPLAY_ATTRS.indexOf(attrName) > -1) {
                                this._display = attrName;
                            } else if (BUTTON_SHAPE_ATTRS.indexOf(attrName) > -1) {
                                this._shape = attrName;
                            } else if (BUTTON_SIZE_ATTRS.indexOf(attrName) > -1) {
                                this._size = attrName;
                            } else if (!IGNORE_ATTRS.test(attrName)) {
                                this._colors.push(attrName);
                            }
                        }
                    }
                }, {
                    key: "_assignCss",
                    value: function _assignCss(assignCssClass) {
                        var _this = this;

                        var role = this._role;
                        if (role) {
                            (function () {
                                _this._renderer.setElementClass(_this._elementRef, role, assignCssClass); // button
                                _this._setClass(_this._style, assignCssClass); // button-clear
                                _this._setClass(_this._shape, assignCssClass); // button-round
                                _this._setClass(_this._display, assignCssClass); // button-full
                                _this._setClass(_this._size, assignCssClass); // button-small
                                _this._setClass(_this._icon, assignCssClass); // button-icon-left
                                var colorStyle = _this._style !== 'default' ? _this._style + '-' : '';
                                _this._colors.forEach(function (colorName) {
                                    _this._setClass(colorStyle + colorName, assignCssClass); // button-secondary, button-clear-secondary
                                });
                            })();
                        }
                    }
                }, {
                    key: "_setClass",
                    value: function _setClass(type, assignCssClass) {
                        if (type) {
                            this._renderer.setElementClass(this._elementRef, this._role + '-' + type, assignCssClass);
                        }
                    }

                    /**
                     * @private
                     */
                }], [{
                    key: "setRoles",
                    value: function setRoles(contentButtonChildren, role) {
                        var buttons = contentButtonChildren.toArray();
                        buttons.forEach(function (button) {
                            button.setRole(role);
                        });
                    }
                }]);

                return Button;
            })();

            _export("Button", Button);

            _export("Button", Button = __decorate([Directive({
                selector: 'button,[button]',
                inputs: ['color']
            }), __param(3, Attribute('ion-item')), __metadata('design:paramtypes', [typeof (_a = typeof Config !== 'undefined' && Config) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof Renderer !== 'undefined' && Renderer) === 'function' && _c || Object, String])], Button));
            BUTTON_SIZE_ATTRS = ['large', 'small'];
            BUTTON_STYLE_ATTRS = ['clear', 'outline', 'solid'];
            BUTTON_SHAPE_ATTRS = ['round', 'fab'];
            BUTTON_DISPLAY_ATTRS = ['block', 'full'];
            IGNORE_ATTRS = /_ng|button|left|right/;
            TEXT = 1;
            ICON = 2;
        }
    };
});
System.register("ionic/components/checkbox/checkbox", ["angular2/core", "angular2/common", "../../util/form"], function (_export) {
    /**
     * The checkbox is no different than the HTML checkbox input, except it's styled differently.
     *
     * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/core/Form-interface.html) for more info on forms and input.
     *
     * @property [checked] - whether or not the checkbox is checked (defaults to false)
     * @property [value] - the value of the checkbox component
     * @property [disabled] - whether or not the checkbox is disabled or not.
     *
     * @usage
     * ```html
     * <ion-checkbox checked="true" value="isChecked" ngControl="htmlCtrl">
     *   HTML5
     * </ion-checkbox>
     * ```
     * @demo /docs/v3/demos/checkbox/
     * @see {@link /docs/v3/components#checkbox Checkbox Component Docs}
     */
    "use strict";

    var Component, Optional, ElementRef, Input, Renderer, HostListener, NgControl, Form, __decorate, __metadata, __param, Checkbox, _a, _b, _c, _d;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            Optional = _angular2Core.Optional;
            ElementRef = _angular2Core.ElementRef;
            Input = _angular2Core.Input;
            Renderer = _angular2Core.Renderer;
            HostListener = _angular2Core.HostListener;
        }, function (_angular2Common) {
            NgControl = _angular2Common.NgControl;
        }, function (_utilForm) {
            Form = _utilForm.Form;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Checkbox = (function () {
                function Checkbox(_form, _elementRef, _renderer, ngControl) {
                    _classCallCheck(this, Checkbox);

                    this._form = _form;
                    this._elementRef = _elementRef;
                    this._renderer = _renderer;
                    this.value = '';
                    this.checked = false;
                    this.disabled = false;
                    _form.register(this);
                    if (ngControl) {
                        ngControl.valueAccessor = this;
                    }
                }

                /**
                 * @private
                 */

                _createClass(Checkbox, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        if (!this.id) {
                            this.id = 'chk-' + this._form.nextId();
                            this._renderer.setElementAttribute(this._elementRef, 'id', this.id);
                        }
                        this.labelId = 'lbl-' + this.id;
                        this._renderer.setElementAttribute(this._elementRef, 'aria-labelledby', this.labelId);
                    }

                    /**
                     * @private
                     * Toggle the checked state of the checkbox. Calls onChange to pass the updated checked state to the model (Control).
                     */
                }, {
                    key: "toggle",
                    value: function toggle() {
                        this.checked = !this.checked;
                    }
                }, {
                    key: "_click",

                    /**
                     * @private
                     */
                    value: function _click(ev) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        this.toggle();
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the model (Control) on change to update
                     * the checked value.
                     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L34
                     */
                }, {
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.checked = value;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "onChange",
                    value: function onChange(val) {}
                    // TODO: figure the whys and the becauses

                    /**
                     * @private
                     */

                }, {
                    key: "onTouched",
                    value: function onTouched(val) {}
                    // TODO: figure the whys and the becauses

                    /**
                     * @private
                     * Angular2 Forms API method called by the view (NgControl) to register the
                     * onChange event handler that updates the model (Control).
                     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L27
                     * @param {Function} fn  the onChange event handler.
                     */

                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the the view (NgControl) to register
                     * the onTouched event handler that marks model (Control) as touched.
                     * @param {Function} fn  onTouched event handler.
                     */
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "ngOnDestroy",
                    value: function ngOnDestroy() {
                        this._form.deregister(this);
                    }
                }, {
                    key: "checked",
                    get: function get() {
                        return !!this._checked;
                    },
                    set: function set(val) {
                        this._checked = !!val;
                        this._renderer.setElementAttribute(this._elementRef, 'aria-checked', this._checked);
                        this.onChange(this._checked);
                    }
                }]);

                return Checkbox;
            })();

            _export("Checkbox", Checkbox);

            __decorate([Input(), __metadata('design:type', String)], Checkbox.prototype, "value", void 0);
            __decorate([Input(), __metadata('design:type', Object)], Checkbox.prototype, "checked", void 0);
            __decorate([Input(), __metadata('design:type', Boolean)], Checkbox.prototype, "disabled", void 0);
            __decorate([Input(), __metadata('design:type', String)], Checkbox.prototype, "id", void 0);
            __decorate([HostListener('click', ['$event']), __metadata('design:type', Function), __metadata('design:paramtypes', [Object]), __metadata('design:returntype', void 0)], Checkbox.prototype, "_click", null);
            _export("Checkbox", Checkbox = __decorate([Component({
                selector: 'ion-checkbox',
                host: {
                    'role': 'checkbox',
                    'class': 'item',
                    'tappable': '',
                    'tabindex': 0,
                    '[attr.aria-disabled]': 'disabled'
                },
                template: '<div class="item-inner">' + '<div class="checkbox-media" disable-activated>' + '<div class="checkbox-icon"></div>' + '</div>' + '<ion-item-content id="{{labelId}}">' + '<ng-content></ng-content>' + '</ion-item-content>' + '</div>'
            }), __param(3, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof Form !== 'undefined' && Form) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof Renderer !== 'undefined' && Renderer) === 'function' && _c || Object, typeof (_d = typeof NgControl !== 'undefined' && NgControl) === 'function' && _d || Object])], Checkbox));
        }
    };
});
System.register("ionic/components/content/content", ["angular2/core", "../ion", "../app/app", "../../config/config", "../../util/dom", "../nav/view-controller", "../../animations/scroll-to"], function (_export) {
    /**
     * @name Content
     * @description
     * The Content component provides an easy to use content area that can be configured to use Ionic's custom Scroll View, or the built in overflow scrolling of the browser.
     *
     * While we recommend using the custom Scroll features in Ionic in most cases, sometimes (for performance reasons) only the browser's native overflow scrolling will suffice, and so we've made it easy to toggle between the Ionic scroll implementation and overflow scrolling.
     *
     * You can implement pull-to-refresh with the [Refresher](../../scroll/Refresher) component.
     *
     * @usage
     * ```html
     * <ion-content id="myContent">
     *   Add your content here!
     * </ion-content>
     * ```
     *
     */
    "use strict";

    var Component, ElementRef, Optional, NgZone, Ion, IonicApp, Config, raf, ViewController, ScrollTo, __decorate, __metadata, __param, Content, _a, _b, _c, _d, _e;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            ElementRef = _angular2Core.ElementRef;
            Optional = _angular2Core.Optional;
            NgZone = _angular2Core.NgZone;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_utilDom) {
            raf = _utilDom.raf;
        }, function (_navViewController) {
            ViewController = _navViewController.ViewController;
        }, function (_animationsScrollTo) {
            ScrollTo = _animationsScrollTo.ScrollTo;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Content = (function (_Ion) {
                _inherits(Content, _Ion);

                /**
                 * @param {ElementRef} elementRef  A reference to the component's DOM element.
                 * @param {Config} config  The config object to change content's default settings.
                 */

                function Content(elementRef, _config, viewCtrl, _app, _zone) {
                    _classCallCheck(this, Content);

                    _get(Object.getPrototypeOf(Content.prototype), "constructor", this).call(this, elementRef, _config);
                    this._config = _config;
                    this._app = _app;
                    this._zone = _zone;
                    this.scrollPadding = 0;
                    if (viewCtrl) {
                        viewCtrl.setContent(this);
                        viewCtrl.setContentRef(elementRef);
                    }
                }

                /**
                 * @private
                 */

                _createClass(Content, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        _get(Object.getPrototypeOf(Content.prototype), "ngOnInit", this).call(this);
                        var self = this;
                        self.scrollElement = self.getNativeElement().children[0];
                        self._scroll = function (ev) {
                            self._app.setScrolling();
                        };
                        if (self._config.get('tapPolyfill') === true) {
                            self._zone.runOutsideAngular(function () {
                                self.scrollElement.addEventListener('scroll', self._scroll);
                            });
                        }
                    }
                }, {
                    key: "ngOnDestroy",
                    value: function ngOnDestroy() {
                        this.scrollElement.removeEventListener('scroll', this._scroll);
                    }

                    /**
                     * Adds the specified scroll handler to the content' scroll element.
                     *
                     * ```ts
                     * @Page({
                     *   template: `<ion-content id="my-content"></ion-content>`
                     * )}
                     * export class MyPage{
                     *    constructor(app: IonicApp){
                     *        this.app = app;
                     *    }
                     *   // Need to wait until the component has been initialized
                     *   ngAfterViewInit() {
                     *     // Here 'my-content' is the ID of my ion-content
                     *     this.content = this.app.getComponent('my-content');
                     *     this.content.addScrollEventListener(this.myScroll);
                     *   }
                     *     myScroll() {
                     *      console.info('They see me scrolling...');
                     *    }
                     * }
                     * ```
                     * @param {Function} handler  The method you want perform when scrolling
                     * @returns {Function} A function that removes the scroll handler.
                     */
                }, {
                    key: "addScrollEventListener",
                    value: function addScrollEventListener(handler) {
                        var _this = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        // ensure we're not creating duplicates
                        this.scrollElement.removeEventListener('scroll', handler);
                        this.scrollElement.addEventListener('scroll', handler);
                        return function () {
                            _this.scrollElement.removeEventListener('scroll', handler);
                        };
                    }
                }, {
                    key: "onScrollEnd",
                    value: function onScrollEnd(callback) {
                        var lastScrollTop = null;
                        var framesUnchanged = 0;
                        var scrollElement = this.scrollElement;
                        function next() {
                            var currentScrollTop = scrollElement.scrollTop;
                            if (lastScrollTop !== null) {
                                if (Math.round(lastScrollTop) === Math.round(currentScrollTop)) {
                                    framesUnchanged++;
                                } else {
                                    framesUnchanged = 0;
                                }
                                if (framesUnchanged > 9) {
                                    return callback();
                                }
                            }
                            lastScrollTop = currentScrollTop;
                            raf(function () {
                                raf(next);
                            });
                        }
                        setTimeout(next, 100);
                    }

                    /**
                     * Adds the specified touchmove handler to the content's scroll element.
                     *
                     * ```ts
                     * @Page({
                     *   template: `<ion-content id="my-content"></ion-content>`
                     * )}
                     * export class MyPage{
                     *    constructor(app: IonicApp){
                     *        this.app = app;
                     *    }
                     *   // Need to wait until the component has been initialized
                     *   ngAfterViewInit() {
                     *     // Here 'my-content' is the ID of my ion-content
                     *     this.content = this.app.getComponent('my-content');
                     *     this.content.addTouchMoveListener(this.touchHandler);
                     *   }
                     *    touchHandler() {
                     *      console.log("I'm touching all the magazines!!");
                     *    }
                     * }
                     * ```
                     * @param {Function} handler  The method you want to perform when touchmove is firing
                     * @returns {Function} A function that removes the touchmove handler.
                     */
                }, {
                    key: "addTouchMoveListener",
                    value: function addTouchMoveListener(handler) {
                        var _this2 = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        // ensure we're not creating duplicates
                        this.scrollElement.removeEventListener('touchmove', handler);
                        this.scrollElement.addEventListener('touchmove', handler);
                        return function () {
                            _this2.scrollElement.removeEventListener('touchmove', handler);
                        };
                    }

                    /**
                     * Scroll to the specified position.
                     *
                     * ```ts
                     * @Page({
                     *   template: `<ion-content id="my-content">
                     *      <button (click)="scrollTo()"> Down 500px</button>
                     *   </ion-content>`
                     * )}
                     * export class MyPage{
                     *    constructor(app: IonicApp){
                     *        this.app = app;
                     *    }
                     *   // Need to wait until the component has been initialized
                     *   ngAfterViewInit() {
                     *     // Here 'my-content' is the ID of my ion-content
                     *     this.content = this.app.getComponent('my-content');
                     *   }
                     *    scrollTo() {
                     *      this.content.scrollTo(0, 500, 200);
                     *    }
                     * }
                     * ```
                     * @param {Number} x  The x-value to scroll to.
                     * @param {Number} y  The y-value to scroll to.
                     * @param {Number} duration  Duration of the scroll animation in ms.
                     * @param {TODO} tolerance  TODO
                     * @returns {Promise} Returns a promise when done
                     */
                }, {
                    key: "scrollTo",
                    value: function scrollTo(x, y, duration, tolerance) {
                        if (this._scrollTo) {
                            this._scrollTo.dispose();
                        }
                        this._scrollTo = new ScrollTo(this.scrollElement);
                        return this._scrollTo.start(x, y, duration, tolerance);
                    }

                    /**
                     * Scroll to the specified position.
                     *
                     * ```ts
                     * @Page({
                     *   template: `<ion-content id="my-content">
                     *      <button (click)="scrollTop()"> Down 500px</button>
                     *   </ion-content>`
                     * )}
                     * export class MyPage{
                     *    constructor(app: IonicApp){
                     *        this.app = app;
                     *    }
                     *   // Need to wait until the component has been initialized
                     *   ngAfterViewInit() {
                     *     // Here 'my-content' is the ID of my ion-content
                     *     this.content = this.app.getComponent('my-content');
                     *   }
                     *    scrollTop() {
                     *      this.content.scrollTop();
                     *    }
                     * }
                     * ```
                     * @returns {Promise} Returns a promise when done
                     */
                }, {
                    key: "scrollToTop",
                    value: function scrollToTop() {
                        if (this._scrollTo) {
                            this._scrollTo.dispose();
                        }
                        this._scrollTo = new ScrollTo(this.scrollElement);
                        return this._scrollTo.start(0, 0, 300, 0);
                    }

                    /**
                     * @private
                     * Returns the content and scroll elements' dimensions.
                     * @returns {Object} dimensions  The content and scroll elements' dimensions
                     * {Number} dimensions.contentHeight  content offsetHeight
                     * {Number} dimensions.contentTop  content offsetTop
                     * {Number} dimensions.contentBottom  content offsetTop+offsetHeight
                     * {Number} dimensions.contentWidth  content offsetWidth
                     * {Number} dimensions.contentLeft  content offsetLeft
                     * {Number} dimensions.contentRight  content offsetLeft + offsetWidth
                     * {Number} dimensions.scrollHeight  scroll scrollHeight
                     * {Number} dimensions.scrollTop  scroll scrollTop
                     * {Number} dimensions.scrollBottom  scroll scrollTop + scrollHeight
                     * {Number} dimensions.scrollWidth  scroll scrollWidth
                     * {Number} dimensions.scrollLeft  scroll scrollLeft
                     * {Number} dimensions.scrollRight  scroll scrollLeft + scrollWidth
                     */
                }, {
                    key: "getDimensions",
                    value: function getDimensions() {
                        var scrollElement = this.scrollElement;
                        var parentElement = scrollElement.parentElement;
                        return {
                            contentHeight: parentElement.offsetHeight,
                            contentTop: parentElement.offsetTop,
                            contentBottom: parentElement.offsetTop + parentElement.offsetHeight,
                            contentWidth: parentElement.offsetWidth,
                            contentLeft: parentElement.offsetLeft,
                            contentRight: parentElement.offsetLeft + parentElement.offsetWidth,
                            scrollHeight: scrollElement.scrollHeight,
                            scrollTop: scrollElement.scrollTop,
                            scrollBottom: scrollElement.scrollTop + scrollElement.scrollHeight,
                            scrollWidth: scrollElement.scrollWidth,
                            scrollLeft: scrollElement.scrollLeft,
                            scrollRight: scrollElement.scrollLeft + scrollElement.scrollWidth
                        };
                    }

                    /**
                     * @private
                     * Adds padding to the bottom of the scroll element when the keyboard is open
                     * so content below the keyboard can be scrolled into view.
                     */
                }, {
                    key: "addScrollPadding",
                    value: function addScrollPadding(newScrollPadding) {
                        if (newScrollPadding > this.scrollPadding) {
                            console.debug('addScrollPadding', newScrollPadding);
                            this.scrollPadding = newScrollPadding;
                            this.scrollElement.style.paddingBottom = newScrollPadding + 'px';
                        }
                    }
                }]);

                return Content;
            })(Ion);

            _export("Content", Content);

            _export("Content", Content = __decorate([Component({
                selector: 'ion-content',
                template: '<scroll-content>' + '<ng-content></ng-content>' + '</scroll-content>'
            }), __param(2, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof Config !== 'undefined' && Config) === 'function' && _b || Object, typeof (_c = typeof ViewController !== 'undefined' && ViewController) === 'function' && _c || Object, typeof (_d = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _d || Object, typeof (_e = typeof NgZone !== 'undefined' && NgZone) === 'function' && _e || Object])], Content));
        }
    };
});
System.register("ionic/components/icon/icon", ["angular2/core", "../../config/config"], function (_export) {
    /**
     * @name Icon
     * @description
     * Icons can be used on their own, or inside of a number of Ionic components.
     * For a full list of available icons, check out the
     * [Ionicons resource docs](../../../../resources/ionicons).
     *
     * One feature of Ionicons is that when icon names are set, the actual icon
     * which is rendered can change slightly depending on the mode the app is
     * running from. For example, by setting the icon name of `alarm`, on iOS the
     * icon will automatically apply `ios-alarm`, and on Material Design it will
     * automatically apply `md-alarm`. This allow the developer to write the
     * markup once, and let Ionic automatically apply the appropriate icon.
     *
     * @usage
     * ```html
     * <!-- automatically uses the correct "star" icon depending on the mode -->
     * <ion-icon name="star"></ion-icon>
     *
     * <!-- explicity set the icon for each mode -->
     * <ion-icon ios="ios-home" md="md-home"></ion-icon>
     *
     * <!-- always use the same icon, no matter what the mode -->
     * <ion-icon name="ios-clock"></ion-icon>
     * <ion-icon name="twitter-logo"></ion-icon>
     * ```
     *
     * @property {string} [name] - Use the appropriate icon for the mode.
     * @property {string} [ios] - Explicitly set the icon to use on iOS.
     * @property {string} [md] - Explicitly set the icon to use on Android.
     * @property {boolean} [isActive] - Whether or not the icon has an "active"
     * appearance. On iOS an active icon is filled in or full appearance, and an
     * inactive icon on iOS will use an outlined version of the icon same icon.
     * Material Design icons do not change appearance depending if they're active
     * or not. The `isActive` property is largely used by the tabbar.
     * @see {@link /docs/v3/components#icons Icon Component Docs}
     *
     */
    "use strict";

    var Directive, ElementRef, Renderer, Config, __decorate, __metadata, Icon, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            ElementRef = _angular2Core.ElementRef;
            Renderer = _angular2Core.Renderer;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Icon = (function () {
                function Icon(config, _elementRef, _renderer) {
                    _classCallCheck(this, Icon);

                    this._elementRef = _elementRef;
                    this._renderer = _renderer;
                    this.mode = config.get('iconMode');
                    this._name = '';
                    this._ios = '';
                    this._md = '';
                    this._css = '';
                    if (_elementRef.nativeElement.tagName === 'ICON') {
                        // deprecated warning
                        console.warn('<icon> has been renamed to <ion-icon>');
                        console.warn('<ion-icon> requires the "name" attribute w/ a value');
                        console.warn('<icon home></icon> should now be <ion-icon name="home"></ion-icon>');
                    }
                }

                _createClass(Icon, [{
                    key: "update",

                    /**
                     * @private
                     */
                    value: function update() {
                        var css = 'ion-';
                        if (this._ios && this.mode === 'ios') {
                            css += this._ios;
                        } else if (this._md && this.mode === 'md') {
                            css += this._md;
                        } else {
                            css += this._name;
                        }
                        if (this.mode == 'ios' && !this.isActive) {
                            css += '-outline';
                        }
                        if (this._css !== css) {
                            if (this._css) {
                                this._renderer.setElementClass(this._elementRef, this._css, false);
                            }
                            this._css = css;
                            this._renderer.setElementClass(this._elementRef, css, true);
                            this._renderer.setElementAttribute(this._elementRef, 'aria-label', css.replace('ion-', '').replace('ios-', '').replace('md-', '').replace('-', ' '));
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "addClass",
                    value: function addClass(className) {
                        this._renderer.setElementClass(this._elementRef, className, true);
                    }
                }, {
                    key: "name",
                    get: function get() {
                        return this._name;
                    },

                    /**
                     * @private
                     */
                    set: function set(val) {
                        if (!/^md-|^ios-|-logo$/.test(val)) {
                            // this does not have one of the defaults
                            // so lets auto add in the mode prefix for them
                            val = this.mode + '-' + val;
                        }
                        this._name = val;
                        this.update();
                    }
                }, {
                    key: "ios",
                    get: function get() {
                        return this._ios;
                    },

                    /**
                     * @private
                     */
                    set: function set(val) {
                        this._ios = val;
                        this.update();
                    }
                }, {
                    key: "md",
                    get: function get() {
                        return this._md;
                    },

                    /**
                     * @private
                     */
                    set: function set(val) {
                        this._md = val;
                        this.update();
                    }
                }, {
                    key: "isActive",
                    get: function get() {
                        return this._isActive === undefined || this._isActive === true || this._isActive === 'true';
                    },

                    /**
                     * @private
                     */
                    set: function set(val) {
                        this._isActive = val;
                        this.update();
                    }
                }]);

                return Icon;
            })();

            _export("Icon", Icon);

            _export("Icon", Icon = __decorate([Directive({
                selector: 'ion-icon,icon',
                inputs: ['name', 'ios', 'md', 'isActive'],
                host: {
                    'role': 'img'
                }
            }), __metadata('design:paramtypes', [typeof (_a = typeof Config !== 'undefined' && Config) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof Renderer !== 'undefined' && Renderer) === 'function' && _c || Object])], Icon));
        }
    };
});
System.register('ionic/components/item/item-sliding-gesture', ['../../gestures/hammer', '../../gestures/drag-gesture', '../../util/dom'], function (_export) {
    'use strict';

    var Hammer, DragGesture, CSS, raf, closest, ItemSlidingGesture, DRAG_THRESHOLD;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function isItemActive(ele, isActive) {
        ele.classList[isActive ? 'add' : 'remove']('active-slide');
        ele.classList[isActive ? 'add' : 'remove']('active-options');
    }
    function preventDefault(ev) {
        console.debug('sliding item preventDefault', ev.type);
        ev.preventDefault();
    }
    function getItemConatiner(ele) {
        return closest(ele, 'ion-item-sliding', true);
    }
    function isFromOptionButtons(ele) {
        return !!closest(ele, 'ion-item-options', true);
    }
    function getOptionsWidth(itemContainerEle) {
        var optsEle = itemContainerEle.querySelector('ion-item-options');
        if (optsEle) {
            return optsEle.offsetWidth;
        }
    }
    function isActive(itemContainerEle) {
        return itemContainerEle.classList.contains('active-slide');
    }
    return {
        setters: [function (_gesturesHammer) {
            Hammer = _gesturesHammer.Hammer;
        }, function (_gesturesDragGesture) {
            DragGesture = _gesturesDragGesture.DragGesture;
        }, function (_utilDom) {
            CSS = _utilDom.CSS;
            raf = _utilDom.raf;
            closest = _utilDom.closest;
        }],
        execute: function () {
            ItemSlidingGesture = (function (_DragGesture) {
                _inherits(ItemSlidingGesture, _DragGesture);

                function ItemSlidingGesture(list, listEle) {
                    var _this = this;

                    _classCallCheck(this, ItemSlidingGesture);

                    _get(Object.getPrototypeOf(ItemSlidingGesture.prototype), 'constructor', this).call(this, listEle, {
                        direction: 'x',
                        threshold: DRAG_THRESHOLD
                    });
                    this.data = {};
                    this.openItems = 0;
                    this.list = list;
                    this.listEle = listEle;
                    this.canDrag = true;
                    this.listen();
                    this.tap = function (ev) {
                        if (!isFromOptionButtons(ev.target)) {
                            var didClose = _this.closeOpened();
                            if (didClose) {
                                console.debug('tap close sliding item');
                                preventDefault(ev);
                            }
                        }
                    };
                    this.mouseOut = function (ev) {
                        if (ev.target.tagName === 'ION-ITEM-SLIDING') {
                            console.debug('tap close sliding item');
                            _this.onDragEnd(ev);
                        }
                    };
                }

                _createClass(ItemSlidingGesture, [{
                    key: 'onDragStart',
                    value: function onDragStart(ev) {
                        var itemContainerEle = getItemConatiner(ev.target);
                        if (!itemContainerEle) {
                            console.debug('onDragStart, no itemContainerEle');
                            return;
                        }
                        this.closeOpened(itemContainerEle);
                        var openAmout = this.getOpenAmount(itemContainerEle);
                        var itemData = this.get(itemContainerEle);
                        this.preventDrag = openAmout > 0;
                        if (this.preventDrag) {
                            this.closeOpened();
                            console.debug('onDragStart, preventDefault');
                            return preventDefault(ev);
                        }
                        itemContainerEle.classList.add('active-slide');
                        this.set(itemContainerEle, 'offsetX', openAmout);
                        this.set(itemContainerEle, 'startX', ev.center[this.direction]);
                        this.dragEnded = false;
                    }
                }, {
                    key: 'onDrag',
                    value: function onDrag(ev) {
                        var _this2 = this;

                        if (this.dragEnded || this.preventDrag || Math.abs(ev.deltaY) > 30) {
                            console.debug('onDrag preventDrag, dragEnded:', this.dragEnded, 'preventDrag:', this.preventDrag, 'ev.deltaY:', Math.abs(ev.deltaY));
                            this.preventDrag = true;
                            return;
                        }
                        var itemContainerEle = getItemConatiner(ev.target);
                        if (!itemContainerEle || !isActive(itemContainerEle)) {
                            console.debug('onDrag, no itemContainerEle');
                            return;
                        }
                        var itemData = this.get(itemContainerEle);
                        if (!itemData.optsWidth) {
                            itemData.optsWidth = getOptionsWidth(itemContainerEle);
                            if (!itemData.optsWidth) {
                                console.debug('onDrag, no optsWidth');
                                return;
                            }
                        }
                        var x = ev.center[this.direction];
                        var delta = x - itemData.startX;
                        var newX = Math.max(0, itemData.offsetX - delta);
                        if (newX > itemData.optsWidth) {
                            // Calculate the new X position, capped at the top of the buttons
                            newX = -Math.min(-itemData.optsWidth, -itemData.optsWidth + (delta + itemData.optsWidth) * 0.4);
                        }
                        if (newX > 5 && ev.srcEvent.type.indexOf('mouse') > -1 && !itemData.hasMouseOut) {
                            itemContainerEle.addEventListener('mouseout', this.mouseOut);
                            itemData.hasMouseOut = true;
                        }
                        raf(function () {
                            if (!_this2.dragEnded && !_this2.preventDrag) {
                                isItemActive(itemContainerEle, true);
                                _this2.open(itemContainerEle, newX, false);
                            }
                        });
                    }
                }, {
                    key: 'onDragEnd',
                    value: function onDragEnd(ev) {
                        var _this3 = this;

                        this.preventDrag = false;
                        this.dragEnded = true;
                        var itemContainerEle = getItemConatiner(ev.target);
                        if (!itemContainerEle || !isActive(itemContainerEle)) {
                            console.debug('onDragEnd, no itemContainerEle');
                            return;
                        }
                        // If we are currently dragging, we want to snap back into place
                        // The final resting point X will be the width of the exposed buttons
                        var itemData = this.get(itemContainerEle);
                        var restingPoint = itemData.optsWidth;
                        // Check if the drag didn't clear the buttons mid-point
                        // and we aren't moving fast enough to swipe open
                        if (this.getOpenAmount(itemContainerEle) < restingPoint / 2) {
                            // If we are going left but too slow, or going right, go back to resting
                            if (ev.direction & Hammer.DIRECTION_RIGHT || Math.abs(ev.velocityX) < 0.3) {
                                restingPoint = 0;
                            }
                        }
                        itemContainerEle.removeEventListener('mouseout', this.mouseOut);
                        itemData.hasMouseOut = false;
                        raf(function () {
                            _this3.open(itemContainerEle, restingPoint, true);
                        });
                    }
                }, {
                    key: 'closeOpened',
                    value: function closeOpened(doNotCloseEle) {
                        var didClose = false;
                        if (this.openItems) {
                            var openItemElements = this.listEle.querySelectorAll('.active-slide');
                            for (var i = 0; i < openItemElements.length; i++) {
                                if (openItemElements[i] !== doNotCloseEle) {
                                    this.open(openItemElements[i], 0, true);
                                    didClose = true;
                                }
                            }
                        }
                        return didClose;
                    }
                }, {
                    key: 'open',
                    value: function open(itemContainerEle, openAmount, isFinal) {
                        var _this4 = this;

                        var slidingEle = itemContainerEle.querySelector('ion-item,[ion-item]');
                        if (!slidingEle) {
                            console.debug('open, no slidingEle, openAmount:', openAmount);
                            return;
                        }
                        this.set(itemContainerEle, 'openAmount', openAmount);
                        clearTimeout(this.get(itemContainerEle).timerId);
                        if (openAmount) {
                            this.openItems++;
                        } else {
                            var timerId = setTimeout(function () {
                                if (slidingEle.style[CSS.transform] === '') {
                                    isItemActive(itemContainerEle, false);
                                    _this4.openItems--;
                                }
                            }, 400);
                            this.set(itemContainerEle, 'timerId', timerId);
                        }
                        slidingEle.style[CSS.transition] = isFinal ? '' : 'none';
                        slidingEle.style[CSS.transform] = openAmount ? 'translate3d(' + -openAmount + 'px,0,0)' : '';
                        if (isFinal) {
                            if (openAmount) {
                                isItemActive(itemContainerEle, true);
                                this.on('tap', this.tap);
                            } else {
                                this.off('tap', this.tap);
                            }
                        }
                    }
                }, {
                    key: 'getOpenAmount',
                    value: function getOpenAmount(itemContainerEle) {
                        return this.get(itemContainerEle).openAmount || 0;
                    }
                }, {
                    key: 'get',
                    value: function get(itemContainerEle) {
                        return this.data[itemContainerEle && itemContainerEle.$ionSlide] || {};
                    }
                }, {
                    key: 'set',
                    value: function set(itemContainerEle, key, value) {
                        if (!this.data[itemContainerEle.$ionSlide]) {
                            this.data[itemContainerEle.$ionSlide] = {};
                        }
                        this.data[itemContainerEle.$ionSlide][key] = value;
                    }
                }, {
                    key: 'unlisten',
                    value: function unlisten() {
                        _get(Object.getPrototypeOf(ItemSlidingGesture.prototype), 'unlisten', this).call(this);
                        this.listEle = null;
                    }
                }]);

                return ItemSlidingGesture;
            })(DragGesture);

            _export('ItemSlidingGesture', ItemSlidingGesture);

            DRAG_THRESHOLD = 20;
        }
    };
});
System.register("ionic/components/item/item-sliding", ["angular2/core", "../list/list"], function (_export) {
    /**
     * @name ItemSliding
     *
     * @description
     * Creates a list-item that can easily be swiped, deleted, reordered, edited, and more.
     *
     * @usage
     * ```html
     * <ion-list>
     *   <ion-item-sliding *ngFor="#item of items">
     *     <ion-item (click)="itemTapped(item)">
     *       {{item.title}}
     *     </ion-item>
     *     <ion-item-options>
     *       <button (click)="favorite(item)">Favorite</button>
     *       <button (click)="share(item)">Share</button>
     *     </ion-item-options>
     *   </ion-item-sliding>
     * </ion-list>
     * ```
     * @see {@link /docs/v3/components#lists List Component Docs}
     * @see {@link ../../list/List List API Docs}
     */
    "use strict";

    var Component, ElementRef, Optional, List, __decorate, __metadata, __param, ItemSliding, slideIds, _a, _b;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            ElementRef = _angular2Core.ElementRef;
            Optional = _angular2Core.Optional;
        }, function (_listList) {
            List = _listList.List;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            ItemSliding = (function () {
                function ItemSliding(_list, elementRef) {
                    _classCallCheck(this, ItemSliding);

                    this._list = _list;
                    _list.enableSlidingItems(true);
                    elementRef.nativeElement.$ionSlide = ++slideIds;
                }

                /**
                 * @private
                 */

                _createClass(ItemSliding, [{
                    key: "close",
                    value: function close() {
                        this._list.closeSlidingItems();
                    }
                }]);

                return ItemSliding;
            })();

            _export("ItemSliding", ItemSliding);

            _export("ItemSliding", ItemSliding = __decorate([Component({
                selector: 'ion-item-sliding',
                template: '<ng-content select="ion-item,[ion-item]"></ng-content>' + '<ng-content select="ion-item-options"></ng-content>'
            }), __param(0, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof List !== 'undefined' && List) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object])], ItemSliding));
            slideIds = 0;
        }
    };
});
System.register("ionic/components/item/item", ["angular2/core", "../button/button", "../icon/icon"], function (_export) {
    /**
     * @name Item
     * @description
     * Creates a list-item that can easily be swiped, deleted, reordered, edited, and more.
     *
     * There are three common ways to use an item:
     * - Use `<ion-item>` for something that is only non-clickable text.
     * - Use `<button ion-item>` for something that can be clicked/tapped. Typically this element will also have a `(click)` handler.
     * - Use `<a ion-item>` for when the item needs to contain a `href`.
     *
     * By default, `<button ion-item>` and `<a ion-item>` will receive a right arrow icon on iOS to signal that tapping the item will reveal more information.
     * To hide this icon, add the `detail-none` attribute to the item (eg: `<button ion-item detail-none>`). To add the icon when it is not displayed by default,
     * add the `detail-push` attribute (eg: `<ion-item detail-push>`).
     *
     * To break an item up into multiple columns, add multiple `<ion-item-content>` components inside of the item. By default,
     * this component will automatically be added inside of an `<ion-item>`, giving it a single column.
     *
     *
     * @usage
     * ```html
     *
     * <ion-list>
     *
     *   // default item
     *   <ion-item>
     *     {{item.title}}
     *   </ion-item>
     *
     *   // multiple item-content containers
     *   <ion-item>
     *     <ion-item-content>First Column</ion-item-content>
     *     <ion-item-content>Second Column</ion-item-content>
     *     <ion-item-content>Third Column</ion-item-content>
     *   </ion-item>
     *
     * </ion-list>
     *
     *  ```
     * @see {@link /docs/v3/components#lists List Component Docs}
     * @see {@link ../../list/List List API Docs}
     */
    "use strict";

    var Component, ContentChildren, Button, Icon, __decorate, __metadata, Item;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            ContentChildren = _angular2Core.ContentChildren;
        }, function (_buttonButton) {
            Button = _buttonButton.Button;
        }, function (_iconIcon) {
            Icon = _iconIcon.Icon;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Item = (function () {
                function Item() {
                    _classCallCheck(this, Item);
                }

                _createClass(Item, [{
                    key: "_buttons",
                    set: function set(buttons) {
                        buttons.toArray().forEach(function (button) {
                            if (!button.isItem) {
                                button.addClass('item-button');
                            }
                        });
                    }
                }, {
                    key: "_icons",
                    set: function set(icons) {
                        icons.toArray().forEach(function (icon) {
                            icon.addClass('item-icon');
                        });
                    }
                }]);

                return Item;
            })();

            _export("Item", Item);

            __decorate([ContentChildren(Button), __metadata('design:type', Object), __metadata('design:paramtypes', [Object])], Item.prototype, "_buttons", null);
            __decorate([ContentChildren(Icon), __metadata('design:type', Object), __metadata('design:paramtypes', [Object])], Item.prototype, "_icons", null);
            _export("Item", Item = __decorate([Component({
                selector: 'ion-item,[ion-item]',
                template: '<ng-content select="[item-left]"></ng-content>' + '<div class="item-inner">' + '<ng-content select="ion-item-content,[item-content]"></ng-content>' + '<ion-item-content cnt>' + '<ng-content></ng-content>' + '</ion-item-content>' + '<ng-content select="[item-right]"></ng-content>' + '</div>',
                host: {
                    'class': 'item'
                }
            }), __metadata('design:paramtypes', [])], Item));
        }
    };
});
System.register("ionic/components/label/label", ["angular2/core", "../../util/form"], function (_export) {
    /**
     * @name Label
     * @description
     * Labels describe the data that the user should enter in to an input element.
     * @usage
     * ```html
     * <ion-input>
     *   <ion-label>Username</ion-label>
     *   <input type="text" value="">
     * </ion-input>
     * ```
     *
     * @demo /docs/v3/demos/label/
     * @see {@link ../../../../components#inputs Input Component Docs}
     * @see {@link ../Input Input API Docs}
     *
     */
    "use strict";

    var Directive, ElementRef, Renderer, Form, __decorate, __metadata, Label, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            ElementRef = _angular2Core.ElementRef;
            Renderer = _angular2Core.Renderer;
        }, function (_utilForm) {
            Form = _utilForm.Form;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Label = (function () {
                function Label(_form, _elementRef, _renderer) {
                    _classCallCheck(this, Label);

                    this._form = _form;
                    this._elementRef = _elementRef;
                    this._renderer = _renderer;
                }

                /**
                 * @private
                 */

                _createClass(Label, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        if (!this.id) {
                            this.id = 'lbl-' + this._form.nextId();
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "addClass",
                    value: function addClass(className) {
                        this._renderer.setElementClass(this._elementRef, className, true);
                    }
                }]);

                return Label;
            })();

            _export("Label", Label);

            _export("Label", Label = __decorate([Directive({
                selector: 'ion-label',
                inputs: ['id'],
                host: {
                    '[attr.id]': 'id'
                }
            }), __metadata('design:paramtypes', [typeof (_a = typeof Form !== 'undefined' && Form) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof Renderer !== 'undefined' && Renderer) === 'function' && _c || Object])], Label));
        }
    };
});
System.register("ionic/components/list/list", ["angular2/core", "../ion", "../../config/config", "./virtual", "../item/item-sliding-gesture", "../../util"], function (_export) {
    /**
     * The List is a widely used interface element in almost any mobile app, and can include
     * content ranging from basic text all the way to buttons, toggles, icons, and thumbnails.
     *
     * Both the list, which contains items, and the list items themselves can be any HTML
     * element.
     *
     * Using the List and Item components make it easy to support various
     * interaction modes such as swipe to edit, drag to reorder, and removing items.
     * @demo /docs/v3/demos/list/
     * @see {@link /docs/v3/components#lists List Component Docs}
     *
     *
     */
    "use strict";

    var Directive, ElementRef, Renderer, Attribute, NgZone, Ion, Config, ListVirtualScroll, ItemSlidingGesture, isDefined, __decorate, __metadata, __param, List, ListHeader, _a, _b, _c, _d, _e;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            ElementRef = _angular2Core.ElementRef;
            Renderer = _angular2Core.Renderer;
            Attribute = _angular2Core.Attribute;
            NgZone = _angular2Core.NgZone;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_virtual) {
            ListVirtualScroll = _virtual.ListVirtualScroll;
        }, function (_itemItemSlidingGesture) {
            ItemSlidingGesture = _itemItemSlidingGesture.ItemSlidingGesture;
        }, function (_util) {
            isDefined = _util.isDefined;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            List = (function (_Ion) {
                _inherits(List, _Ion);

                function List(elementRef, config, zone) {
                    _classCallCheck(this, List);

                    _get(Object.getPrototypeOf(List.prototype), "constructor", this).call(this, elementRef, config);
                    this.zone = zone;
                    this.ele = elementRef.nativeElement;
                    this._enableSliding = false;
                }

                /**
                 * @private
                 */

                _createClass(List, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        _get(Object.getPrototypeOf(List.prototype), "ngOnInit", this).call(this);
                        if (isDefined(this.virtual)) {
                            console.log('Content', this.content);
                            console.log('Virtual?', this.virtual);
                            console.log('Items?', this.items.length, 'of \'em');
                            this._initVirtualScrolling();
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "ngOnDestroy",
                    value: function ngOnDestroy() {
                        this.ele = null;
                        this.slidingGesture && this.slidingGesture.unlisten();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_initVirtualScrolling",
                    value: function _initVirtualScrolling() {
                        if (!this.content) {
                            return;
                        }
                        this._virtualScrollingManager = new ListVirtualScroll(this);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setItemTemplate",
                    value: function setItemTemplate(item) {
                        this.itemTemplate = item;
                    }

                    /**
                     * Enable sliding items if your page has them
                     *
                     * ```ts
                     * export class MyClass {
                     *    constructor(app: IonicApp){
                     *      this.app = app;
                     *      this.list = this.app.getComponent('my-list');
                     *    }
                     *    stopSliding(){
                     *      this.list.enableSlidingItems(false);
                     *    }
                     * }
                     * ```
                     * @param {Boolean} shouldEnable whether the item-sliding should be enabled or not
                     */
                }, {
                    key: "enableSlidingItems",
                    value: function enableSlidingItems(shouldEnable) {
                        var _this = this;

                        if (this._enableSliding !== shouldEnable) {
                            this._enableSliding = shouldEnable;
                            if (shouldEnable) {
                                console.debug('enableSlidingItems');
                                this.zone.runOutsideAngular(function () {
                                    setTimeout(function () {
                                        _this.slidingGesture = new ItemSlidingGesture(_this, _this.ele);
                                    });
                                });
                            } else {
                                this.slidingGesture && this.slidingGesture.unlisten();
                            }
                        }
                    }

                    /**
                     * Enable sliding items if your page has
                     *
                     * ```ts
                     * export class MyClass {
                     *    constructor(app: IonicApp){
                     *      this.app = app;
                     *      this.list = this.app.getComponent('my-list');
                     *    }
                     *    // Here we have some method that will close the items
                     *    // when called
                     *    closeItmes(){
                     *      this.list.closeSlidingItems();
                     *    }
                     * }
                     * ```
                     */
                }, {
                    key: "closeSlidingItems",
                    value: function closeSlidingItems() {
                        this.slidingGesture && this.slidingGesture.closeOpened();
                    }
                }]);

                return List;
            })(Ion);

            _export("List", List);

            _export("List", List = __decorate([Directive({
                selector: 'ion-list',
                inputs: ['items', 'virtual', 'content']
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof Config !== 'undefined' && Config) === 'function' && _b || Object, typeof (_c = typeof NgZone !== 'undefined' && NgZone) === 'function' && _c || Object])], List));
            /**
             * @private
             */

            ListHeader = (function () {
                function ListHeader(_renderer, _elementRef, id) {
                    _classCallCheck(this, ListHeader);

                    this._renderer = _renderer;
                    this._elementRef = _elementRef;
                    this._id = id;
                }

                _createClass(ListHeader, [{
                    key: "id",
                    get: function get() {
                        return this._id;
                    },
                    set: function set(val) {
                        this._id = val;
                        this._renderer.setElementAttribute(this._elementRef, 'id', val);
                    }
                }]);

                return ListHeader;
            })();

            _export("ListHeader", ListHeader);

            _export("ListHeader", ListHeader = __decorate([Directive({
                selector: 'ion-list-header'
            }), __param(2, Attribute('id')), __metadata('design:paramtypes', [typeof (_d = typeof Renderer !== 'undefined' && Renderer) === 'function' && _d || Object, typeof (_e = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _e || Object, String])], ListHeader));
        }
    };
});
System.register('ionic/components/list/virtual', [], function (_export) {
    'use strict';

    var ListVirtualScroll, VirtualItemRef;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            ListVirtualScroll = (function () {
                function ListVirtualScroll(list) {
                    var _this = this;

                    _classCallCheck(this, ListVirtualScroll);

                    this.list = list;
                    this.content = this.list.content;
                    this.viewportHeight = this.content.height();
                    this.viewContainer = this.list.itemTemplate.viewContainer;
                    this.itemHeight = 60;
                    this.shownItems = {};
                    this.enteringItems = [];
                    this.leavingItems = [];
                    // Compute the initial sizes
                    setTimeout(function () {
                        _this.resize();
                        // Simulate the first event to start layout
                        _this._handleVirtualScroll({
                            target: _this.content.scrollElement
                        });
                    });
                    this.content.addScrollEventListener(function (event) {
                        _this._handleVirtualScroll(event);
                    });
                }

                _createClass(ListVirtualScroll, [{
                    key: 'resize',
                    value: function resize() {
                        this.viewportHeight = this.content.height();
                        this.viewportScrollHeight = this.content.scrollElement.scrollHeight;
                        this.virtualHeight = this.list.items.length * this.itemHeight;
                        this.itemsPerScreen = this.viewportHeight / this.itemHeight;
                        console.log('VIRTUAL: resize(viewportHeight:', this.viewportHeight, 'viewportScrollHeight:', this.viewportScrollHeight, 'virtualHeight:', this.virtualHeight, ', itemsPerScreen:', this.itemsPerScreen, ')');
                    }
                }, {
                    key: '_handleVirtualScroll',
                    value: function _handleVirtualScroll(event) {
                        var item = undefined;
                        var shownItemRef = undefined;
                        var st = event.target.scrollTop;
                        var sh = event.target.scrollHeight;
                        var topIndex = Math.floor(st / this.itemHeight);
                        var bottomIndex = Math.floor(st / this.itemHeight + this.itemsPerScreen);
                        var items = this.list.items;
                        // Key iterate the shown items map
                        // and compare the index to our index range,
                        // pushing the items to remove to our leaving
                        // list if they're ouside this range.
                        for (var i in this.shownItems) {
                            if (i < topIndex || i > bottomIndex) {
                                this.leavingItems.push(this.shownItems[i]);
                                delete this.shownItems[i];
                            }
                        }
                        var realIndex = 0;
                        // Iterate the set of items that will be rendered, using the
                        // index from the actual items list as the map for the
                        // virtual items we draw
                        for (var i = topIndex, _realIndex = 0; i < bottomIndex && i < items.length; i++, _realIndex++) {
                            item = items[i];
                            console.log('Drawing item', i, item.title);
                            shownItemRef = this.shownItems[i];
                            // Is this a new item?
                            if (!shownItemRef) {
                                var itemView = this.viewContainer.create(this.list.itemTemplate.protoViewRef, _realIndex);
                                itemView.setLocal('\$implicit', item);
                                itemView.setLocal('\$item', item);
                                shownItemRef = new VirtualItemRef(item, i, _realIndex, itemView);
                                this.shownItems[i] = shownItemRef;
                                this.enteringItems.push(shownItemRef);
                            }
                        }
                        while (this.leavingItems.length) {
                            var itemRef = this.leavingItems.pop();
                            console.log('Removing item', itemRef.item, itemRef.realIndex);
                            this.viewContainer.remove(itemRef.realIndex);
                        }
                        console.log('VIRTUAL SCROLL: scroll(scrollTop:', st, 'topIndex:', topIndex, 'bottomIndex:', bottomIndex, ')');
                        console.log('Container has', this.list.getNativeElement().children.length, 'children');
                    }
                }, {
                    key: 'cellAtIndex',
                    value: function cellAtIndex(index) {}
                }]);

                return ListVirtualScroll;
            })();

            _export('ListVirtualScroll', ListVirtualScroll);

            VirtualItemRef = function VirtualItemRef(item, index, realIndex, view) {
                _classCallCheck(this, VirtualItemRef);

                this.item = item;
                this.index = index;
                this.realIndex = realIndex;
                this.view = view;
            };
        }
    };
});
System.register("ionic/components/menu/menu-close", ["angular2/core", "../app/app", "./menu"], function (_export) {
    /**
    * @name MenuClose
    * @description
    * Place `menuClose` on a button to automatically close an open menu. Note that the menu's id must be either
    * `leftMenu` or `rightMenu`
    *
    * @usage
     * ```html
     * <ion-menu [content]="mycontent" id="leftMenu">
     *   <ion-content>
     *     <ion-list>
     *     <ion-item menuClose>Close the menu</ion-item>
     *     </ion-list>
     *   </ion-content>
     * </ion-menu>
     *
     * <ion-nav #mycontent [root]="rootPage"></ion-nav>
     * ```
    * @demo /docs/v3/demos/menu/
    * @see {@link /docs/v3/components#menus Menu Component Docs}
    * @see {@link ../../menu/Menu Menu API Docs}
    */
    "use strict";

    var Directive, IonicApp, Menu, __decorate, __metadata, MenuClose, _a;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_menu) {
            Menu = _menu.Menu;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            MenuClose = (function () {
                function MenuClose(_app) {
                    _classCallCheck(this, MenuClose);

                    this._app = _app;
                }

                /**
                * @private
                */

                _createClass(MenuClose, [{
                    key: "close",
                    value: function close() {
                        var menu = Menu.getById(this._app, this.menuClose);
                        menu && menu.close();
                    }
                }]);

                return MenuClose;
            })();

            _export("MenuClose", MenuClose);

            _export("MenuClose", MenuClose = __decorate([Directive({
                selector: '[menuClose]',
                inputs: ['menuClose'],
                host: {
                    '(click)': 'close()'
                }
            }), __metadata('design:paramtypes', [typeof (_a = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _a || Object])], MenuClose));
        }
    };
});
System.register('ionic/components/menu/menu-gestures', ['../../gestures/slide-edge-gesture', '../../util'], function (_export) {
    'use strict';

    var SlideEdgeGesture, util, MenuContentGesture, TargetGesture, LeftMenuGesture, RightMenuGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_gesturesSlideEdgeGesture) {
            SlideEdgeGesture = _gesturesSlideEdgeGesture.SlideEdgeGesture;
        }, function (_util) {
            util = _util;
        }],
        execute: function () {
            MenuContentGesture = (function (_SlideEdgeGesture) {
                _inherits(MenuContentGesture, _SlideEdgeGesture);

                function MenuContentGesture(menu, targetEl) {
                    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                    _classCallCheck(this, MenuContentGesture);

                    _get(Object.getPrototypeOf(MenuContentGesture.prototype), 'constructor', this).call(this, targetEl, util.extend({
                        direction: menu.side === 'left' || menu.side === 'right' ? 'x' : 'y',
                        edge: menu.side,
                        threshold: 75
                    }, options));
                    this.menu = menu;
                    this.listen();
                }

                /**
                 * Support dragging the target menu as well as the content.
                 */

                _createClass(MenuContentGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        return this.menu.isOpen && this.menu.isEnabled ? true : _get(Object.getPrototypeOf(MenuContentGesture.prototype), 'canStart', this).call(this, ev);
                    }

                    // Set CSS, then wait one frame for it to apply before sliding starts
                }, {
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart(slide, ev) {
                        this.menu.setProgressStart();
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.menu.setProgess(slide.distance / slide.max);
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        var shouldComplete = Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5;
                        this.menu.setProgressEnd(shouldComplete);
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.menu.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.menu.width()
                        };
                    }
                }]);

                return MenuContentGesture;
            })(SlideEdgeGesture);

            _export('MenuContentGesture', MenuContentGesture);

            TargetGesture = (function (_MenuContentGesture) {
                _inherits(TargetGesture, _MenuContentGesture);

                function TargetGesture(menu) {
                    _classCallCheck(this, TargetGesture);

                    _get(Object.getPrototypeOf(TargetGesture.prototype), 'constructor', this).call(this, menu, menu.getNativeElement(), {
                        threshold: 0
                    });
                }

                return TargetGesture;
            })(MenuContentGesture);

            _export('TargetGesture', TargetGesture);

            LeftMenuGesture = (function (_MenuContentGesture2) {
                _inherits(LeftMenuGesture, _MenuContentGesture2);

                function LeftMenuGesture(menu) {
                    _classCallCheck(this, LeftMenuGesture);

                    _get(Object.getPrototypeOf(LeftMenuGesture.prototype), 'constructor', this).call(this, menu, menu.getContentElement());
                }

                return LeftMenuGesture;
            })(MenuContentGesture);

            _export('LeftMenuGesture', LeftMenuGesture);

            RightMenuGesture = (function (_MenuContentGesture3) {
                _inherits(RightMenuGesture, _MenuContentGesture3);

                function RightMenuGesture(menu) {
                    _classCallCheck(this, RightMenuGesture);

                    _get(Object.getPrototypeOf(RightMenuGesture.prototype), 'constructor', this).call(this, menu, menu.getContentElement());
                }

                _createClass(RightMenuGesture, [{
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.menu.setProgess(slide.distance / slide.min);
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.menu.isOpen ? slide.min : slide.max;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.menu.width(),
                            max: 0
                        };
                    }
                }]);

                return RightMenuGesture;
            })(MenuContentGesture);

            _export('RightMenuGesture', RightMenuGesture);
        }
    };
});
System.register("ionic/components/menu/menu-toggle", ["angular2/core", "../app/app", "../nav/view-controller", "../navbar/navbar", "./menu"], function (_export) {
    /**
    * @name MenuToggle
    * @description
    * Toggle a menu by placing this directive on any item.
    * Note that the menu's id must be either `leftMenu` or `rightMenu`
    *
    * @usage
     * ```html
     *<ion-content>
     *  <h3>Page 1</h3>
     *  <button menuToggle>Toggle Menu</button>
     *</ion-content>
     *
     * ```
    * @demo /docs/v3/demos/menu/
    * @see {@link /docs/v3/components#menus Menu Component Docs}
    * @see {@link ../../menu/Menu Menu API Docs}
    */
    "use strict";

    var Directive, ElementRef, Optional, IonicApp, ViewController, Navbar, Menu, __decorate, __metadata, __param, MenuToggle, _a, _b, _c, _d;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            ElementRef = _angular2Core.ElementRef;
            Optional = _angular2Core.Optional;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_navViewController) {
            ViewController = _navViewController.ViewController;
        }, function (_navbarNavbar) {
            Navbar = _navbarNavbar.Navbar;
        }, function (_menu) {
            Menu = _menu.Menu;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            MenuToggle = (function () {
                function MenuToggle(app, elementRef, viewCtrl, navbar) {
                    _classCallCheck(this, MenuToggle);

                    this.app = app;
                    this.viewCtrl = viewCtrl;
                    this.withinNavbar = !!navbar;
                    // Deprecation warning
                    if (this.withinNavbar && elementRef.nativeElement.tagName === 'A') {
                        console.warn('Menu toggles within a navbar should use <button menuToggle> instead of <a menu-toggle>');
                    }
                }

                /**
                * @private
                */

                _createClass(MenuToggle, [{
                    key: "toggle",
                    value: function toggle() {
                        var menu = Menu.getById(this.app, this.menuToggle);
                        menu && menu.toggle();
                    }

                    /**
                    * @private
                    */
                }, {
                    key: "isHidden",
                    get: function get() {
                        if (this.withinNavbar && this.viewCtrl) {
                            return !this.viewCtrl.isRoot();
                        }
                        return false;
                    }
                }]);

                return MenuToggle;
            })();

            _export("MenuToggle", MenuToggle);

            _export("MenuToggle", MenuToggle = __decorate([Directive({
                selector: '[menuToggle]',
                inputs: ['menuToggle'],
                host: {
                    '(click)': 'toggle()',
                    '[hidden]': 'isHidden',
                    'menuToggle': '' //ensures the attr is there for css when using [menuToggle]
                }
            }), __param(2, Optional()), __param(3, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof ViewController !== 'undefined' && ViewController) === 'function' && _c || Object, typeof (_d = typeof Navbar !== 'undefined' && Navbar) === 'function' && _d || Object])], MenuToggle));
        }
    };
});
System.register('ionic/components/menu/menu-types', ['./menu', '../../animations/animation'], function (_export) {
    /**
     * Menu Type
     * Base class which is extended by the various types. Each
     * type will provide their own animations for open and close
     * and registers itself with Menu.
     * @private
     */
    'use strict';

    var Menu, Animation, MenuType, MenuRevealType, MenuPushType, MenuOverlayType, OPACITY, TRANSLATE_X;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_menu) {
            Menu = _menu.Menu;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            MenuType = (function () {
                function MenuType() {
                    _classCallCheck(this, MenuType);

                    this.open = new Animation();
                    this.close = new Animation();
                }

                /**
                 * Menu Reveal Type
                 * The content slides over to reveal the menu underneath.
                 * The menu itself, which is under the content, does not move.
                 */

                _createClass(MenuType, [{
                    key: 'setOpen',
                    value: function setOpen(shouldOpen) {
                        var _this = this;

                        return new Promise(function (resolve) {
                            if (shouldOpen) {
                                _this.open.playbackRate(1).onFinish(resolve, true).play();
                            } else {
                                _this.close.playbackRate(1).onFinish(resolve, true).play();
                            }
                        });
                    }
                }, {
                    key: 'setProgressStart',
                    value: function setProgressStart(isOpen) {
                        this.isOpening = !isOpen;
                        this.seek && this.seek.dispose();
                        // clone the correct animation depending on open/close
                        if (this.isOpening) {
                            this.seek = this.open.clone();
                        } else {
                            this.seek = this.close.clone();
                        }
                        // the cloned animation should not use an easing curve during seek
                        this.seek.easing('linear').progressStart();
                    }
                }, {
                    key: 'setProgess',
                    value: function setProgess(value) {
                        // adjust progress value depending if it opening or closing
                        if (!this.isOpening) {
                            value = 1 - value;
                        }
                        this.seek.progress(value);
                    }
                }, {
                    key: 'setProgressEnd',
                    value: function setProgressEnd(shouldComplete) {
                        var _this2 = this;

                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        var isOpen = this.isOpening && shouldComplete;
                        if (!this.isOpening && !shouldComplete) {
                            isOpen = true;
                        }
                        this.seek.progressEnd(shouldComplete).then(function () {
                            _this2.isOpening = false;
                            resolve(isOpen);
                        });
                        return promise;
                    }
                }, {
                    key: 'ngOnDestroy',
                    value: function ngOnDestroy() {
                        this.open && this.open.dispose();
                        this.close && this.close.dispose();
                        this.seek && this.seek.dispose();
                    }
                }]);

                return MenuType;
            })();

            _export('MenuType', MenuType);

            MenuRevealType = (function (_MenuType) {
                _inherits(MenuRevealType, _MenuType);

                function MenuRevealType(menu) {
                    _classCallCheck(this, MenuRevealType);

                    _get(Object.getPrototypeOf(MenuRevealType.prototype), 'constructor', this).call(this);
                    var easing = 'ease';
                    var duration = 250;
                    var openedX = menu.width() * (menu.side == 'right' ? -1 : 1) + 'px';
                    var closedX = '0px';
                    this.open.easing(easing).duration(duration);
                    this.close.easing(easing).duration(duration);
                    var contentOpen = new Animation(menu.getContentElement());
                    contentOpen.fromTo(TRANSLATE_X, closedX, openedX);
                    this.open.add(contentOpen);
                    var contentClose = new Animation(menu.getContentElement());
                    contentClose.fromTo(TRANSLATE_X, openedX, closedX);
                    this.close.add(contentClose);
                }

                return MenuRevealType;
            })(MenuType);

            Menu.register('reveal', MenuRevealType);
            /**
             * Menu Push Type
             * The content slides over to reveal the menu underneath.
             * The menu itself also slides over to reveal its bad self.
             */

            MenuPushType = (function (_MenuType2) {
                _inherits(MenuPushType, _MenuType2);

                function MenuPushType(menu) {
                    _classCallCheck(this, MenuPushType);

                    _get(Object.getPrototypeOf(MenuPushType.prototype), 'constructor', this).call(this);
                    var easing = 'ease';
                    var duration = 250;
                    var contentOpenedX = undefined,
                        menuClosedX = undefined,
                        menuOpenedX = undefined;
                    if (menu.side == 'right') {
                        contentOpenedX = -menu.width() + 'px';
                        menuOpenedX = menu.platform.width() - menu.width() + 'px';
                        menuClosedX = menu.platform.width() + 'px';
                    } else {
                        contentOpenedX = menu.width() + 'px';
                        menuOpenedX = '0px';
                        menuClosedX = -menu.width() + 'px';
                    }
                    // left side
                    this.open.easing(easing).duration(duration);
                    this.close.easing(easing).duration(duration);
                    var menuOpen = new Animation(menu.getMenuElement());
                    menuOpen.fromTo(TRANSLATE_X, menuClosedX, menuOpenedX);
                    this.open.add(menuOpen);
                    var contentOpen = new Animation(menu.getContentElement());
                    contentOpen.fromTo(TRANSLATE_X, '0px', contentOpenedX);
                    this.open.add(contentOpen);
                    var menuClose = new Animation(menu.getMenuElement());
                    menuClose.fromTo(TRANSLATE_X, menuOpenedX, menuClosedX);
                    this.close.add(menuClose);
                    var contentClose = new Animation(menu.getContentElement());
                    contentClose.fromTo(TRANSLATE_X, contentOpenedX, '0px');
                    this.close.add(contentClose);
                }

                return MenuPushType;
            })(MenuType);

            Menu.register('push', MenuPushType);
            /**
             * Menu Overlay Type
             * The menu slides over the content. The content
             * itself, which is under the menu, does not move.
             */

            MenuOverlayType = (function (_MenuType3) {
                _inherits(MenuOverlayType, _MenuType3);

                function MenuOverlayType(menu) {
                    _classCallCheck(this, MenuOverlayType);

                    _get(Object.getPrototypeOf(MenuOverlayType.prototype), 'constructor', this).call(this);
                    var easing = 'ease';
                    var duration = 250;
                    var backdropOpacity = 0.35;
                    var closedX = undefined,
                        openedX = undefined;
                    if (menu.side == 'right') {
                        // right side
                        closedX = menu.platform.width() + 'px';
                        openedX = menu.platform.width() - menu.width() - 8 + 'px';
                    } else {
                        // left side
                        closedX = -menu.width() + 'px';
                        openedX = '8px';
                    }
                    this.open.easing(easing).duration(duration);
                    this.close.easing(easing).duration(duration);
                    var menuOpen = new Animation(menu.getMenuElement());
                    menuOpen.fromTo(TRANSLATE_X, closedX, openedX);
                    this.open.add(menuOpen);
                    var backdropOpen = new Animation(menu.getBackdropElement());
                    backdropOpen.fromTo(OPACITY, 0.01, backdropOpacity);
                    this.open.add(backdropOpen);
                    var menuClose = new Animation(menu.getMenuElement());
                    menuClose.fromTo(TRANSLATE_X, openedX, closedX);
                    this.close.add(menuClose);
                    var backdropClose = new Animation(menu.getBackdropElement());
                    backdropClose.fromTo(OPACITY, backdropOpacity, 0.01);
                    this.close.add(backdropClose);
                }

                return MenuOverlayType;
            })(MenuType);

            Menu.register('overlay', MenuOverlayType);
            OPACITY = 'opacity';
            TRANSLATE_X = 'translateX';
        }
    };
});
System.register("ionic/components/menu/menu", ["angular2/core", "../ion", "../app/app", "../../config/config", "../../platform/platform", "../../util/keyboard", "./menu-gestures"], function (_export) {
    /**
     * @name Menu
     * @description
     * _For basic Menu usage, see the [Menu section](../../../../components/#menus)
     * of the Component docs._
     *
     * Menu is a side-menu navigation that can be dragged out or toggled to show.
     *
     * @usage
     * In order to use Menu, you must specify a [reference](https://angular.io/docs/ts/latest/guide/user-input.html#local-variables)
     * to the content element that Menu should listen on for drag events, using the `content` property:
     *
     * ```html
     * <ion-menu [content]="mycontent">
     *   <ion-content>
     *     <ion-list>
     *     ...
     *     </ion-list>
     *   </ion-content>
     * </ion-menu>
     *
     * <ion-nav #mycontent [root]="rootPage"></ion-nav>
     * ```
     *
     * By default, Menus are on the left, but this can be overriden with the `side`
     * property:
     * ```html
     * <ion-menu [content]="mycontent" side="right"></ion-menu>
     * ```
     *
     * Menus can optionally be given an `id` attribute which allows the app to
     * to get ahold of menu references. If no `id` is given then the menu
     * automatically receives an `id` created from the side it is on, such as
     * `leftMenu` or `rightMenu`. When using more than one menu it is always
     * recommended to give each menu a unique `id`. Additionally menuToggle and
     * menuClose directives should be given menu id values of their respective
     * menu.
     *
     * Menu supports two display styles: overlay, and reveal. Overlay
     * is the traditional Android drawer style, and Reveal is the traditional iOS
     * style. By default, Menu will adjust to the correct style for the platform,
     * but this can be overriden using the `type` property:
     * ```html
     * <ion-menu [content]="mycontent" type="overlay"></ion-menu>
     * ```
     *
     * To programatically interact with the menu, you first get the menu component.
     *
     * ```ts
     * @Page({
     * `<ion-menu [content]="mycontent" id="leftMenu"></ion-menu>
     * <ion-nav #mycontent [root]="rootPage"></ion-nav>`
     * )}
     * export class MyClass{
     *  constructor(app: IonicApp){
     *    this.app = app;
     *    this.menu;
     *  }
     *
     *  // Wait until the page is ready
     *  ngAfterViewInit(){
     *    this.menu = this.app.getComponent('leftMenu');
     *  }
     *
     *  // Open the menu programatically
     *  openMenu(){
     *    this.menu.open();
     *  }
     *
     * }
     * ```
     *
     * If you want to use any of the APIs down below, make sure to grabe the menu component by it's ID
     *
     * @demo /docs/v3/demos/menu/
     *
     * @see {@link /docs/v3/components#menus Menu Component Docs}
     * @see {@link /docs/v3/components#navigation Navigation Component Docs}
     * @see {@link ../../nav/Nav Nav API Docs}
     *
     */
    "use strict";

    var Component, forwardRef, Directive, Host, EventEmitter, ElementRef, NgZone, Ion, IonicApp, Config, Platform, Keyboard, gestures, __decorate, __metadata, __param, Menu, menuTypes, menuIds, MenuBackdrop, _a, _b, _c, _d, _e, _f, _g;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            forwardRef = _angular2Core.forwardRef;
            Directive = _angular2Core.Directive;
            Host = _angular2Core.Host;
            EventEmitter = _angular2Core.EventEmitter;
            ElementRef = _angular2Core.ElementRef;
            NgZone = _angular2Core.NgZone;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }, function (_utilKeyboard) {
            Keyboard = _utilKeyboard.Keyboard;
        }, function (_menuGestures) {
            gestures = _menuGestures;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Menu = (function (_Ion) {
                _inherits(Menu, _Ion);

                function Menu(elementRef, config, app, platform, keyboard, zone) {
                    _classCallCheck(this, Menu);

                    _get(Object.getPrototypeOf(Menu.prototype), "constructor", this).call(this, elementRef, config);
                    this.app = app;
                    this.platform = platform;
                    this.keyboard = keyboard;
                    this.zone = zone;
                    this.opening = new EventEmitter('opening');
                    this.isOpen = false;
                    this._preventTime = 0;
                    this.isEnabled = true;
                }

                /**
                 * @private
                 */

                _createClass(Menu, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        _get(Object.getPrototypeOf(Menu.prototype), "ngOnInit", this).call(this);
                        var self = this;
                        var content = self.content;
                        self._cntEle = content instanceof Node ? content : content && content.getNativeElement && content.getNativeElement();
                        if (!self._cntEle) {
                            return console.error('Menu: must have a [content] element to listen for drag events on. Example:\n\n<ion-menu [content]="content"></ion-menu>\n\n<ion-nav #content></ion-nav>');
                        }
                        if (self.side !== 'left' && self.side !== 'right') {
                            self.side = 'left';
                        }
                        if (!self.id) {
                            // Auto register
                            self.id = self.side + 'Menu';
                            if (self.app.getComponent(self.id)) {
                                // id already exists, make sure this one is unique
                                self.id += ++menuIds;
                            }
                            self.app.register(self.id, self);
                        }
                        self._initGesture();
                        self._initType(self.type);
                        self._cntEle.classList.add('menu-content');
                        self._cntEle.classList.add('menu-content-' + self.type);
                        self.onContentClick = function (ev) {
                            if (self.isEnabled) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                self.close();
                            }
                        };
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_initGesture",
                    value: function _initGesture() {
                        var _this = this;

                        this.zone.runOutsideAngular(function () {
                            switch (_this.side) {
                                case 'right':
                                    _this._gesture = new gestures.RightMenuGesture(_this);
                                    break;
                                case 'left':
                                    _this._gesture = new gestures.LeftMenuGesture(_this);
                                    break;
                            }
                            _this._targetGesture = new gestures.TargetGesture(_this);
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_initType",
                    value: function _initType(type) {
                        type = type && type.trim().toLowerCase();
                        if (!type) {
                            type = this.config.get('menuType');
                        }
                        this.type = type;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_getType",
                    value: function _getType() {
                        if (!this._type) {
                            this._type = new menuTypes[this.type](this);
                            if (this.config.get('animate') === false) {
                                this._type.open.duration(33);
                                this._type.close.duration(33);
                            }
                        }
                        return this._type;
                    }

                    /**
                     * Sets the state of the Menu to open or not.
                     * @param {boolean} isOpen  If the Menu is open or not.
                     * @return {Promise} returns a promise once set
                     */
                }, {
                    key: "setOpen",
                    value: function setOpen(shouldOpen) {
                        var _this2 = this;

                        // _isPrevented is used to prevent unwanted opening/closing after swiping open/close
                        // or swiping open the menu while pressing down on the menuToggle button
                        if (shouldOpen === this.isOpen || this._isPrevented()) {
                            return Promise.resolve();
                        }
                        this._before();
                        return this._getType().setOpen(shouldOpen).then(function () {
                            _this2._after(shouldOpen);
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setProgressStart",
                    value: function setProgressStart() {
                        // user started swiping the menu open/close
                        if (this._isPrevented() || !this.isEnabled) return;
                        this._before();
                        this._getType().setProgressStart(this.isOpen);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setProgess",
                    value: function setProgess(value) {
                        // user actively dragging the menu
                        if (this.isEnabled) {
                            this._prevent();
                            this._getType().setProgess(value);
                            this.opening.next(value);
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setProgressEnd",
                    value: function setProgressEnd(shouldComplete) {
                        var _this3 = this;

                        // user has finished dragging the menu
                        if (this.isEnabled) {
                            this._prevent();
                            this._getType().setProgressEnd(shouldComplete).then(function (isOpen) {
                                _this3._after(isOpen);
                            });
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_before",
                    value: function _before() {
                        // this places the menu into the correct location before it animates in
                        // this css class doesn't actually kick off any animations
                        if (this.isEnabled) {
                            this.getNativeElement().classList.add('show-menu');
                            this.getBackdropElement().classList.add('show-backdrop');
                            this._prevent();
                            this.keyboard.close();
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_after",
                    value: function _after(isOpen) {
                        // keep opening/closing the menu disabled for a touch more yet
                        // only add listeners/css if it's enabled and isOpen
                        // and only remove listeners/css if it's not open
                        if (this.isEnabled && isOpen || !isOpen) {
                            this._prevent();
                            this.isOpen = isOpen;
                            this._cntEle.classList[isOpen ? 'add' : 'remove']('menu-content-open');
                            this._cntEle.removeEventListener('click', this.onContentClick);
                            if (isOpen) {
                                this._cntEle.addEventListener('click', this.onContentClick);
                            } else {
                                this.getNativeElement().classList.remove('show-menu');
                                this.getBackdropElement().classList.remove('show-backdrop');
                            }
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_prevent",
                    value: function _prevent() {
                        // used to prevent unwanted opening/closing after swiping open/close
                        // or swiping open the menu while pressing down on the menuToggle
                        this._preventTime = Date.now() + 20;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_isPrevented",
                    value: function _isPrevented() {
                        return this._preventTime > Date.now();
                    }

                    /**
                     * Progamatically open the Menu
                     * @return {Promise} returns a promise when the menu is fully opened
                     */
                }, {
                    key: "open",
                    value: function open() {
                        return this.setOpen(true);
                    }

                    /**
                     * Progamatically close the Menu
                     * @return {Promise} returns a promise when the menu is fully closed
                     */
                }, {
                    key: "close",
                    value: function close() {
                        return this.setOpen(false);
                    }

                    /**
                     * Toggle the menu. If it's closed, it will open, and if opened, it will close
                     * @return {Promise} returns a promise when the menu has been toggled
                     */
                }, {
                    key: "toggle",
                    value: function toggle() {
                        return this.setOpen(!this.isOpen);
                    }

                    /**
                     * Used to enable or disable a menu. For example, there could be multiple
                     * left menus, but only one of them should be able to be dragged open.
                     * @param {boolean} shouldEnable  True if it should be enabled, false if not.
                     * @return {Menu}  Returns the instance of the menu, which is useful for chaining.
                     */
                }, {
                    key: "enable",
                    value: function enable(shouldEnable) {
                        this.isEnabled = shouldEnable;
                        if (!shouldEnable) {
                            this.close();
                        }
                        return this;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getMenuElement",
                    value: function getMenuElement() {
                        return this.getNativeElement();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getContentElement",
                    value: function getContentElement() {
                        return this._cntEle;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getBackdropElement",
                    value: function getBackdropElement() {
                        return this.backdrop.elementRef.nativeElement;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "ngOnDestroy",

                    /**
                     * @private
                     */
                    value: function ngOnDestroy() {
                        this.app.unregister(this.id);
                        this._gesture && this._gesture.destroy();
                        this._targetGesture && this._targetGesture.destroy();
                        this._type && this._type.ngOnDestroy();
                        this._cntEle = null;
                    }
                }], [{
                    key: "register",
                    value: function register(name, cls) {
                        menuTypes[name] = cls;
                    }
                }, {
                    key: "getById",
                    value: function getById(app, menuId) {
                        var menu = null;
                        if (menuId) {
                            menu = app.getComponent(menuId);
                            if (!menu) {
                                console.error('Menu with id "' + menuId + '" cannot be found for menuToggle');
                                return;
                            }
                        } else {
                            menu = app.getComponent('leftMenu');
                            if (!menu) {
                                menu = app.getComponent('rightMenu');
                            }
                            if (!menu) {
                                console.error('Menu with id "leftMenu" or "rightMenu" cannot be found for menuToggle');
                                return;
                            }
                        }
                        return menu;
                    }
                }]);

                return Menu;
            })(Ion);

            _export("Menu", Menu);

            _export("Menu", Menu = __decorate([Component({
                selector: 'ion-menu',
                inputs: ['content', 'id', 'side', 'type'],
                defaultInputs: {
                    'side': 'left',
                    'menuType': 'reveal'
                },
                outputs: ['opening'],
                host: {
                    'role': 'navigation',
                    '[attr.side]': 'side',
                    '[attr.type]': 'type'
                },
                template: '<ng-content></ng-content><div tappable disable-activated class="backdrop"></div>',
                directives: [forwardRef(function () {
                    return MenuBackdrop;
                })]
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof Config !== 'undefined' && Config) === 'function' && _b || Object, typeof (_c = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _c || Object, typeof (_d = typeof Platform !== 'undefined' && Platform) === 'function' && _d || Object, typeof (_e = typeof Keyboard !== 'undefined' && Keyboard) === 'function' && _e || Object, typeof (_f = typeof NgZone !== 'undefined' && NgZone) === 'function' && _f || Object])], Menu));
            menuTypes = {};
            menuIds = 0;

            MenuBackdrop = (function () {
                function MenuBackdrop(menu, elementRef) {
                    _classCallCheck(this, MenuBackdrop);

                    this.menu = menu;
                    this.elementRef = elementRef;
                    menu.backdrop = this;
                }

                /**
                 * @private
                 */

                _createClass(MenuBackdrop, [{
                    key: "clicked",
                    value: function clicked(ev) {
                        console.debug('backdrop clicked');
                        ev.preventDefault();
                        ev.stopPropagation();
                        this.menu.close();
                    }
                }]);

                return MenuBackdrop;
            })();

            MenuBackdrop = __decorate([Directive({
                selector: '.backdrop',
                host: {
                    '(click)': 'clicked($event)'
                }
            }), __param(0, Host()), __metadata('design:paramtypes', [Menu, typeof (_g = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _g || Object])], MenuBackdrop);
        }
    };
});
System.register('ionic/components/modal/modal', ['../nav/view-controller', '../../animations/animation'], function (_export) {
    /**
     * @name Modal
     * @description
     * A Modal is a content pane that goes over the user's current page.
     * Usually it is used for making a choice or editing an item. A modal uses the
     * `NavController` to
     * {@link /docs/api/components/nav/NavController/#present present}
     * itself in the root nav stack. It is added to the stack similar to how
     * {@link /docs/api/components/nav/NavController/#push NavController.push}
     * works.
     *
     * When a modal (or any other overlay such as an alert or actionsheet) is
     * "presented" to a nav controller, the overlay is added to the app's root nav.
     * After the modal has been presented, from within the component instance The
     * modal can later be closed or "dimsissed" by using the ViewController's
     * `dismiss` method. Additinoally, you can dismiss any overlay by using `pop`
     * on the root nav controller.
     *
     * A modal can also emit data, which is useful when it is used to add or edit
     * data. For example, a profile page could slide up in a modal, and on submit,
     * the submit button could pass the updated profile data, then dismiss the
     * modal.
     *
     * @usage
     * ```ts
     * import {Modal, NavController} from 'ionic/ionic';
     *
     * @Page(...)
     * class HomePage {
     *
     *  constructor(nav: NavController) {
     *    this.nav = nav;
     *  }
     *
     *  presentContactModal() {
     *    let contactModal = Modal.create(ContactUs);
     *    this.nav.present(contactModal);
     *  }
     *
     *  presentProfileModal() {
     *    let profileModal = Modal.create(Profile, { userId: 8675309 });
     *    profileModal.onDismiss(data => {
     *      console.log(data);
     *    });
     *    this.nav.present(profileModal);
     *  }
     *
     * }
     *
     * @Page(...)
     * class Profile {
     *
     *  constructor(viewCtrl: ViewController) {
     *    this.viewCtrl = viewCtrl;
     *  }
     *
     *  dismiss() {
     *    let data = { 'foo': 'bar' };
     *    this.viewCtrl.dismiss(data);
     *  }
     *
     * }
     * ```
     * @demo /docs/v3/demos/modal/
     * @see {@link /docs/v3/components#modals Modal Component Docs}
     */
    'use strict';

    var ViewController, Animation, Modal, ModalSlideIn, ModalSlideOut, ModalMDSlideIn, ModalMDSlideOut;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_navViewController) {
            ViewController = _navViewController.ViewController;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            Modal = (function (_ViewController) {
                _inherits(Modal, _ViewController);

                function Modal(componentType) {
                    var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, Modal);

                    _get(Object.getPrototypeOf(Modal.prototype), 'constructor', this).call(this, componentType, data);
                    this.viewType = 'modal';
                }

                /**
                 * Animations for modals
                 */

                /**
                * @private
                */

                _createClass(Modal, [{
                    key: 'getTransitionName',
                    value: function getTransitionName(direction) {
                        var key = direction === 'back' ? 'modalLeave' : 'modalEnter';
                        return this._nav && this._nav.config.get(key);
                    }

                    /**
                     * @param {Any} componentType Modal
                     * @param {Object} data Modal options
                     */
                }], [{
                    key: 'create',
                    value: function create(componentType) {
                        var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        return new Modal(componentType, data);
                    }
                }]);

                return Modal;
            })(ViewController);

            _export('Modal', Modal);

            ModalSlideIn = (function (_Animation) {
                _inherits(ModalSlideIn, _Animation);

                function ModalSlideIn(enteringView, leavingView, opts) {
                    _classCallCheck(this, ModalSlideIn);

                    _get(Object.getPrototypeOf(ModalSlideIn.prototype), 'constructor', this).call(this, enteringView.pageRef(), opts);
                    this.easing('cubic-bezier(0.36,0.66,0.04,1)').duration(400).fromTo('translateY', '100%', '0%').before.addClass('show-page');
                    if (enteringView.hasNavbar()) {
                        // entering page has a navbar
                        var enteringNavBar = new Animation(enteringView.navbarRef());
                        enteringNavBar.before.addClass('show-navbar');
                        this.add(enteringNavBar);
                    }
                }

                return ModalSlideIn;
            })(Animation);

            Animation.register('modal-slide-in', ModalSlideIn);

            ModalSlideOut = (function (_Animation2) {
                _inherits(ModalSlideOut, _Animation2);

                function ModalSlideOut(enteringView, leavingView, opts) {
                    _classCallCheck(this, ModalSlideOut);

                    _get(Object.getPrototypeOf(ModalSlideOut.prototype), 'constructor', this).call(this, leavingView.pageRef(), opts);
                    this.easing('ease-out').duration(250).fromTo('translateY', '0%', '100%');
                }

                return ModalSlideOut;
            })(Animation);

            Animation.register('modal-slide-out', ModalSlideOut);

            ModalMDSlideIn = (function (_Animation3) {
                _inherits(ModalMDSlideIn, _Animation3);

                function ModalMDSlideIn(enteringView, leavingView, opts) {
                    _classCallCheck(this, ModalMDSlideIn);

                    _get(Object.getPrototypeOf(ModalMDSlideIn.prototype), 'constructor', this).call(this, enteringView.pageRef(), opts);
                    this.easing('cubic-bezier(0.36,0.66,0.04,1)').duration(280).fromTo('translateY', '40px', '0px').fadeIn().before.addClass('show-page');
                    if (enteringView.hasNavbar()) {
                        // entering page has a navbar
                        var enteringNavBar = new Animation(enteringView.navbarRef());
                        enteringNavBar.before.addClass('show-navbar');
                        this.add(enteringNavBar);
                    }
                }

                return ModalMDSlideIn;
            })(Animation);

            Animation.register('modal-md-slide-in', ModalMDSlideIn);

            ModalMDSlideOut = (function (_Animation4) {
                _inherits(ModalMDSlideOut, _Animation4);

                function ModalMDSlideOut(enteringView, leavingView, opts) {
                    _classCallCheck(this, ModalMDSlideOut);

                    _get(Object.getPrototypeOf(ModalMDSlideOut.prototype), 'constructor', this).call(this, leavingView.pageRef(), opts);
                    this.duration(200).easing('cubic-bezier(0.47,0,0.745,0.715)').fromTo('translateY', '0px', '40px').fadeOut();
                }

                return ModalMDSlideOut;
            })(Animation);

            Animation.register('modal-md-slide-out', ModalMDSlideOut);
        }
    };
});
System.register('ionic/components/nav/nav-controller', ['angular2/core', 'angular2/instrumentation', '../ion', './view-controller', '../../animations/animation', './swipe-back', '../../util/util', '../../util/dom'], function (_export) {
    /**
     * _For examples on the basic usage of NavController, check out the
     * [Navigation section](../../../../components/#navigation) of the Component
     * docs._
     *
     * NavController is the base class for navigation controller components like
     * [`Nav`](../Nav/) and [`Tab`](../../Tabs/Tab/). You use navigation controllers
     * to navigate to [pages](#creating_pages) in your app. At a basic level, a
     * navigation controller is an array of pages representing a particular history
     * (of a Tab for example). This array can be manipulated to navigate throughout
     * an app by pushing and popping pages or inserting and removing them at
     * arbitrary locations in history.
     *
     * The current page is the last one in the array, or the top of the stack if we
     * think of it that way.  [Pushing](#push) a new page onto the top of the
     * navigation stack causes the new page to be animated in, while [popping](#pop)
     * the current page will navigate to the previous page in the stack.
     *
     * Unless you are using a directive like [NavPush](../NavPush/), or need a
     * specific NavController, most times you will inject and use a reference to the
     * nearest NavController to manipulate the navigation stack.
     *
     * <h3 id="injecting_nav_controller">Injecting NavController</h3>
     * Injecting NavController will always get you an instance of the nearest
     * NavController, regardless of whether it is a Tab or a Nav.
     *
     * Behind the scenes, when Ionic instantiates a new NavController, it creates an
     * injector with NavController bound to that instance (usually either a Nav or
     * Tab) and adds the injector to its own providers.  For more information on
     * providers and dependency injection, see [Providers and DI]().
     *
     * Instead, you can inject NavController and know that it is the correct
     * navigation controller for most situations (for more advanced situations, see
     * [Menu](../../Menu/Menu/) and [Tab](../../Tab/Tab/)).
     *
     * ```ts
     *  class MyComponent {
     *    constructor(nav: NavController) {
     *      this.nav = nav;
     *    }
     *  }
     * ```
     *
     * <h2 id="creating_pages">Page creation</h2>
     * _For more information on the `@Page` decorator see the [@Page API
     * reference](../../../decorators/Page/)._
     *
     * Pages are created when they are added to the navigation stack.  For methods
     * like [push()](#push), the NavController takes any component class that is
     * decorated with `@Page` as its first argument.  The NavController then
     * compiles that component, adds it to the app and animates it into view.
     *
     * By default, pages are cached and left in the DOM if they are navigated away
     * from but still in the navigation stack (the exiting page on a `push()` for
     * example).  They are destroyed when removed from the navigation stack (on
     * [pop()](#pop) or [setRoot()](#setRoot)).
     *
     *
     * <h2 id="Lifecycle">Lifecycle events</h2>
     * Lifecycle events are fired during various stages of navigation.  They can be
     * defined in any `@Page` decorated component class.
     *
     * ```ts
     * @Page({
     *   template: 'Hello World'
     * })
     * class HelloWorld {
     *   onPageLoaded() {
     *     console.log("I'm alive!");
     *   }
     *   onPageWillLeave() {
     *     console.log("Looks like I'm about to leave :(");
     *   }
     * }
     * ```
     *
     *
     *
     * - `onPageLoaded` - Runs when the page has loaded. This event only happens once per page being created and added to the DOM. If a page leaves but is cached, then this event will not fire again on a subsequent viewing. The `onPageLoaded` event is good place to put your setup code for the page.
     * - `onPageWillEnter` - Runs when the page is about to enter and become the active page.
     * - `onPageDidEnter` - Runs when the page has fully entered and is now the active page. This event will fire, whether it was the first load or a cached page.
     * - `onPageWillLeave` - Runs when the page is about to leave and no longer be the active page.
     * - `onPageDidLeave` - Runs when the page has finished leaving and is no longer the active page.
     * - `onPageWillUnload` - Runs when the page is about to be destroyed and have its elements removed.
     * - `onPageDidUnload` - Runs after the page has been destroyed and its elements have been removed.
     *
     * @see {@link /docs/v3/components#navigation Navigation Component Docs}
     */
    'use strict';

    var Injector, provide, wtfLeave, wtfCreateScope, wtfStartTimeRange, wtfEndTimeRange, Ion, ViewController, Animation, SwipeBackGesture, isBoolean, array, pascalCaseToDashCase, raf, rafFrames, NavController, ACTIVE_STATE, CACHED_STATE, STAGED_ENTERING_STATE, STAGED_LEAVING_STATE, ctrlIds, NavParams;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x13, _x14, _x15) { var _again = true; _function: while (_again) { var object = _x13, property = _x14, receiver = _x15; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x13 = parent; _x14 = property; _x15 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Injector = _angular2Core.Injector;
            provide = _angular2Core.provide;
        }, function (_angular2Instrumentation) {
            wtfLeave = _angular2Instrumentation.wtfLeave;
            wtfCreateScope = _angular2Instrumentation.wtfCreateScope;
            wtfStartTimeRange = _angular2Instrumentation.wtfStartTimeRange;
            wtfEndTimeRange = _angular2Instrumentation.wtfEndTimeRange;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_viewController) {
            ViewController = _viewController.ViewController;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_swipeBack) {
            SwipeBackGesture = _swipeBack.SwipeBackGesture;
        }, function (_utilUtil) {
            isBoolean = _utilUtil.isBoolean;
            array = _utilUtil.array;
            pascalCaseToDashCase = _utilUtil.pascalCaseToDashCase;
        }, function (_utilDom) {
            raf = _utilDom.raf;
            rafFrames = _utilDom.rafFrames;
        }],
        execute: function () {
            NavController = (function (_Ion) {
                _inherits(NavController, _Ion);

                function NavController(parentnavCtrl, app, config, keyboard, elementRef, anchorName, compiler, viewManager, zone, renderer, cd) {
                    _classCallCheck(this, NavController);

                    _get(Object.getPrototypeOf(NavController.prototype), 'constructor', this).call(this, elementRef, config);
                    this.parent = parentnavCtrl;
                    this.app = app;
                    this.config = config;
                    this.keyboard = keyboard;
                    this._anchorName = anchorName;
                    this._compiler = compiler;
                    this._viewManager = viewManager;
                    this._zone = zone;
                    this._renderer = renderer;
                    this._cd = cd;
                    this._views = [];
                    this._trnsTime = 0;
                    this._trnsDelay = config.get('pageTransitionDelay');
                    this._sbTrans = null;
                    this._sbEnabled = config.get('swipeBackEnabled') || false;
                    this._sbThreshold = config.get('swipeBackThreshold') || 40;
                    this.initZIndex = 10;
                    this.id = ++ctrlIds;
                    this._ids = -1;
                    // build a new injector for child ViewControllers to use
                    this.providers = Injector.resolve([provide(NavController, { useValue: this })]);
                }

                /**
                 * Boolean if the nav controller is actively transitioning or not.
                 * @private
                 * @return {bool}
                 */

                _createClass(NavController, [{
                    key: 'isTransitioning',
                    value: function isTransitioning() {
                        return this._trnsTime > Date.now();
                    }

                    /**
                     * Boolean if the nav controller is actively transitioning or not.
                     * @private
                     * @return {bool}
                     */
                }, {
                    key: 'setTransitioning',
                    value: function setTransitioning(isTransitioning) {
                        var fallback = arguments.length <= 1 || arguments[1] === undefined ? 700 : arguments[1];

                        this._trnsTime = isTransitioning ? Date.now() + fallback : 0;
                    }

                    /**
                     * Push is how we can pass components and navigate to them. We push the component we want to navigate to on to the navigation stack.
                     *
                     * ```typescript
                     * class MyClass{
                     *    constructor(nav:NavController){
                     *      this.nav = nav;
                     *    }
                     *
                     *    pushPage(){
                     *      this.nav.push(SecondView);
                     *    }
                     * }
                     * ```
                     *
                     * We can also pass along parameters to the next view, such as data that we have on the current view. This is a similar concept to to V1 apps with `$stateParams`.
                     *
                     * ```typescript
                     * class MyClass{
                     *    constructor(nav:NavController){
                     *      this.nav = nav;
                     *    }
                     *
                     *    pushPage(user){
                     *      this.nav.push(SecondView,{
                     *       // user is an object we have in our view
                     *       // typically this comes from an ngFor or some array
                     *       // here we can create an object with a property of
                     *       // paramUser, and set it's value to the user object we passed in
                     *       paramUser: user
                     *      });
                     *    }
                     * }
                     * ```
                     *
                     * We'll look at how we can access that data in the `SecondView` in the navParam docs
                     *
                     * We can also pass any options to the transtion from that same method
                     *
                     * ```typescript
                     * class MyClass{
                     *    constructor(nav: NavController){
                     *      this.nav = nav;
                     *    }
                     *
                     *    pushPage(user){
                     *      this.nav.push(SecondView,{
                     *       // user is an object we have in our view
                     *       // typically this comes from an ngFor or some array
                     *       // here we can create an object with a property of
                     *       // paramUser, and set it's value to the user object we passed in
                     *       paramUser: user
                     *      },{
                     *       // here we can configure things like the animations direction or
                     *       // or if the view should animate at all.
                     *       direction: 'back'
                     *      });
                     *    }
                     * }
                     * ```
                     * @param {Any} component The page component class you want to push on to the navigation stack
                     * @param {Object} [params={}] Any nav-params you want to pass along to the next view
                     * @param {Object} [opts={}] Any options you want to use pass to transtion
                     * @returns {Promise} Returns a promise, which resolves when the transition has completed
                     */
                }, {
                    key: 'push',
                    value: function push(componentType, params, opts, callback) {
                        if (params === undefined) params = {};
                        if (opts === undefined) opts = {};

                        if (!componentType) {
                            var errMsg = 'invalid componentType to push';
                            console.error(errMsg);
                            return Promise.reject(errMsg);
                        }
                        if (typeof componentType !== 'function') {
                            throw 'Loading component must be a component class, not "' + componentType.toString() + '"';
                        }
                        if (this.isTransitioning()) {
                            return Promise.reject('nav controller actively transitioning');
                        }
                        this.setTransitioning(true, 500);
                        var promise = null;
                        if (!callback) {
                            promise = new Promise(function (res) {
                                callback = res;
                            });
                        }
                        // do not animate if this is the first in the stack
                        if (!this._views.length && !opts.animateFirst) {
                            opts.animate = false;
                        }
                        // the active view is going to be the leaving one (if one exists)
                        var leavingView = this.getActive() || new ViewController();
                        leavingView.shouldCache = isBoolean(opts.cacheLeavingView) ? opts.cacheLeavingView : true;
                        leavingView.shouldDestroy = !leavingView.shouldCache;
                        if (leavingView.shouldDestroy) {
                            leavingView.willUnload();
                        }
                        // create a new ViewController
                        var enteringView = new ViewController(componentType, params);
                        enteringView.setNav(this);
                        // default the direction to "forward"
                        opts.direction = opts.direction || 'forward';
                        if (!opts.animation) {
                            opts.animation = enteringView.getTransitionName(opts.direction);
                        }
                        // add the view to the stack
                        this._add(enteringView);
                        if (this.router) {
                            // notify router of the state change
                            this.router.stateChange('push', enteringView, params);
                        }
                        // start the transition
                        this._transition(enteringView, leavingView, opts, callback);
                        return promise;
                    }

                    /**
                     * Present is how we display overlays on top of the content, from within the
                     * root level `NavController`. The `present` method is used by overlays, such
                     * as `ActionSheet`, `Alert`, and `Modal`. The main difference between `push`
                     * and `present`, is that `present` takes a `ViewController` instance, whereas
                     * `push` takes a `Page` component class. Additionally, `present` will place
                     * the overlay in the root NavController's stack.
                     *
                     * ```typescript
                     * class MyClass{
                     *    constructor(nav: NavController) {
                     *      this.nav = nav;
                     *    }
                     *
                     *    presentModal() {
                     *      let modal = Modal.create(ProfilePage);
                     *      this.nav.present(modal);
                     *    }
                     * }
                     * ```
                     *
                     * @param {ViewController} enteringView The name of the component you want to push on the navigation stack
                     * @param {Object} [opts={}] Any options you want to use pass to transtion
                     * @returns {Promise} Returns a promise, which resolves when the transition has completed
                     */
                }, {
                    key: 'present',
                    value: function present(enteringView) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        var rootNav = this.rootNav;
                        enteringView.setNav(rootNav);
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        opts.keyboardClose = false;
                        opts.skipCache = true;
                        opts.direction = 'forward';
                        if (!opts.animation) {
                            opts.animation = enteringView.getTransitionName('forward');
                        }
                        enteringView.setLeavingOpts({
                            keyboardClose: false,
                            skipCache: true,
                            direction: 'back',
                            animation: enteringView.getTransitionName('back')
                        });
                        // the active view is going to be the leaving one (if one exists)
                        var leavingView = rootNav.getActive() || new ViewController();
                        leavingView.shouldCache = isBoolean(opts.cacheLeavingView) ? opts.cacheLeavingView : true;
                        leavingView.shouldDestroy = !leavingView.shouldCache;
                        if (leavingView.shouldDestroy) {
                            leavingView.willUnload();
                        }
                        // add the view to the stack
                        rootNav._add(enteringView);
                        // start the transition
                        rootNav._transition(enteringView, leavingView, opts, resolve);
                        return promise;
                    }

                    /**
                     * If you wanted to navigate back from a current view, you can use the back-button or programatically call `pop()`
                     * Similar to `push()`, you can pass animation options.
                     *
                     * ```typescript
                     * class SecondView{
                     *    constructor(nav:NavController){
                     *      this.nav = nav;
                     *    }
                     *    goBack(){
                     *      this.nav.pop();
                     *    }
                     * }
                     * ```
                     *
                     * @param {Object} [opts={}] Any options you want to use pass to transtion
                     * @returns {Promise} Returns a promise when the transition is completed
                     */
                }, {
                    key: 'pop',
                    value: function pop() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        if (!opts.animateFirst && !this.canGoBack()) {
                            return Promise.reject('pop cannot go back');
                        }
                        if (this.isTransitioning()) {
                            return Promise.reject('nav controller actively transitioning');
                        }
                        this.setTransitioning(true, 500);
                        var resolve = null;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // get the active view and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingView = this.getActive() || new ViewController();
                        leavingView.shouldCache = isBoolean(opts.cacheLeavingView) ? opts.cacheLeavingView : false;
                        leavingView.shouldDestroy = !leavingView.shouldCache;
                        if (leavingView.shouldDestroy) {
                            leavingView.willUnload();
                        }
                        // the entering view is now the new last view
                        // Note: we might not have an entering view if this is the
                        // only view on the history stack.
                        var enteringView = this.getPrevious(leavingView);
                        if (this.router) {
                            // notify router of the state change
                            this.router.stateChange('pop', enteringView);
                        }
                        // default the direction to "back"
                        opts.direction = opts.direction || 'back';
                        if (!opts.animation) {
                            opts.animation = leavingView.getTransitionName(opts.direction);
                        }
                        // start the transition
                        this._transition(enteringView, leavingView, opts, resolve);
                        return promise;
                    }

                    /**
                     * @private
                     * Pop to a specific view in the history stack
                     * @param view {ViewController} to pop to
                     * @param {Object} [opts={}] Any options you want to use pass to transtion
                     */
                }, {
                    key: 'popTo',
                    value: function popTo(viewCtrl) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        // Get the target index of the view to pop to
                        var viewIndex = this._views.indexOf(viewCtrl);
                        var targetIndex = viewIndex + 1;
                        // Don't pop to the view if it wasn't found, or the target is beyond the view list
                        if (viewIndex < 0 || targetIndex > this._views.length - 1) {
                            return Promise.resolve();
                        }
                        // ensure the entering view is shown
                        this._cachePage(viewCtrl, true);
                        var resolve = null;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        opts.direction = opts.direction || 'back';
                        if (!opts.animation) {
                            opts.animation = viewCtrl.getTransitionName(opts.direction);
                        }
                        var leavingView = this.getActive() || new ViewController();
                        // get the views to auto remove without having to do a transiton for each
                        // the last view (the currently active one) will do a normal transition out
                        if (this._views.length > 1) {
                            var autoRemoveItems = this._views.slice(targetIndex, this._views.length);
                            var popView = undefined;
                            for (var i = 0; i < autoRemoveItems.length; i++) {
                                popView = autoRemoveItems[i];
                                popView.shouldDestroy = true;
                                popView.shouldCache = false;
                                popView.willUnload();
                                // only the leaving view should be shown, all others hide
                                this._cachePage(popView, popView === leavingView);
                            }
                        }
                        if (this.router) {
                            this.router.stateChange('pop', viewCtrl);
                        }
                        this._transition(viewCtrl, leavingView, opts, resolve);
                        return promise;
                    }

                    /**
                     * Similar to `pop()`, this method let's you navigate back to the root of the stack, no matter how many views that is
                     * @param {Object} [opts={}] Any options you want to use pass to transtion
                     */
                }, {
                    key: 'popToRoot',
                    value: function popToRoot() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        return this.popTo(this.first(), opts);
                    }

                    /**
                     * Inserts a view into the nav stack at the specified index.
                     * This is useful if you need to add a view at any point in your navigation stack
                     *
                     * ```typescript
                     * export class Detail {
                     *    constructor(nav: NavController) {
                     *      this.nav = nav;
                     *    }
                     *    insertView(){
                     *      this.nav.insert(1,Info)
                     *    }
                     *  }
                     * ```
                     *
                     * This will insert the `Info` view into the second slot of our navigation stack
                     *
                     * @param {Number} index The index where you want to insert the view
                     * @param {Any} component The name of the component you want to insert into the nav stack
                     * @returns {Promise} Returns a promise when the view has been inserted into the navigation stack
                     */
                }, {
                    key: 'insert',
                    value: function insert(index, componentType) {
                        var params = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
                        var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

                        if (!componentType || index < 0) {
                            return Promise.reject('invalid insert');
                        }
                        // push it onto the end
                        if (index >= this._views.length) {
                            return this.push(componentType, params, opts);
                        }
                        // create new ViewController, but don't render yet
                        var viewCtrl = new ViewController(componentType, params);
                        viewCtrl.setNav(this);
                        viewCtrl.state = CACHED_STATE;
                        viewCtrl.shouldDestroy = false;
                        viewCtrl.shouldCache = false;
                        this._incId(viewCtrl);
                        this._views.splice(index, 0, viewCtrl);
                        this._cleanup();
                        return Promise.resolve();
                    }

                    /**
                     * Removes a view from the nav stack at the specified index.
                     *
                     * ```typescript
                     * export class Detail {
                     *    constructor(nav: NavController) {
                     *      this.nav = nav;
                     *    }
                     *    removeView(){
                     *      this.nav.remove(1)
                     *    }
                     *  }
                     * ```
                     *
                     * @param {Number} index Remove the view from the nav stack at that index
                     * @param {Object} [opts={}] Any options you want to use pass to transtion
                     * @returns {Promise} Returns a promise when the view has been removed
                     */
                }, {
                    key: 'remove',
                    value: function remove(index) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        if (index < 0 || index >= this._views.length) {
                            return Promise.reject("index out of range");
                        }
                        var viewToRemove = this._views[index];
                        if (this.isActive(viewToRemove)) {
                            return this.pop(opts);
                        }
                        viewToRemove.shouldDestroy = true;
                        this._cleanup();
                        return Promise.resolve();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'setViews',
                    value: function setViews(components) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        console.warn('setViews() deprecated, use setPages() instead');
                        return this.setPages(components, opts);
                    }

                    /**
                     * You can set the views of the current navigation stack and navigate to the last view past
                     *
                     *
                     *```typescript
                     * import {Page, NavController} from 'ionic/ionic'
                     * import {Detail} from '../detail/detail'
                     * import {Info} from '../info/info'
                     *
                     *  export class Home {
                     *    constructor(nav: NavController) {
                     *      this.nav = nav;
                     *    }
                     *    setPages() {
                     *      this.nav.setPages([List,Detail, Info]);
                     *    }
                     *  }
                     *```
                     *
                     *
                     *In this example, we're giving the current nav stack an array of pages. Then the navigation stack will navigate to the last view in the array and remove the orignal view you came from.
                     *
                     *By default, animations are disabled, but they can be enabled by passing options to the navigation controller
                     *
                     *
                     *```typescript
                     * import {Page, NavController} from 'ionic/ionic'
                     * import {Detail} from '../detail/detail'
                     * import {Info} from '../info/info'
                     *
                     *  export class Home {
                     *    constructor(nav: NavController) {
                     *      this.nav = nav;
                     *    }
                     *    setPages() {
                     *      this.nav.setPages([List,Detail, Info],{
                     *        animate: true
                     *      });
                     *    }
                     *  }
                     *```
                     *
                     *
                     *You can also pass any navigation params to the individual pages in the array.
                     *
                     *
                     *```typescript
                     * import {Page, NavController} from 'ionic/ionic'
                     * import {Detail} from '../detail/detail'
                     * import {Info} from '../info/info'
                     *
                     *  export class Home {
                     *    constructor(nav: NavController) {
                     *      this.nav = nav;
                     *    }
                     *    setPages() {
                     *      this.nav.setPages([{
                     *        componentType: List,
                     *        params: {id: 43}
                     *      }, {
                     *        componentType: Detail,
                     *        params: {id: 45}
                     *      },{
                     *        componentType: Info,
                     *        params: {id: 5}
                     *      }]);
                     *    }
                     *  }
                     *```
                     *
                     * @param {Array} component an arry of components to load in the stack
                     * @param {Object} [opts={}] Any options you want to use pass
                     * @returns {Promise} Returns a promise when the pages are set
                     */
                }, {
                    key: 'setPages',
                    value: function setPages(components) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        if (!components || !components.length) {
                            return Promise.resolve();
                        }
                        var leavingView = this.getActive() || new ViewController();
                        // if animate has not been set then default to false
                        opts.animate = opts.animate || false;
                        // ensure leaving views are not cached, and should be destroyed
                        opts.cacheLeavingView = false;
                        // get the views to auto remove without having to do a transiton for each
                        // the last view (the currently active one) will do a normal transition out
                        if (this._views.length > 1) {
                            var autoRemoveItems = this._views.slice(0, this._views.length - 1);
                            var popView = undefined;
                            for (var i = 0; i < autoRemoveItems.length; i++) {
                                popView = autoRemoveItems[i];
                                popView.shouldDestroy = true;
                                popView.shouldCache = false;
                                popView.willUnload();
                                if (opts.animate) {
                                    // only the leaving view should be shown, all others hide
                                    this._cachePage(popView, popView === leavingView);
                                }
                            }
                        }
                        var componentObj = null;
                        var componentType = null;
                        var viewCtrl = null;
                        // create the ViewControllers that go before the new active ViewController
                        // in the stack, but the previous views shouldn't render yet
                        if (components.length > 1) {
                            var newBeforeItems = components.slice(0, components.length - 1);
                            for (var j = 0; j < newBeforeItems.length; j++) {
                                componentObj = newBeforeItems[j];
                                if (componentObj) {
                                    // could be an object with a componentType property, or it is a componentType
                                    componentType = componentObj.componentType || componentObj;
                                    viewCtrl = new ViewController(componentType, componentObj.params);
                                    viewCtrl.setNav(this);
                                    viewCtrl.state = CACHED_STATE;
                                    viewCtrl.shouldDestroy = false;
                                    viewCtrl.shouldCache = false;
                                    // add the item to the stack
                                    this._add(viewCtrl);
                                }
                            }
                        }
                        // get the component that will become the active item
                        // it'll be the last one in the given components array
                        componentObj = components[components.length - 1];
                        componentType = componentObj.componentType || componentObj;
                        // transition the leaving and entering
                        return this.push(componentType, componentObj.params, opts);
                    }

                    /**
                     * Set the root for the current navigation stack
                     * @param {Component} The name of the component you want to push on the navigation stack
                     * @param {Object} [params={}] Any nav-params you want to pass along to the next view
                     * @param {Object} [opts={}] Any options you want to use pass to transtion
                     * @returns {Promise} Returns a promise when done
                     */
                }, {
                    key: 'setRoot',
                    value: function setRoot(componentType) {
                        var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return this.setPages([{
                            componentType: componentType,
                            params: params
                        }], opts);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_transition',
                    value: function _transition(enteringView, leavingView, opts, done) {
                        if (enteringView === leavingView) {
                            // if the entering view and leaving view are the same thing don't continue
                            return done(enteringView);
                        }
                        if (this.config.get('animate') === false) {
                            opts.animate = false;
                        }
                        if (!enteringView) {
                            // if no entering view then create a bogus one
                            // already consider this bogus one loaded
                            enteringView = new ViewController();
                            enteringView.loaded();
                        }
                        var wtfScope = wtfStartTimeRange('ionic.NavController#_transition ' + enteringView.name);
                        /* Async steps to complete a transition
                          1. _render: compile the view and render it in the DOM. Load page if it hasn't loaded already. When done call postRender
                          2. _postRender: Run willEnter/willLeave, then wait a frame (change detection happens), then call beginTransition
                          3. _beforeTrans: Create the transition's animation, play the animation, wait for it to end
                          4. _afterTrans: Run didEnter/didLeave, call _transComplete()
                          5. _transComplete: Cleanup, remove cache views, then call the final callback
                        */
                        // begin the multiple async process of transitioning to the entering view
                        this._render(enteringView, leavingView, opts, function () {
                            wtfEndTimeRange(wtfScope);
                            done(enteringView);
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_render',
                    value: function _render(enteringView, leavingView, opts, done) {
                        var _this = this;

                        // compile/load the view into the DOM
                        if (enteringView.shouldDestroy) {
                            // about to be destroyed, shouldn't continue
                            done();
                        } else if (enteringView.isLoaded()) {
                            // already compiled this view, do not load again and continue
                            this._postRender(enteringView, leavingView, opts, done);
                        } else {
                            // view has not been compiled/loaded yet
                            // continue once the view has finished compiling
                            // DOM WRITE
                            this.loadPage(enteringView, null, opts, function () {
                                if (enteringView.onReady) {
                                    // this entering view needs to wait for it to be ready
                                    // this is used by Tabs to wait for the first page of
                                    // the first selected tab to be loaded
                                    enteringView.onReady(function () {
                                        enteringView.loaded();
                                        _this._postRender(enteringView, leavingView, opts, done);
                                    });
                                } else {
                                    enteringView.loaded();
                                    _this._postRender(enteringView, leavingView, opts, done);
                                }
                            });
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_postRender',
                    value: function _postRender(enteringView, leavingView, opts, done) {
                        var _this2 = this;

                        var wtfScope = wtfStartTimeRange('ionic.NavController#_postRender ' + enteringView.name);
                        // called after _render has completed and the view is compiled/loaded
                        if (enteringView.shouldDestroy) {
                            // view already marked as a view that will be destroyed, don't continue
                            wtfEndTimeRange(wtfScope);
                            done();
                        } else if (!opts.preload) {
                            // the enteringView will become the active view, and is not being preloaded
                            // call each view's lifecycle events
                            // POSSIBLE DOM READ THEN DOM WRITE
                            enteringView.willEnter();
                            leavingView.willLeave();
                            // set the correct zIndex for the entering and leaving views
                            // DOM WRITE
                            this._setZIndex(enteringView, leavingView, opts.direction);
                            // make sure the entering and leaving views are showing
                            // and all others are hidden, but don't remove the leaving view yet
                            // DOM WRITE
                            this._cleanup(enteringView, leavingView, true, opts.skipCache);
                            // lifecycle events may have updated some data
                            // wait one frame and allow the raf to do a change detection
                            // before kicking off the transition and showing the new view
                            raf(function () {
                                wtfEndTimeRange(wtfScope);
                                _this2._beforeTrans(enteringView, leavingView, opts, done);
                            });
                        } else {
                            // this view is being preloaded, don't call lifecycle events
                            // transition does not need to animate
                            opts.animate = false;
                            wtfEndTimeRange(wtfScope);
                            this._beforeTrans(enteringView, leavingView, opts, done);
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_beforeTrans',
                    value: function _beforeTrans(enteringView, leavingView, opts, done) {
                        var _this3 = this;

                        var wtfScope = wtfStartTimeRange('ionic.NavController#_beforeTrans ' + enteringView.name);
                        // called after one raf from postRender()
                        // create the transitions animation, play the animation
                        // when the transition ends call wait for it to end
                        // everything during the transition should runOutsideAngular
                        this._zone.runOutsideAngular(function () {
                            // ensure the entering view is not destroyed or cached
                            enteringView.shouldDestroy = false;
                            enteringView.shouldCache = false;
                            // set that the new view pushed on the stack is staged to be entering/leaving
                            // staged state is important for the transition to find the correct view
                            enteringView.state = STAGED_ENTERING_STATE;
                            leavingView.state = STAGED_LEAVING_STATE;
                            // init the transition animation
                            opts.renderDelay = opts.transitionDelay || self._trnsDelay;
                            // set if this app is right-to-left or not
                            opts.isRTL = _this3.config.platform.isRTL();
                            var transAnimation = Animation.createTransition(enteringView, leavingView, opts);
                            if (opts.animate === false) {
                                // force it to not animate the elements, just apply the "to" styles
                                transAnimation.clearDuration();
                                transAnimation.duration(0);
                            }
                            var duration = transAnimation.duration();
                            var enableApp = duration < 64;
                            // block any clicks during the transition and provide a
                            // fallback to remove the clickblock if something goes wrong
                            _this3.app.setEnabled(enableApp, duration);
                            _this3.setTransitioning(!enableApp, duration);
                            if (enteringView.viewType) {
                                transAnimation.before.addClass(enteringView.viewType);
                            }
                            wtfEndTimeRange(wtfScope);
                            // start the transition
                            transAnimation.play(function () {
                                // transition animation has ended
                                // dispose the animation and it's element references
                                transAnimation.dispose();
                                _this3._afterTrans(enteringView, leavingView, opts, done);
                            });
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_afterTrans',
                    value: function _afterTrans(enteringView, leavingView, opts, done) {
                        var _this4 = this;

                        var wtfScope = wtfStartTimeRange('ionic.NavController#_afterTrans ' + enteringView.name);
                        // transition has completed, update each view's state
                        // place back into the zone, run didEnter/didLeave
                        // call the final callback when done
                        enteringView.state = ACTIVE_STATE;
                        leavingView.state = CACHED_STATE;
                        // run inside of the zone again
                        this._zone.run(function () {
                            if (!opts.preload) {
                                enteringView.didEnter();
                                leavingView.didLeave();
                            }
                            if (opts.keyboardClose !== false && _this4.keyboard.isOpen()) {
                                // the keyboard is still open!
                                // no problem, let's just close for them
                                _this4.keyboard.close();
                                _this4.keyboard.onClose(function () {
                                    // keyboard has finished closing, transition complete
                                    _this4._transComplete();
                                    wtfEndTimeRange(wtfScope);
                                    done();
                                }, 32);
                            } else {
                                // all good, transition complete
                                _this4._transComplete();
                                wtfEndTimeRange(wtfScope);
                                done();
                            }
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_transComplete',
                    value: function _transComplete() {
                        var wtfScope = wtfCreateScope('ionic.NavController#_transComplete')();
                        this._views.forEach(function (view) {
                            if (view) {
                                if (view.shouldDestroy) {
                                    view.didUnload();
                                } else if (view.state === CACHED_STATE && view.shouldCache) {
                                    view.shouldCache = false;
                                }
                            }
                        });
                        // allow clicks again, but still set an enable time
                        // meaning nothing with this view controller can happen for XXms
                        this.app.setEnabled(true);
                        this.setTransitioning(false);
                        this._sbComplete();
                        this._cleanup();
                        wtfLeave(wtfScope);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'loadPage',
                    value: function loadPage(viewCtrl, navbarContainerRef, opts, done) {
                        var _this5 = this;

                        var wtfTimeRangeScope = wtfStartTimeRange('ionic.NavController#loadPage ' + viewCtrl.name);
                        // guts of DynamicComponentLoader#loadIntoLocation
                        this._compiler.compileInHost(viewCtrl.componentType).then(function (hostProtoViewRef) {
                            var wtfScope = wtfCreateScope('ionic.NavController#loadPage_After_Compile')();
                            var providers = _this5.providers.concat(Injector.resolve([provide(ViewController, { useValue: viewCtrl }), provide(NavParams, { useValue: viewCtrl.getNavParams() })]));
                            var location = _this5.elementRef;
                            if (_this5._anchorName) {
                                location = _this5._viewManager.getNamedElementInComponentView(location, _this5._anchorName);
                            }
                            var viewContainer = _this5._viewManager.getViewContainer(location);
                            var hostViewRef = viewContainer.createHostView(hostProtoViewRef, viewContainer.length, providers);
                            var pageElementRef = _this5._viewManager.getHostElement(hostViewRef);
                            var component = _this5._viewManager.getComponent(pageElementRef);
                            // auto-add page css className created from component JS class name
                            var cssClassName = pascalCaseToDashCase(viewCtrl.componentType.name);
                            _this5._renderer.setElementClass(pageElementRef, cssClassName, true);
                            viewCtrl.addDestroy(function () {
                                // ensure the element is cleaned up for when the view pool reuses this element
                                _this5._renderer.setElementAttribute(pageElementRef, 'class', null);
                                _this5._renderer.setElementAttribute(pageElementRef, 'style', null);
                                // remove the page from its container
                                var index = viewContainer.indexOf(hostViewRef);
                                if (index !== -1) {
                                    viewContainer.remove(index);
                                }
                            });
                            // a new ComponentRef has been created
                            // set the ComponentRef's instance to this ViewController
                            viewCtrl.setInstance(component);
                            // remember the ElementRef to the ion-page elementRef that was just created
                            viewCtrl.setPageRef(pageElementRef);
                            if (!navbarContainerRef) {
                                navbarContainerRef = viewCtrl.getNavbarViewRef();
                            }
                            var navbarTemplateRef = viewCtrl.getNavbarTemplateRef();
                            if (navbarContainerRef && navbarTemplateRef) {
                                (function () {
                                    var navbarView = navbarContainerRef.createEmbeddedView(navbarTemplateRef);
                                    viewCtrl.addDestroy(function () {
                                        var index = navbarContainerRef.indexOf(navbarView);
                                        if (index > -1) {
                                            navbarContainerRef.remove(index);
                                        }
                                    });
                                })();
                            }
                            opts.postLoad && opts.postLoad(viewCtrl);
                            if (_this5._views.length === 1) {
                                _this5._zone.runOutsideAngular(function () {
                                    rafFrames(38, function () {
                                        _this5._renderer.setElementClass(_this5.elementRef, 'has-views', true);
                                    });
                                });
                            }
                            wtfEndTimeRange(wtfTimeRangeScope);
                            wtfLeave(wtfScope);
                            done(viewCtrl);
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_setZIndex',
                    value: function _setZIndex(enteringView, leavingView, direction) {
                        var enteringPageRef = enteringView && enteringView.pageRef();
                        if (enteringPageRef) {
                            if (!leavingView || !leavingView.isLoaded()) {
                                enteringView.zIndex = this.initZIndex;
                            } else if (direction === 'back') {
                                // moving back
                                enteringView.zIndex = leavingView.zIndex - 1;
                            } else {
                                // moving forward
                                enteringView.zIndex = leavingView.zIndex + 1;
                            }
                            if (enteringView.zIndex !== enteringView._zIndex) {
                                this._renderer.setElementStyle(enteringPageRef, 'z-index', enteringView.zIndex);
                                enteringView._zIndex = enteringView.zIndex;
                            }
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_cachePage',
                    value: function _cachePage(viewCtrl, shouldShow) {
                        // using hidden element attribute to display:none and not render views
                        // renderAttr of '' means the hidden attribute will be added
                        // renderAttr of null means the hidden attribute will be removed
                        // doing checks to make sure we only make an update to the element when needed
                        if (shouldShow && viewCtrl._hdnAttr === '' || !shouldShow && viewCtrl._hdnAttr !== '') {
                            viewCtrl._hdnAttr = shouldShow ? null : '';
                            this._renderer.setElementAttribute(viewCtrl.pageRef(), 'hidden', viewCtrl._hdnAttr);
                            var navbarRef = viewCtrl.navbarRef();
                            if (navbarRef) {
                                this._renderer.setElementAttribute(navbarRef, 'hidden', viewCtrl._hdnAttr);
                            }
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_cleanup',
                    value: function _cleanup(activeView, previousView, skipDestroy, skipCache) {
                        var _this6 = this;

                        // the active page, and the previous page, should be rendered in dom and ready to go
                        // all others, like a cached page 2 back, should be display: none and not rendered
                        var destroys = [];
                        activeView = activeView || this.getActive();
                        previousView = previousView || this.getPrevious(activeView);
                        this._views.forEach(function (view) {
                            if (view) {
                                if (view.shouldDestroy && !skipDestroy) {
                                    destroys.push(view);
                                } else if (view.isLoaded() && !skipCache) {
                                    var shouldShow = view === activeView || view === previousView;
                                    _this6._cachePage(view, shouldShow);
                                }
                            }
                        });
                        // all pages being destroyed should be removed from the list of pages
                        // and completely removed from the dom
                        destroys.forEach(function (view) {
                            _this6._remove(view);
                            view.destroy();
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'swipeBackStart',
                    value: function swipeBackStart() {
                        var _this7 = this;

                        return;
                        if (!this.app.isEnabled() || !this.canSwipeBack()) {
                            return;
                        }
                        // disables the app during the transition
                        this.app.setEnabled(false);
                        this.setTransitioning(true);
                        // default the direction to "back"
                        var opts = {
                            direction: 'back'
                        };
                        // get the active view and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingView = this.getActive() || new ViewController();
                        leavingView.shouldDestroy = true;
                        leavingView.shouldCache = false;
                        leavingView.willLeave();
                        leavingView.willUnload();
                        // the entering view is now the new last view
                        var enteringView = this.getPrevious(leavingView);
                        enteringView.shouldDestroy = false;
                        enteringView.shouldCache = false;
                        enteringView.willEnter();
                        // wait for the new view to complete setup
                        this._render(enteringView, {}, function () {
                            _this7._zone.runOutsideAngular(function () {
                                // set that the new view pushed on the stack is staged to be entering/leaving
                                // staged state is important for the transition to find the correct view
                                enteringView.state = STAGED_ENTERING_STATE;
                                leavingView.state = STAGED_LEAVING_STATE;
                                // init the swipe back transition animation
                                _this7._sbTrans = Transition.create(_this7, opts);
                                _this7._sbTrans.easing('linear').progressStart();
                            });
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'swipeBackProgress',
                    value: function swipeBackProgress(value) {
                        return;
                        if (this._sbTrans) {
                            // continue to disable the app while actively dragging
                            this.app.setEnabled(false, 4000);
                            this.setTransitioning(true, 4000);
                            // set the transition animation's progress
                            this._sbTrans.progress(value);
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'swipeBackEnd',
                    value: function swipeBackEnd(completeSwipeBack, rate) {
                        var _this8 = this;

                        return;
                        if (!this._sbTrans) return;
                        // disables the app during the transition
                        this.app.setEnabled(false);
                        this.setTransitioning(true);
                        this._sbTrans.progressEnd(completeSwipeBack, rate).then(function () {
                            _this8._zone.run(function () {
                                // find the views that were entering and leaving
                                var enteringView = _this8._getStagedEntering();
                                var leavingView = _this8._getStagedLeaving();
                                if (enteringView && leavingView) {
                                    // finish up the animation
                                    if (completeSwipeBack) {
                                        // swipe back has completed navigating back
                                        // update each view's state
                                        enteringView.state = ACTIVE_STATE;
                                        leavingView.state = CACHED_STATE;
                                        enteringView.didEnter();
                                        leavingView.didLeave();
                                        if (_this8.router) {
                                            // notify router of the pop state change
                                            _this8.router.stateChange('pop', enteringView);
                                        }
                                    } else {
                                        // cancelled the swipe back, they didn't end up going back
                                        // return views to their original state
                                        leavingView.state = ACTIVE_STATE;
                                        enteringView.state = CACHED_STATE;
                                        leavingView.willEnter();
                                        leavingView.didEnter();
                                        enteringView.didLeave();
                                        leavingView.shouldDestroy = false;
                                        enteringView.shouldDestroy = false;
                                    }
                                }
                                // empty out and dispose the swipe back transition animation
                                _this8._sbTrans && _this8._sbTrans.dispose();
                                _this8._sbTrans = null;
                                // all done!
                                _this8._transComplete();
                            });
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_sbComplete',
                    value: function _sbComplete() {
                        return;
                        if (this.canSwipeBack()) {
                            // it is possible to swipe back
                            if (this.sbGesture) {
                                // this is already an active gesture, don't create another one
                                return;
                            }
                            var opts = {
                                edge: 'left',
                                threshold: this._sbThreshold
                            };
                            this.sbGesture = new SwipeBackGesture(this.getNativeElement(), opts, this);
                            console.debug('SwipeBackGesture listen');
                            this.sbGesture.listen();
                        } else if (this.sbGesture) {
                            // it is not possible to swipe back and there is an
                            // active sbGesture, so unlisten it
                            console.debug('SwipeBackGesture unlisten');
                            this.sbGesture.unlisten();
                            this.sbGesture = null;
                        }
                    }

                    /**
                     * Check to see if swipe-to-go-back is enabled
                     * @param {boolean=} isSwipeBackEnabled Set whether or not swipe-to-go-back is enabled
                     * @returns {boolean} Whether swipe-to-go-back is enabled
                     */
                }, {
                    key: 'isSwipeBackEnabled',
                    value: function isSwipeBackEnabled(val) {
                        if (arguments.length) {
                            this._sbEnabled = !!val;
                        }
                        return this._sbEnabled;
                    }

                    /**
                     * If it's possible to use swipe back or not. If it's not possible
                     * to go back, or swipe back is not enable then this will return false.
                     * If it is possible to go back, and swipe back is enabled, then this
                     * will return true.
                     * @returns {boolean} Whether you can swipe to go back
                     */
                }, {
                    key: 'canSwipeBack',
                    value: function canSwipeBack() {
                        return this._sbEnabled && this.canGoBack();
                    }

                    /**
                     * Returns `true` if there's a valid previous page that we can pop back to.
                     * Otherwise returns false.
                     * @returns {boolean} Whether there is a page to go back to
                     */
                }, {
                    key: 'canGoBack',
                    value: function canGoBack() {
                        var activeView = this.getActive();
                        if (activeView) {
                            return activeView.enableBack();
                        }
                        return false;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: 'navbarViewContainer',
                    value: function navbarViewContainer(nbContainer) {
                        if (nbContainer) {
                            this._nbContainer = nbContainer;
                        }
                        if (this._nbContainer) {
                            return this._nbContainer;
                        }
                        if (this.parent) {
                            return this.parent.navbarViewContainer();
                        }
                    }

                    /**
                     * @private
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'anchorElementRef',
                    value: function anchorElementRef() {
                        if (arguments.length) {
                            this._anchorER = arguments[0];
                        }
                        return this._anchorER;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_add',
                    value: function _add(viewCtrl) {
                        this._incId(viewCtrl);
                        this._views.push(viewCtrl);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_incId',
                    value: function _incId(viewCtrl) {
                        viewCtrl.id = this.id + '-' + ++this._ids;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_remove',
                    value: function _remove(viewOrIndex) {
                        array.remove(this._views, viewOrIndex);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_getStagedEntering',
                    value: function _getStagedEntering() {
                        for (var i = 0, ii = this._views.length; i < ii; i++) {
                            if (this._views[i].state === STAGED_ENTERING_STATE) {
                                return this._views[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: '_getStagedLeaving',
                    value: function _getStagedLeaving() {
                        for (var i = 0, ii = this._views.length; i < ii; i++) {
                            if (this._views[i].state === STAGED_LEAVING_STATE) {
                                return this._views[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * @private
                     * @returns {Component} TODO
                     */
                }, {
                    key: 'getActive',
                    value: function getActive() {
                        for (var i = this._views.length - 1; i >= 0; i--) {
                            if (this._views[i].state === ACTIVE_STATE && !this._views[i].shouldDestroy) {
                                return this._views[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * @param {Index} The index of the page you want to get
                     * @returns {Component} Returns the component that matches the index given
                     */
                }, {
                    key: 'getByIndex',
                    value: function getByIndex(index) {
                        if (index < this._views.length && index > -1) {
                            return this._views[index];
                        }
                        return null;
                    }

                    /**
                     * @private
                     * @param {TODO} view  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getPrevious',
                    value: function getPrevious(viewCtrl) {
                        if (viewCtrl) {
                            var viewIndex = this._views.indexOf(viewCtrl);
                            for (var i = viewIndex - 1; i >= 0; i--) {
                                if (!this._views[i].shouldDestroy) {
                                    return this._views[i];
                                }
                            }
                        }
                        return null;
                    }

                    /**
                     * First page in this nav controller's stack. This would not return a page which is about to be destroyed.
                     * @returns {Component} Returns the first component page in the current stack
                     */
                }, {
                    key: 'first',
                    value: function first() {
                        for (var i = 0, l = this._views.length; i < l; i++) {
                            if (!this._views[i].shouldDestroy) {
                                return this._views[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * Last page in this nav controller's stack. This would not return a page which is about to be destroyed.
                     * @returns {Component} Returns the last component page in the current stack
                     */
                }, {
                    key: 'last',
                    value: function last() {
                        for (var i = this._views.length - 1; i >= 0; i--) {
                            if (!this._views[i].shouldDestroy) {
                                return this._views[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * @private
                     * @param {TODO} view  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'indexOf',
                    value: function indexOf(viewCtrl) {
                        return this._views.indexOf(viewCtrl);
                    }

                    /**
                     * Number of sibling views in the nav controller. This does
                     * not include views which are about to be destroyed.
                     * @returns {Number} The number of views in stack, including the current view
                     */
                }, {
                    key: 'length',
                    value: function length() {
                        var len = 0;
                        for (var i = 0, l = this._views.length; i < l; i++) {
                            if (!this._views[i].shouldDestroy) {
                                len++;
                            }
                        }
                        return len;
                    }

                    /**
                     * @private
                     * @param {TODO} view  TODO
                     * @returns {boolean}
                     */
                }, {
                    key: 'isActive',
                    value: function isActive(viewCtrl) {
                        return !!(viewCtrl && viewCtrl.state === ACTIVE_STATE);
                    }

                    /**
                     * Returns the root NavController.
                     * @returns {NavController}
                     */
                }, {
                    key: 'registerRouter',

                    /**
                     * @private
                     * @param {TODO} router  TODO
                     */
                    value: function registerRouter(router) {
                        this.router = router;
                    }
                }, {
                    key: 'rootNav',
                    get: function get() {
                        var nav = this;
                        while (nav.parent) {
                            nav = nav.parent;
                        }
                        return nav;
                    }
                }]);

                return NavController;
            })(Ion);

            _export('NavController', NavController);

            ACTIVE_STATE = 1;
            CACHED_STATE = 2;
            STAGED_ENTERING_STATE = 3;
            STAGED_LEAVING_STATE = 4;
            ctrlIds = -1;

            /**
             * @name NavParams
             * @description
             * NavParams are an object that exists on a page and can contain data for that particular view.
             * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible
             * option with a simple `get` method.
             *
             * @usage
             * ```ts
             * export class MyClass{
             *  constructor(params: NavParams){
             *    this.params = params;
             *    // userParams is an object we have in our nav-parameters
             *    this.params.get('userParams');
             *  }
             * }
             * ```
             * @demo /docs/v3/demos/nav-params/
             * @see {@link /docs/v3/components#navigation Navigation Component Docs}
             * @see {@link ../NavController/ NavController API Docs}
             * @see {@link ../Nav/ Nav API Docs}
             * @see {@link ../NavPush/ NavPush API Docs}
             */

            NavParams = (function () {
                /**
                 * @private
                 * @param {TODO} data  TODO
                 */

                function NavParams(data) {
                    _classCallCheck(this, NavParams);

                    this.data = data || {};
                }

                /**
                 * Get the value of a nav-parameter for the current view
                 *
                 * ```ts
                 * export class MyClass{
                 *  constructor(params: NavParams){
                 *    this.params = params;
                 *    // userParams is an object we have in our nav-parameters
                 *    this.params.get('userParams');
                 *  }
                 * }
                 * ```
                 *
                 *
                 * @param {string} parameter Which param you want to look up
                 */

                _createClass(NavParams, [{
                    key: 'get',
                    value: function get(param) {
                        return this.data[param];
                    }
                }]);

                return NavParams;
            })();

            _export('NavParams', NavParams);
        }
    };
});
System.register("ionic/components/nav/nav-push", ["angular2/core", "./nav-controller", "./nav-registry"], function (_export) {
    /**
     * @name NavPush
     * @description
     * Directive for declaratively linking to a new page instead of using
     * {@link ../NavController/#push NavController.push}. Similar to ui-router's `ui-sref`.
     *
     * @usage
     * ```html
     * <button [navPush]="pushPage"></button>
     * ```
     * To specify parameters you can use array syntax or the `nav-params` property:
     * ```html
     * <button [navPush]="pushPage" [navParams]="params"></button>
     * ```
     * Where `pushPage` and `params` are specified in your component, and `pushPage`
     * contains a reference to a [@Page component](../../../config/Page/):
     *
     * ```ts
     * import {LoginPage} from 'login';
     * @Page({
     *   template: `<button [navPush]="pushPage" [navParams]="params"></button>`
     * })
     * class MyPage {
     *   constructor(){
     *     this.pushPage = LoginPage;
     *     this.params = { id: 42 };
     *   }
     * }
     * ```
     *
     * ### Alternate syntax
     * You can also use syntax similar to Angular2's router, passing an array to
     * NavPush:
     * ```html
     * <button [navPush]="[pushPage, params]"></button>
     * ```
     * @demo /docs/v3/demos/nav-push-pop/
     * @see {@link /docs/v3/components#navigation Navigation Component Docs}
     * @see {@link ../NavPop NavPop API Docs}
     */
    "use strict";

    var Directive, Optional, NavController, NavRegistry, __decorate, __metadata, __param, NavPush, NavPop, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            Optional = _angular2Core.Optional;
        }, function (_navController) {
            NavController = _navController.NavController;
        }, function (_navRegistry) {
            NavRegistry = _navRegistry.NavRegistry;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            NavPush = (function () {
                /**
                 * TODO
                 * @param {NavController} nav  TODO
                 */

                function NavPush(nav, registry) {
                    _classCallCheck(this, NavPush);

                    this.nav = nav;
                    this.registry = registry;
                    if (!nav) {
                        console.error('nav-push must be within a NavController');
                    }
                }

                /**
                 * @private
                 */

                _createClass(NavPush, [{
                    key: "onClick",
                    value: function onClick() {
                        var destination = undefined,
                            params = undefined;
                        if (this.instruction instanceof Array) {
                            if (this.instruction.length > 2) {
                                throw 'Too many [navPush] arguments, expects [View, { params }]';
                            }
                            destination = this.instruction[0];
                            params = this.instruction[1] || this.params;
                        } else {
                            destination = this.instruction;
                            params = this.params;
                        }
                        if (typeof destination === "string") {
                            destination = this.registry.get(destination);
                        }
                        this.nav && this.nav.push(destination, params);
                    }
                }]);

                return NavPush;
            })();

            _export("NavPush", NavPush);

            _export("NavPush", NavPush = __decorate([Directive({
                selector: '[navPush]',
                inputs: ['instruction: navPush', 'params: navParams'],
                host: {
                    '(click)': 'onClick()',
                    'role': 'link'
                }
            }), __param(0, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof NavController !== 'undefined' && NavController) === 'function' && _a || Object, typeof (_b = typeof NavRegistry !== 'undefined' && NavRegistry) === 'function' && _b || Object])], NavPush));
            /**
             * @name NavPop
             * @description
             * Directive for declaratively pop the current page off from the navigation stack.
             *
             * @usage
             * ```html
             * <ion-content>
             *  <div block button nav-pop>go back</div>
             * </ion-content>
             * ```
             * This will go back one page in the navigation stack
             *
             * Similar to {@link /docs/api/components/nav/NavPush/ `NavPush` }
             * @demo /docs/v3/demos/nav-push-pop/
             * @see {@link /docs/v3/components#navigation Navigation Component Docs}
             * @see {@link ../NavPush NavPush API Docs}
             */

            NavPop = (function () {
                /**
                 * TODO
                 * @param {NavController} nav  TODO
                 */

                function NavPop(nav) {
                    _classCallCheck(this, NavPop);

                    this.nav = nav;
                    if (!nav) {
                        console.error('nav-pop must be within a NavController');
                    }
                }

                /**
                 * @private
                 */

                _createClass(NavPop, [{
                    key: "onClick",
                    value: function onClick() {
                        this.nav && this.nav.pop();
                    }
                }]);

                return NavPop;
            })();

            _export("NavPop", NavPop);

            _export("NavPop", NavPop = __decorate([Directive({
                selector: '[nav-pop]',
                host: {
                    '(click)': 'onClick()',
                    'role': 'link'
                }
            }), __param(0, Optional()), __metadata('design:paramtypes', [typeof (_c = typeof NavController !== 'undefined' && NavController) === 'function' && _c || Object])], NavPop));
        }
    };
});
System.register("ionic/components/nav/nav-registry", [], function (_export) {
    /**
     * @private
     * Map of possible pages that can be navigated to using an Ionic NavController
     */
    "use strict";

    var NavRegistry;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [],
        execute: function () {
            NavRegistry = (function () {
                function NavRegistry() {
                    var pages = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

                    _classCallCheck(this, NavRegistry);

                    this._pages = new Map(pages.map(function (page) {
                        return [page.name, page];
                    }));
                }

                _createClass(NavRegistry, [{
                    key: "get",
                    value: function get(pageName) {
                        return this._pages.get(pageName);
                    }
                }, {
                    key: "set",
                    value: function set(page) {
                        this._pages.set(page.name, page);
                    }
                }]);

                return NavRegistry;
            })();

            _export("NavRegistry", NavRegistry);
        }
    };
});
System.register("ionic/components/nav/nav-router", ["angular2/core", "angular2/router", "./nav"], function (_export) {
    /**
     * @private
     */
    "use strict";

    var Directive, ElementRef, DynamicComponentLoader, Attribute, RouterOutlet, Router, Instruction, Nav, __decorate, __metadata, __param, NavRouter, ResolvedInstruction, _a, _b, _c, _d;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            ElementRef = _angular2Core.ElementRef;
            DynamicComponentLoader = _angular2Core.DynamicComponentLoader;
            Attribute = _angular2Core.Attribute;
        }, function (_angular2Router) {
            RouterOutlet = _angular2Router.RouterOutlet;
            Router = _angular2Router.Router;
            Instruction = _angular2Router.Instruction;
        }, function (_nav) {
            Nav = _nav.Nav;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            NavRouter = (function (_RouterOutlet) {
                _inherits(NavRouter, _RouterOutlet);

                /**
                 * TODO
                 * @param {ElementRef} _elementRef  TODO
                 * @param {DynamicComponentLoader} _loader  TODO
                 * @param {Router} _parentRouter  TODO
                 * @param {string} nameAttr  Value of the element's 'name' attribute
                 * @param {Nav} nav  TODO
                 */

                function NavRouter(_elementRef, _loader, _parentRouter, nameAttr, nav) {
                    _classCallCheck(this, NavRouter);

                    _get(Object.getPrototypeOf(NavRouter.prototype), "constructor", this).call(this, _elementRef, _loader, _parentRouter, nameAttr);
                    // Nav is Ionic's NavController, which we injected into this class
                    this.nav = nav;
                    // register this router with Ionic's NavController
                    // Ionic's NavController will call this NavRouter's "stateChange"
                    // method when the NavController has...changed its state
                    nav.registerRouter(this);
                }

                /**
                 * @private
                 * TODO
                 * @param {ComponentInstruction} instruction  TODO
                 */

                _createClass(NavRouter, [{
                    key: "activate",
                    value: function activate(nextInstruction) {
                        var previousInstruction = this._currentInstruction;
                        this._currentInstruction = nextInstruction;
                        var componentType = nextInstruction.componentType;
                        var childRouter = this._parentRouter.childRouter(componentType);
                        // prevent double navigations to the same view
                        var lastView = this.nav.last();
                        if (this.nav.isTransitioning() || lastView && lastView.componentType === componentType && lastView.params.data === nextInstruction.params) {
                            return Promise.resolve();
                        }
                        // tell the NavController which componentType, and it's params, to navigate to
                        return this.nav.push(componentType, nextInstruction.params);
                    }
                }, {
                    key: "reuse",
                    value: function reuse(nextInstruction) {
                        return Promise.resolve();
                    }

                    /**
                     * TODO
                     * @param {TODO} type  TODO
                     * @param {TODO} viewCtrl  TODO
                     */
                }, {
                    key: "stateChange",
                    value: function stateChange(type, viewCtrl) {
                        // stateChange is called by Ionic's NavController
                        // type could be "push" or "pop"
                        // viewCtrl is Ionic's ViewController class, which has the properties "componentType" and "params"
                        // only do an update if there's an actual view change
                        if (!viewCtrl || this._activeViewId === viewCtrl.id) return;
                        this._activeViewId = viewCtrl.id;
                        // get the best PathRecognizer for this view's componentType
                        var pathRecognizer = this.getPathRecognizerByComponent(viewCtrl.componentType);
                        if (pathRecognizer) {
                            // generate a componentInstruction from the view's PathRecognizer and params
                            var componentInstruction = pathRecognizer.generate(viewCtrl.data);
                            // create a ResolvedInstruction from the componentInstruction
                            var instruction = new ResolvedInstruction(componentInstruction, null);
                            this._parentRouter.navigateByInstruction(instruction);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} componentType  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "getPathRecognizerByComponent",
                    value: function getPathRecognizerByComponent(componentType) {
                        // given a componentType, figure out the best PathRecognizer to use
                        var rules = this._parentRouter.registry._rules;
                        var pathRecognizer = null;
                        rules.forEach(function (rule) {
                            pathRecognizer = rule.matchers.find(function (matcherPathRecognizer) {
                                return matcherPathRecognizer.handler.componentType === componentType;
                            });
                        });
                        return pathRecognizer;
                    }
                }]);

                return NavRouter;
            })(RouterOutlet);

            _export("NavRouter", NavRouter);

            _export("NavRouter", NavRouter = __decorate([Directive({
                selector: 'ion-nav'
            }), __param(3, Attribute('name')), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof DynamicComponentLoader !== 'undefined' && DynamicComponentLoader) === 'function' && _b || Object, typeof (_c = typeof Router !== 'undefined' && Router) === 'function' && _c || Object, String, typeof (_d = typeof Nav !== 'undefined' && Nav) === 'function' && _d || Object])], NavRouter));
            // TODO: hacked from
            // https://github.com/angular/angular/blob/6ddfff5cd59aac9099aa6da5118c5598eea7ea11/modules/angular2/src/router/instruction.ts#L207

            ResolvedInstruction = (function (_Instruction) {
                _inherits(ResolvedInstruction, _Instruction);

                function ResolvedInstruction(component, child, auxInstruction) {
                    _classCallCheck(this, ResolvedInstruction);

                    _get(Object.getPrototypeOf(ResolvedInstruction.prototype), "constructor", this).call(this);
                    this.component = component;
                    this.child = child;
                    this.auxInstruction = auxInstruction;
                }

                _createClass(ResolvedInstruction, [{
                    key: "resolveComponent",
                    value: function resolveComponent() {
                        return Promise.resolve(this.component);
                    }
                }]);

                return ResolvedInstruction;
            })(Instruction);
        }
    };
});
System.register("ionic/components/nav/nav", ["angular2/core", "../app/app", "../../config/config", "../../util/keyboard", "../../decorators/config-component", "./nav-controller", "./view-controller"], function (_export) {
    /**
     * @name Nav
     * @description
     * _For a quick walkthrough of navigation in Ionic, check out the
     * [Navigation section](../../../../components/#navigation) of the Component
     * docs._
     *
     * Nav is a basic navigation controller component.  As a subclass of NavController
     * you use it to navigate to pages in your app and manipulate the navigation stack.
     * Nav automatically animates transitions between pages for you.
     *
     * For more information on using navigation controllers like Nav or [Tab](../../Tabs/Tab/),
     * take a look at the [NavController API reference](../NavController/).
     *
     * You must set a root page (where page is any [@Page](../../config/Page/)
     * component) to be loaded initially by any Nav you create, using
     * the 'root' property:
     *
     * ```ts
     * import {GettingStartedPage} from 'getting-started';
     * @App({
     *   template: `<ion-nav [root]="rootPage"></ion-nav>`
     * })
     * class MyApp {
     *   constructor(){
     *     this.rootPage = GettingStartedPage;
     *   }
     * }
     * ```
     *
     * <h2 id="back_navigation">Back navigation</h2>
     * If a [page](../NavController/#creating_pages) you navigate to has a [NavBar](../NavBar/),
     * Nav will automatically add a back button to it if there is a page
     * before the one you are navigating to in the navigation stack.
     *
     * Additionally, specifying the `swipe-back-enabled` property will allow you to
     * swipe to go back:
     * ```html
     * <ion-nav swipe-back-enabled="false" [root]="rootPage"></ion-nav>
     * ```
     *
     * Here is a diagram of how Nav animates smoothly between pages:
     *
     * <div class="highlight less-margin">
     *   <pre>
     *                           +-------+
     *                           |  App  |
     *                           +---+---+
     *                           &lt;ion-app&gt;
     *                               |
     *                  +------------+-------------+
     *                  |   Ionic Nav Controller   |
     *                  +------------+-------------+
     *                           &lt;ion-nav&gt;
     *                               |
     *                               |
     *             Page 3  +--------------------+                     LoginPage
     *           Page 2  +--------------------+ |
     *         Page 1  +--------------------+ | |              +--------------------+
     *                 | | Header           |&lt;-----------------|       Login        |
     *                 +--------------------+ | |              +--------------------+
     *                 | | |                | | |              | Username:          |
     *                 | | |                | | |              | Password:          |
     *                 | | |  Page 3 is     | | |              |                    |
     *                 | | |  only content  | | |              |                    |
     *                 | | |                |&lt;-----------------|                    |
     *                 | | |                | | |              |                    |
     *                 | | |                | | |              |                    |
     *                 | +------------------|-+ |              |                    |
     *                 | | Footer           |-|-+              |                    |
     *                 | +------------------|-+                |                    |
     *                 +--------------------+                  +--------------------+
     *
     *           +--------------------+    +--------------------+    +--------------------+
     *           | Header             |    | Content            |    | Content            |
     *           +--------------------+    |                    |    |                    |
     *           | Content            |    |                    |    |                    |
     *           |                    |    |                    |    |                    |
     *           |                    |    |                    |    |                    |
     *           |                    |    |                    |    |                    |
     *           |                    |    |                    |    |                    |
     *           |                    |    |                    |    |                    |
     *           |                    |    |                    |    |                    |
     *           |                    |    |                    |    |                    |
     *           |                    |    +--------------------+    |                    |
     *           |                    |    | Footer             |    |                    |
     *           +--------------------+    +--------------------+    +--------------------+
     *
     *   </pre>
     * </div>
     *
     * @see {@link /docs/v3/components#navigation Navigation Component Docs}
     */
    "use strict";

    var ChangeDetectorRef, ElementRef, Optional, NgZone, Compiler, AppViewManager, Renderer, IonicApp, Config, Keyboard, ConfigComponent, NavController, ViewController, __decorate, __metadata, __param, Nav, _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            ChangeDetectorRef = _angular2Core.ChangeDetectorRef;
            ElementRef = _angular2Core.ElementRef;
            Optional = _angular2Core.Optional;
            NgZone = _angular2Core.NgZone;
            Compiler = _angular2Core.Compiler;
            AppViewManager = _angular2Core.AppViewManager;
            Renderer = _angular2Core.Renderer;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_utilKeyboard) {
            Keyboard = _utilKeyboard.Keyboard;
        }, function (_decoratorsConfigComponent) {
            ConfigComponent = _decoratorsConfigComponent.ConfigComponent;
        }, function (_navController) {
            NavController = _navController.NavController;
        }, function (_viewController) {
            ViewController = _viewController.ViewController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Nav = (function (_NavController) {
                _inherits(Nav, _NavController);

                function Nav(hostNavCtrl, viewCtrl, app, config, keyboard, elementRef, compiler, viewManager, zone, renderer, cd) {
                    _classCallCheck(this, Nav);

                    _get(Object.getPrototypeOf(Nav.prototype), "constructor", this).call(this, hostNavCtrl, app, config, keyboard, elementRef, 'contents', compiler, viewManager, zone, renderer, cd);
                    if (viewCtrl) {
                        // an ion-nav can also act as an ion-page within a parent ion-nav
                        // this would happen when an ion-nav nests a child ion-nav.
                        viewCtrl.setContent(this);
                        viewCtrl.setContentRef(elementRef);
                    }
                }

                /**
                 * @private
                 */

                _createClass(Nav, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        _get(Object.getPrototypeOf(Nav.prototype), "ngOnInit", this).call(this);
                        if (this.root) {
                            if (typeof this.root !== 'function') {
                                throw 'The [root] property in <ion-nav> must be given a reference to a component class from within the constructor.';
                            }
                            this.push(this.root);
                        }
                        // default the swipe back to be enabled
                        this.isSwipeBackEnabled((this.swipeBackEnabled || '').toString() !== 'false');
                    }
                }]);

                return Nav;
            })(NavController);

            _export("Nav", Nav);

            _export("Nav", Nav = __decorate([ConfigComponent({
                selector: 'ion-nav',
                inputs: ['root'],
                // defaultInputs: {
                //   'swipeBackEnabled': true
                // },
                template: '<template #contents></template>'
            }), __param(0, Optional()), __param(1, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof NavController !== 'undefined' && NavController) === 'function' && _a || Object, typeof (_b = typeof ViewController !== 'undefined' && ViewController) === 'function' && _b || Object, typeof (_c = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _c || Object, typeof (_d = typeof Config !== 'undefined' && Config) === 'function' && _d || Object, typeof (_e = typeof Keyboard !== 'undefined' && Keyboard) === 'function' && _e || Object, typeof (_f = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _f || Object, typeof (_g = typeof Compiler !== 'undefined' && Compiler) === 'function' && _g || Object, typeof (_h = typeof AppViewManager !== 'undefined' && AppViewManager) === 'function' && _h || Object, typeof (_j = typeof NgZone !== 'undefined' && NgZone) === 'function' && _j || Object, typeof (_k = typeof Renderer !== 'undefined' && Renderer) === 'function' && _k || Object, typeof (_l = typeof ChangeDetectorRef !== 'undefined' && ChangeDetectorRef) === 'function' && _l || Object])], Nav));
        }
    };
});
System.register('ionic/components/nav/overlay-controller', ['../view-controller'], function (_export) {
    'use strict';

    var ViewController, OverlayController;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_viewController) {
            ViewController = _viewController.ViewController;
        }],
        execute: function () {
            OverlayController = (function (_ViewController) {
                _inherits(OverlayController, _ViewController);

                function OverlayController(navCtrl, componentType) {
                    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                    _classCallCheck(this, OverlayController);

                    _get(Object.getPrototypeOf(OverlayController.prototype), 'constructor', this).call(this, null, AlertCmp, opts);
                    this.data.inputs = this.data.inputs || [];
                    var buttons = this.data.buttons || [];
                    this.data.buttons = [];
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = buttons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var button = _step.value;

                            this.addButton(button);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator['return']) {
                                _iterator['return']();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    this.enterAnimationKey = 'alertEnter';
                    this.leaveAnimationKey = 'alertLeave';
                }

                _createClass(OverlayController, [{
                    key: 'setTitle',
                    value: function setTitle(title) {
                        this.data.title = title;
                    }
                }, {
                    key: 'setSubTitle',
                    value: function setSubTitle(subTitle) {
                        this.data.subTitle = subTitle;
                    }
                }, {
                    key: 'setBody',
                    value: function setBody(body) {
                        this.data.body = body;
                    }
                }, {
                    key: 'addInput',
                    value: function addInput(input) {
                        input.value = isDefined(input.value) ? input.value : '';
                        this.data.inputs.push(input);
                    }
                }, {
                    key: 'addButton',
                    value: function addButton(button) {
                        if (typeof button === 'string') {
                            button = {
                                text: button
                            };
                        }
                        this.data.buttons.push(button);
                    }
                }, {
                    key: 'close',
                    value: function close() {
                        var index = this._nav.indexOf(this);
                        this._nav.remove(index, { animateFirst: true });
                    }
                }, {
                    key: 'onClose',
                    value: function onClose(handler) {
                        this.data.onClose = handler;
                    }
                }]);

                return OverlayController;
            })(ViewController);

            _export('OverlayController', OverlayController);
        }
    };
});
System.register('ionic/components/nav/swipe-back', ['../../gestures/slide-edge-gesture'], function (_export) {
    'use strict';

    var SlideEdgeGesture, SwipeBackGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_gesturesSlideEdgeGesture) {
            SlideEdgeGesture = _gesturesSlideEdgeGesture.SlideEdgeGesture;
        }],
        execute: function () {
            SwipeBackGesture = (function (_SlideEdgeGesture) {
                _inherits(SwipeBackGesture, _SlideEdgeGesture);

                function SwipeBackGesture(element, opts, navCtrl) {
                    if (opts === undefined) opts = {};

                    _classCallCheck(this, SwipeBackGesture);

                    _get(Object.getPrototypeOf(SwipeBackGesture.prototype), 'constructor', this).call(this, element, opts);
                    // Can check corners through use of eg 'left top'
                    this.edges = opts.edge.split(' ');
                    this.threshold = opts.threshold;
                    this.navCtrl = navCtrl;
                }

                _createClass(SwipeBackGesture, [{
                    key: 'onSlideStart',
                    value: function onSlideStart() {
                        this.navCtrl.swipeBackStart();
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.navCtrl.swipeBackProgress(slide.distance / slide.max);
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        var shouldComplete = Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5;
                        // TODO: calculate a better playback rate depending on velocity and distance
                        this.navCtrl.swipeBackEnd(shouldComplete, 1);
                    }
                }]);

                return SwipeBackGesture;
            })(SlideEdgeGesture);

            _export('SwipeBackGesture', SwipeBackGesture);
        }
    };
});
System.register("ionic/components/nav/view-controller", ["angular2/core", "./nav-controller"], function (_export) {
    /**
     * @name ViewController
     * @description
     * Access various features and information about the current view
     * @usage
     *  ```ts
     *  import {Page, ViewController} from 'ionic/ionic';
     *  @Page....
     *  export class MyPage{
     *   constructor(viewCtrl: ViewController){
     *     this.viewCtrl = viewCtrl;
     *   }
     *  }
     *  ```
     */
    "use strict";

    var Output, EventEmitter, NavParams, __decorate, __metadata, ViewController, _a;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function ctrlFn(viewCtrl, fnName) {
        if (viewCtrl.instance && viewCtrl.instance[fnName]) {
            try {
                viewCtrl.instance[fnName]();
            } catch (e) {
                console.error(fnName + ': ' + e.message);
            }
        }
    }
    return {
        setters: [function (_angular2Core) {
            Output = _angular2Core.Output;
            EventEmitter = _angular2Core.EventEmitter;
        }, function (_navController) {
            NavParams = _navController.NavParams;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ViewController = (function () {
                function ViewController(componentType) {
                    var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, ViewController);

                    this._emitter = new EventEmitter();
                    this.componentType = componentType;
                    this.data = data;
                    this.instance = {};
                    this.state = 0;
                    this._destroys = [];
                    this._loaded = false;
                    this.shouldDestroy = false;
                    this.shouldCache = false;
                    this.viewType = '';
                    this._leavingOpts = null;
                    this._onDismiss = null;
                }

                _createClass(ViewController, [{
                    key: "subscribe",
                    value: function subscribe(callback) {
                        this._emitter.subscribe(callback);
                    }
                }, {
                    key: "emit",
                    value: function emit(data) {
                        this._emitter.emit(data);
                    }
                }, {
                    key: "onDismiss",
                    value: function onDismiss(callback) {
                        this._onDismiss = callback;
                    }
                }, {
                    key: "dismiss",
                    value: function dismiss(data) {
                        this._onDismiss && this._onDismiss(data);
                        return this._nav.remove(this._nav.indexOf(this), this._leavingOpts);
                    }
                }, {
                    key: "setNav",
                    value: function setNav(navCtrl) {
                        this._nav = navCtrl;
                    }
                }, {
                    key: "getTransitionName",
                    value: function getTransitionName(direction) {
                        return this._nav && this._nav.config.get('pageTransition');
                    }
                }, {
                    key: "getNavParams",
                    value: function getNavParams() {
                        return new NavParams(this.data);
                    }
                }, {
                    key: "setLeavingOpts",
                    value: function setLeavingOpts(opts) {
                        this._leavingOpts = opts;
                    }

                    /**
                     * Check to see if you can go back in the navigation stack
                     * @param {boolean} Check whether or not you can go back from this page
                     * @returns {boolean} Returns if it's possible to go back from this Page.
                     */
                }, {
                    key: "enableBack",
                    value: function enableBack() {
                        // update if it's possible to go back from this nav item
                        if (this._nav) {
                            var previousItem = this._nav.getPrevious(this);
                            // the previous view may exist, but if it's about to be destroyed
                            // it shouldn't be able to go back to
                            return !!(previousItem && !previousItem.shouldDestroy);
                        }
                        return false;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setInstance",
                    value: function setInstance(instance) {
                        this.instance = instance;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "isRoot",

                    /**
                     * @returns {boolean} Returns if this Page is the root page of the NavController.
                     */
                    value: function isRoot() {
                        return this.index === 0;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "addDestroy",
                    value: function addDestroy(destroyFn) {
                        this._destroys.push(destroyFn);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "destroy",
                    value: function destroy() {
                        for (var i = 0; i < this._destroys.length; i++) {
                            this._destroys[i]();
                        }
                        this._destroys = [];
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setNavbarTemplateRef",
                    value: function setNavbarTemplateRef(templateRef) {
                        this._nbTmpRef = templateRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getNavbarTemplateRef",
                    value: function getNavbarTemplateRef() {
                        return this._nbTmpRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getNavbarViewRef",
                    value: function getNavbarViewRef() {
                        return this._nbVwRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setNavbarViewRef",
                    value: function setNavbarViewRef(viewContainerRef) {
                        this._nbVwRef = viewContainerRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setPageRef",
                    value: function setPageRef(elementRef) {
                        this._pgRef = elementRef;
                    }

                    /**
                     * @private
                     * @returns {ElementRef} Returns the Page's ElementRef
                     */
                }, {
                    key: "pageRef",
                    value: function pageRef() {
                        return this._pgRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setContentRef",
                    value: function setContentRef(elementRef) {
                        this._cntRef = elementRef;
                    }

                    /**
                     * @private
                     * @returns {ElementRef} Returns the Page's Content ElementRef
                     */
                }, {
                    key: "contentRef",
                    value: function contentRef() {
                        return this._cntRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setContent",
                    value: function setContent(directive) {
                        this._cntDir = directive;
                    }

                    /**
                     * @private
                     * @returns {Component} Returns the Page's Content component reference.
                     */
                }, {
                    key: "getContent",
                    value: function getContent() {
                        return this._cntDir;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setNavbar",
                    value: function setNavbar(directive) {
                        this._nbDir = directive;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getNavbar",
                    value: function getNavbar() {
                        return this._nbDir;
                    }

                    /**
                     * You can find out of the current view has a Navbar or not. Be sure to wrap this in an `onPageWillEnter` method in order to make sure the view has rendered fully.
                     *
                     * ```typescript
                     * export class Page1 {
                     *  constructor(view: ViewController) {
                     *    this.view = view
                     *  }
                     *  onPageWillEnter(){
                     *    console.log('Do we have a Navbar?', this.view.hasNavbar());
                     *  }
                     *}
                     * ```
                     *
                     * @returns {boolean} Returns a boolean if this Page has a navbar or not.
                     */
                }, {
                    key: "hasNavbar",
                    value: function hasNavbar() {
                        return !!this.getNavbar();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "navbarRef",
                    value: function navbarRef() {
                        var navbar = this.getNavbar();
                        return navbar && navbar.getElementRef();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "titleRef",
                    value: function titleRef() {
                        var navbar = this.getNavbar();
                        return navbar && navbar.getTitleRef();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "navbarItemRefs",
                    value: function navbarItemRefs() {
                        var navbar = this.getNavbar();
                        return navbar && navbar.getItemRefs();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "backBtnRef",
                    value: function backBtnRef() {
                        var navbar = this.getNavbar();
                        return navbar && navbar.getBackButtonRef();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "backBtnTextRef",
                    value: function backBtnTextRef() {
                        var navbar = this.getNavbar();
                        return navbar && navbar.getBackButtonTextRef();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "navbarBgRef",
                    value: function navbarBgRef() {
                        var navbar = this.getNavbar();
                        return navbar && navbar.getBackgroundRef();
                    }

                    /**
                     * You can change the text of the back button on a view-by-view basis.
                     *
                     * ```ts
                     * export class MyClass{
                     *  constructor(viewCtrl: ViewController){
                     *    this.viewCtrl = viewCtrl
                     *  }
                     *  onPageWillEnter() {
                     *    this.viewCtrl.setBackButtonText('Previous');
                     *  }
                     * }
                     * ```
                     * Make sure you use the view events when calling this method, otherwise the back-button will not have been created
                     *
                     * @param {string} backButtonText Set the back button text.
                     */
                }, {
                    key: "setBackButtonText",
                    value: function setBackButtonText(val) {
                        var navbar = this.getNavbar();
                        if (navbar) {
                            navbar.bbText = val;
                        }
                    }

                    /**
                     * Set if the back button for the current view is visible or not. Be sure to wrap this in `onPageWillEnter` to make sure the has been compleltly rendered.
                     * @param {boolean} Set if this Page's back button should show or not.
                     */
                }, {
                    key: "showBackButton",
                    value: function showBackButton(shouldShow) {
                        var navbar = this.getNavbar();
                        if (navbar) {
                            navbar.hideBackButton = !shouldShow;
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "isLoaded",
                    value: function isLoaded() {
                        return this._loaded;
                    }

                    /**
                     * @private
                     * The view has loaded. This event only happens once per view being
                     * created. If a view leaves but is cached, then this will not
                     * fire again on a subsequent viewing. This method is a good place
                     * to put your setup code for the view; however, it is not the
                     * recommended method to use when a view becomes active.
                     */
                }, {
                    key: "loaded",
                    value: function loaded() {
                        this._loaded = true;
                        if (!this.shouldDestroy) {
                            ctrlFn(this, 'onPageLoaded');
                        }
                    }

                    /**
                     * @private
                     * The view is about to enter and become the active view.
                     */
                }, {
                    key: "willEnter",
                    value: function willEnter() {
                        if (!this.shouldDestroy) {
                            ctrlFn(this, 'onPageWillEnter');
                        }
                    }

                    /**
                     * @private
                     * The view has fully entered and is now the active view. This
                     * will fire, whether it was the first load or loaded from the cache.
                     */
                }, {
                    key: "didEnter",
                    value: function didEnter() {
                        var navbar = this.getNavbar();
                        navbar && navbar.didEnter();
                        ctrlFn(this, 'onPageDidEnter');
                    }

                    /**
                     * @private
                     * The view has is about to leave and no longer be the active view.
                     */
                }, {
                    key: "willLeave",
                    value: function willLeave() {
                        ctrlFn(this, 'onPageWillLeave');
                    }

                    /**
                     * @private
                     * The view has finished leaving and is no longer the active view. This
                     * will fire, whether it is cached or unloaded.
                     */
                }, {
                    key: "didLeave",
                    value: function didLeave() {
                        ctrlFn(this, 'onPageDidLeave');
                    }

                    /**
                     * @private
                     * The view is about to be destroyed and have its elements removed.
                     */
                }, {
                    key: "willUnload",
                    value: function willUnload() {
                        ctrlFn(this, 'onPageWillUnload');
                    }

                    /**
                     * @private
                     * The view has been destroyed and its elements have been removed.
                     */
                }, {
                    key: "didUnload",
                    value: function didUnload() {
                        ctrlFn(this, 'onPageDidUnload');
                    }
                }, {
                    key: "name",
                    get: function get() {
                        return this.componentType ? this.componentType.name : '';
                    }

                    /**
                     * You can find out the index of the current view is in the current navigation stack
                     *
                     * ```typescript
                     *  export class Page1 {
                     *    constructor(view: ViewController){
                     *      this.view = view;
                     *      // Just log out the index
                     *      console.log(this.view.index);
                     *    }
                     *  }
                     * ```
                     *
                     * @returns {Number} Returns the index of this page within its NavController.
                     */
                }, {
                    key: "index",
                    get: function get() {
                        return this._nav ? this._nav.indexOf(this) : -1;
                    }
                }]);

                return ViewController;
            })();

            _export("ViewController", ViewController);

            __decorate([Output(), __metadata('design:type', typeof (_a = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _a || Object)], ViewController.prototype, "_emitter", void 0);
        }
    };
});
System.register("ionic/components/overlay/overlay", ["angular2/core"], function (_export) {
    /**
     * @private
     */
    "use strict";

    var Directive, __decorate, __metadata, OverlayNav;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            OverlayNav = function OverlayNav() {
                _classCallCheck(this, OverlayNav);

                // deprecated warning
                console.warn('<ion-overlay> is no longer needed and can be safely removed.');
                console.warn('https://github.com/ionic-team/ionic2/blob/master/CHANGELOG.md#overlay-refactor');
                console.warn('See the v2 docs for an update on how overlays work.');
            };

            _export("OverlayNav", OverlayNav);

            _export("OverlayNav", OverlayNav = __decorate([Directive({
                selector: 'ion-overlay'
            }), __metadata('design:paramtypes', [])], OverlayNav));
        }
    };
});
System.register("ionic/components/navbar/navbar", ["angular2/core", "../ion", "../icon/icon", "../toolbar/toolbar", "../../config/config", "../app/app", "../nav/view-controller", "../nav/nav-controller"], function (_export) {
    "use strict";

    var Component, Directive, Optional, ElementRef, Renderer, TemplateRef, forwardRef, Inject, ViewContainerRef, Ion, Icon, ToolbarBase, Config, IonicApp, ViewController, NavController, __decorate, __metadata, __param, BackButton, BackButtonText, ToolbarBackground, Navbar, NavbarTemplate, _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            Directive = _angular2Core.Directive;
            Optional = _angular2Core.Optional;
            ElementRef = _angular2Core.ElementRef;
            Renderer = _angular2Core.Renderer;
            TemplateRef = _angular2Core.TemplateRef;
            forwardRef = _angular2Core.forwardRef;
            Inject = _angular2Core.Inject;
            ViewContainerRef = _angular2Core.ViewContainerRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_iconIcon) {
            Icon = _iconIcon.Icon;
        }, function (_toolbarToolbar) {
            ToolbarBase = _toolbarToolbar.ToolbarBase;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_navViewController) {
            ViewController = _navViewController.ViewController;
        }, function (_navNavController) {
            NavController = _navNavController.NavController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            BackButton = (function (_Ion) {
                _inherits(BackButton, _Ion);

                function BackButton(navCtrl, elementRef, navbar) {
                    _classCallCheck(this, BackButton);

                    _get(Object.getPrototypeOf(BackButton.prototype), "constructor", this).call(this, elementRef, null);
                    this.navCtrl = navCtrl;
                    navbar && navbar.setBackButtonRef(elementRef);
                }

                _createClass(BackButton, [{
                    key: "goBack",
                    value: function goBack(ev) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        this.navCtrl && this.navCtrl.pop();
                    }
                }]);

                return BackButton;
            })(Ion);

            BackButton = __decorate([Directive({
                selector: '.back-button',
                host: {
                    '(click)': 'goBack($event)'
                }
            }), __param(0, Optional()), __param(2, Optional()), __param(2, Inject(forwardRef(function () {
                return Navbar;
            }))), __metadata('design:paramtypes', [typeof (_a = typeof NavController !== 'undefined' && NavController) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, Navbar])], BackButton);

            BackButtonText = function BackButtonText(elementRef, navbar) {
                _classCallCheck(this, BackButtonText);

                navbar.setBackButtonTextRef(elementRef);
            };

            BackButtonText = __decorate([Directive({
                selector: '.back-button-text'
            }), __param(1, Inject(forwardRef(function () {
                return Navbar;
            }))), __metadata('design:paramtypes', [typeof (_c = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _c || Object, Navbar])], BackButtonText);

            ToolbarBackground = function ToolbarBackground(elementRef, navbar) {
                _classCallCheck(this, ToolbarBackground);

                navbar.setBackgroundRef(elementRef);
            };

            ToolbarBackground = __decorate([Directive({
                selector: '.toolbar-background'
            }), __param(1, Inject(forwardRef(function () {
                return Navbar;
            }))), __metadata('design:paramtypes', [typeof (_d = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _d || Object, Navbar])], ToolbarBackground);
            /**
             * @name Navbar
             * @description
             * Navbar is a global level toolbar that gets updated every time a page gets
             * loaded. You can pass the navbar a `ion-title` or any number of buttons.
             *
             * @usage
             * ```html
             * <ion-navbar *navbar>
             *
             *   <ion-buttons>
             *     <button (click)="toggleItems()">
             *       toggle
             *     </button>
             *   </ion-buttons>
             *
             *   <ion-title>
             *     Page Title
             *   </ion-title>
             *
             *   <ion-buttons>
             *     <button (click)="openModal()">
             *       Modal
             *     </button>
             *   </ion-buttons>
             * </ion-navbar>
             * ```
             *
             * @see {@link ../../toolbar/Toolbar/ Toolbar API Docs}
             */

            Navbar = (function (_ToolbarBase) {
                _inherits(Navbar, _ToolbarBase);

                function Navbar(app, viewCtrl, elementRef, config, renderer) {
                    _classCallCheck(this, Navbar);

                    _get(Object.getPrototypeOf(Navbar.prototype), "constructor", this).call(this, elementRef, config);
                    this.app = app;
                    this.renderer = renderer;
                    viewCtrl && viewCtrl.setNavbar(this);
                    this.bbIcon = config.get('backButtonIcon');
                    this.bbText = config.get('backButtonText');
                }

                /**
                 * @private
                 */

                _createClass(Navbar, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        _get(Object.getPrototypeOf(Navbar.prototype), "ngOnInit", this).call(this);
                        var hideBackButton = this.hideBackButton;
                        if (typeof hideBackButton === 'string') {
                            this.hideBackButton = hideBackButton === '' || hideBackButton === 'true';
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getBackButtonRef",
                    value: function getBackButtonRef() {
                        return this.bbRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setBackButtonRef",
                    value: function setBackButtonRef(backButtonElementRef) {
                        this.bbRef = backButtonElementRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getBackButtonTextRef",
                    value: function getBackButtonTextRef() {
                        return this.bbtRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setBackButtonTextRef",
                    value: function setBackButtonTextRef(backButtonTextElementRef) {
                        this.bbtRef = backButtonTextElementRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setBackgroundRef",
                    value: function setBackgroundRef(backgrouneElementRef) {
                        this.bgRef = backgrouneElementRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getBackgroundRef",
                    value: function getBackgroundRef() {
                        return this.bgRef;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "didEnter",
                    value: function didEnter() {
                        try {
                            this.app.setTitle(this.getTitleText());
                        } catch (e) {
                            console.error(e);
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setHidden",
                    value: function setHidden(isHidden) {
                        this._hidden = isHidden;
                    }
                }]);

                return Navbar;
            })(ToolbarBase);

            _export("Navbar", Navbar);

            _export("Navbar", Navbar = __decorate([Component({
                selector: 'ion-navbar',
                template: '<div class="toolbar-background"></div>' + '<button class="back-button bar-button bar-button-default" [hidden]="hideBackButton">' + '<ion-icon class="back-button-icon" [name]="bbIcon"></ion-icon>' + '<span class="back-button-text">' + '<span class="back-default">{{bbText}}</span>' + '</span>' + '</button>' + '<ng-content select="[menuToggle],ion-buttons[left]"></ng-content>' + '<ng-content select="ion-buttons[start]"></ng-content>' + '<ng-content select="ion-buttons[end],ion-buttons[right]"></ng-content>' + '<div class="toolbar-content">' + '<ng-content></ng-content>' + '</div>',
                host: {
                    '[hidden]': '_hidden',
                    'class': 'toolbar'
                },
                inputs: ['hideBackButton'],
                directives: [BackButton, BackButtonText, Icon, ToolbarBackground]
            }), __param(1, Optional()), __metadata('design:paramtypes', [typeof (_e = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _e || Object, typeof (_f = typeof ViewController !== 'undefined' && ViewController) === 'function' && _f || Object, typeof (_g = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _g || Object, typeof (_h = typeof Config !== 'undefined' && Config) === 'function' && _h || Object, typeof (_j = typeof Renderer !== 'undefined' && Renderer) === 'function' && _j || Object])], Navbar));
            /**
             * @private
             * Used to find and register headers in a view, and this directive's
             * content will be moved up to the common navbar location, and created
             * using the same context as the view's content area.
            */

            NavbarTemplate = function NavbarTemplate(viewContainerRef, templateRef, viewCtrl) {
                _classCallCheck(this, NavbarTemplate);

                if (viewCtrl) {
                    viewCtrl.setNavbarTemplateRef(templateRef);
                    viewCtrl.setNavbarViewRef(viewContainerRef);
                }
            };

            _export("NavbarTemplate", NavbarTemplate);

            _export("NavbarTemplate", NavbarTemplate = __decorate([Directive({
                selector: 'template[navbar]'
            }), __param(2, Optional()), __metadata('design:paramtypes', [typeof (_k = typeof ViewContainerRef !== 'undefined' && ViewContainerRef) === 'function' && _k || Object, typeof (_l = typeof TemplateRef !== 'undefined' && TemplateRef) === 'function' && _l || Object, typeof (_m = typeof ViewController !== 'undefined' && ViewController) === 'function' && _m || Object])], NavbarTemplate));
        }
    };
});
System.register("ionic/components/radio/radio", ["angular2/core", "angular2/common", "../list/list", "../../util/form", "../../util/util"], function (_export) {
    /**
     * @description
     * A radio button with a unique value. Note that all `<ion-radio>` components
     * must be wrapped within a `<ion-list radio-group>`, and there must be at
     * least two `<ion-radio>` components within the radio group.
     *
     * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/forms/) for more info on forms and input.
     *
     * @usage
     * ```html
     * <ion-radio value="my-value" checked="true">
     *   Radio Label
     * </ion-radio>
     * ```
     * @demo /docs/v3/demos/radio/
     * @see {@link /docs/v3/components#radio Radio Component Docs}
     */
    "use strict";

    var Component, Directive, ElementRef, Renderer, Optional, Input, Output, HostListener, ContentChildren, ContentChild, EventEmitter, NgControl, ListHeader, Form, isDefined, __decorate, __metadata, __param, RadioButton, RadioGroup, radioGroupIds, _a, _b, _c, _d, _e, _f, _g, _h;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            Directive = _angular2Core.Directive;
            ElementRef = _angular2Core.ElementRef;
            Renderer = _angular2Core.Renderer;
            Optional = _angular2Core.Optional;
            Input = _angular2Core.Input;
            Output = _angular2Core.Output;
            HostListener = _angular2Core.HostListener;
            ContentChildren = _angular2Core.ContentChildren;
            ContentChild = _angular2Core.ContentChild;
            EventEmitter = _angular2Core.EventEmitter;
        }, function (_angular2Common) {
            NgControl = _angular2Common.NgControl;
        }, function (_listList) {
            ListHeader = _listList.ListHeader;
        }, function (_utilForm) {
            Form = _utilForm.Form;
        }, function (_utilUtil) {
            isDefined = _utilUtil.isDefined;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            RadioButton = (function () {
                function RadioButton(_form, _renderer, _elementRef) {
                    _classCallCheck(this, RadioButton);

                    this._form = _form;
                    this._renderer = _renderer;
                    this._elementRef = _elementRef;
                    this.value = '';
                    this.checked = false;
                    this.disabled = false;
                    this.select = new EventEmitter();
                    _form.register(this);
                }

                /**
                 * @private
                 */

                _createClass(RadioButton, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        if (!this.id) {
                            this.id = 'rb-' + this._form.nextId();
                            this._renderer.setElementAttribute(this._elementRef, 'id', this.id);
                        }
                        this.labelId = 'lbl-' + this.id;
                        this._renderer.setElementAttribute(this._elementRef, 'aria-labelledby', this.labelId);
                        var checked = this.checked;
                        if (typeof checked === 'string') {
                            this.checked = checked === '' || checked === 'true';
                        }
                        this.isChecked = this.checked;
                        this._renderer.setElementAttribute(this._elementRef, 'checked', null);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_click",
                    value: function _click() {
                        console.debug('RadioButton, select', this.value);
                        this.select.emit(this);
                    }
                }, {
                    key: "ngOnDestroy",

                    /**
                     * @private
                     */
                    value: function ngOnDestroy() {
                        this._form.deregister(this);
                    }
                }, {
                    key: "isChecked",
                    set: function set(isChecked) {
                        this._renderer.setElementAttribute(this._elementRef, 'aria-checked', isChecked);
                    }
                }]);

                return RadioButton;
            })();

            _export("RadioButton", RadioButton);

            __decorate([Input(), __metadata('design:type', String)], RadioButton.prototype, "value", void 0);
            __decorate([Input(), __metadata('design:type', Object)], RadioButton.prototype, "checked", void 0);
            __decorate([Input(), __metadata('design:type', Boolean)], RadioButton.prototype, "disabled", void 0);
            __decorate([Input(), __metadata('design:type', String)], RadioButton.prototype, "id", void 0);
            __decorate([Output(), __metadata('design:type', typeof (_a = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _a || Object)], RadioButton.prototype, "select", void 0);
            __decorate([HostListener('click'), __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], RadioButton.prototype, "_click", null);
            _export("RadioButton", RadioButton = __decorate([Component({
                selector: 'ion-radio',
                host: {
                    'role': 'radio',
                    'class': 'item',
                    'tappable': '',
                    'tabindex': 0,
                    '[attr.aria-disabled]': 'disabled'
                },
                template: '<div class="item-inner">' + '<ion-item-content id="{{labelId}}">' + '<ng-content></ng-content>' + '</ion-item-content>' + '<div class="radio-media">' + '<div class="radio-icon"></div>' + '</div>' + '</div>'
            }), __metadata('design:paramtypes', [typeof (_b = typeof Form !== 'undefined' && Form) === 'function' && _b || Object, typeof (_c = typeof Renderer !== 'undefined' && Renderer) === 'function' && _c || Object, typeof (_d = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _d || Object])], RadioButton));
            /**
             * A radio group is a group of radio components.
             *
             * Selecting a radio button in the group unselects all others in the group.
             *
             * New radios can be registered dynamically.
             *
             * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/forms/) for more info on forms and input.
             *
             * @usage
             * ```html
             * <ion-list radio-group ngControl="autoManufacturers">
             *
             *   <ion-list-header>
             *     Auto Manufacturers
             *   </ion-list-header>
             *
             *   <ion-radio value="cord">
             *     Cord
             *   </ion-radio>
             *
             *   <ion-radio value="duesenberg" checked="true">
             *     Duesenberg
             *   </ion-radio>
             *
             *   <ion-radio value="hudson">
             *     Hudson
             *   </ion-radio>
             *
             *   <ion-radio value="packard">
             *     Packard
             *   </ion-radio>
             *
             *   <ion-radio value="studebaker">
             *     Studebaker
             *   </ion-radio>
             *
             *   <ion-radio value="tucker">
             *     Tucker
             *   </ion-radio>
             *
             * </ion-list>
             * ```
             * @demo /docs/v3/demos/radio/
             * @see {@link /docs/v3/components#radio Radio Component Docs}
            */

            RadioGroup = (function () {
                function RadioGroup(ngControl, _renderer, _elementRef) {
                    _classCallCheck(this, RadioGroup);

                    this._renderer = _renderer;
                    this._elementRef = _elementRef;
                    this.change = new EventEmitter();
                    this.id = ++radioGroupIds;
                    if (ngControl) {
                        ngControl.valueAccessor = this;
                    }
                }

                /**
                 * @private
                 * Angular2 Forms API method called by the model (Control) on change to update
                 * the checked value.
                 * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L34
                 */

                _createClass(RadioGroup, [{
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.value = isDefined(value) ? value : '';
                        if (this._buttons) {
                            var buttons = this._buttons.toArray();
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = buttons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var button = _step.value;

                                    var isChecked = button.value === this.value;
                                    button.isChecked = isChecked;
                                    if (isChecked) {
                                        this._renderer.setElementAttribute(this._elementRef, 'aria-activedescendant', button.id);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                                        _iterator["return"]();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "onChange",
                    value: function onChange(val) {}
                    // TODO: figure the whys and the becauses

                    /**
                     * @private
                     */

                }, {
                    key: "onTouched",
                    value: function onTouched(val) {}
                    // TODO: figure the whys and the becauses

                    /**
                     * @private
                     * Angular2 Forms API method called by the view (NgControl) to register the
                     * onChange event handler that updates the model (Control).
                     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L27
                     * @param {Function} fn  the onChange event handler.
                     */

                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the the view (NgControl) to register
                     * the onTouched event handler that marks the model (Control) as touched.
                     * @param {Function} fn  onTouched event handler.
                     */
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "ngAfterContentInit",
                    value: function ngAfterContentInit() {
                        var _this = this;

                        var header = this._header;
                        if (header) {
                            if (!header.id) {
                                header.id = 'rg-hdr-' + this.id;
                            }
                            this._renderer.setElementAttribute(this._elementRef, 'aria-describedby', header.id);
                        }
                        var buttons = this._buttons.toArray();
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            var _loop = function () {
                                var button = _step2.value;

                                button.select.subscribe(function () {
                                    _this.writeValue(button.value);
                                    _this.onChange(button.value);
                                    _this.change.emit(_this);
                                });
                                if (isDefined(_this.value)) {
                                    var isChecked = button.value === _this.value || button.checked;
                                    button.isChecked = isChecked;
                                    if (isChecked) {
                                        _this.writeValue(button.value);
                                        //this.onChange(button.value);
                                        _this._renderer.setElementAttribute(_this._elementRef, 'aria-activedescendant', button.id);
                                    }
                                }
                            };

                            for (var _iterator2 = buttons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                _loop();
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                    _iterator2["return"]();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }
                }]);

                return RadioGroup;
            })();

            _export("RadioGroup", RadioGroup);

            __decorate([Output(), __metadata('design:type', typeof (_e = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _e || Object)], RadioGroup.prototype, "change", void 0);
            __decorate([ContentChildren(RadioButton), __metadata('design:type', Object)], RadioGroup.prototype, "_buttons", void 0);
            __decorate([ContentChild(ListHeader), __metadata('design:type', Object)], RadioGroup.prototype, "_header", void 0);
            _export("RadioGroup", RadioGroup = __decorate([Directive({
                selector: '[radio-group]',
                host: {
                    '[attr.aria-activedescendant]': 'activeId',
                    'role': 'radiogroup'
                }
            }), __param(0, Optional()), __metadata('design:paramtypes', [typeof (_f = typeof NgControl !== 'undefined' && NgControl) === 'function' && _f || Object, typeof (_g = typeof Renderer !== 'undefined' && Renderer) === 'function' && _g || Object, typeof (_h = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _h || Object])], RadioGroup));
            radioGroupIds = -1;
        }
    };
});
System.register("ionic/components/scroll/pull-to-refresh", ["angular2/core", "angular2/common", "../content/content", "../../util", "../../util/dom"], function (_export) {
    /**
     * @name Refresher
     * @description
     * Allows you to add pull-to-refresh to an Content component.
     * Place it as the first child of your Content or Scroll element.
     *
     * When refreshing is complete, call `refresher.complete()` from your controller.
     *
     *  @usage
     *  ```html
     *  <ion-content>
     *    <ion-refresher (starting)="doStarting()"
     *                   (refresh)="doRefresh($event, refresher)"
     *                   (pulling)="doPulling($event, amt)">
     *    </ion-refresher>
     *
     *  </ion-content>
    
     *  ```
     *
     *  ```ts
     *  export class MyClass {
     *  constructor(){}
     *    doRefresh(refresher) {
     *      console.log('Refreshing!', refresher);
     *
     *      setTimeout(() => {
     *        console.log('Pull to refresh complete!', refresher);
     *        refresher.complete();
     *      })
     *    }
     *
     *    doStarting() {
     *      console.log('Pull started!');
     *    }
     *
     *    doPulling(amt) {
     *      console.log('You have pulled', amt);
     *    }
     *  }
     *  ```
     *  @demo /docs/v3/demos/refresher/
     *
     *  @property {string} [pullingIcon] - the icon you want to display when you begin to pull down
     *  @property {string} [pullingText] - the text you want to display when you begin to pull down
     *  @property {string} [refreshingIcon] - the icon you want to display when performing a refresh
     *  @property {string} [refreshingText] - the text you want to display when performing a refresh
     *
     *  @property {any} (refresh) - the methond on your class you want to perform when you refreshing
     *  @property {any} (starting) - the methond on your class you want to perform when you start pulling down
     *  @property {any} (pulling) - the methond on your class you want to perform when you are pulling down
     *
     */
    "use strict";

    var Component, ElementRef, EventEmitter, Host, NgIf, NgClass, Content, util, raf, CSS, __decorate, __metadata, __param, Refresher, _a, _b;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            ElementRef = _angular2Core.ElementRef;
            EventEmitter = _angular2Core.EventEmitter;
            Host = _angular2Core.Host;
        }, function (_angular2Common) {
            NgIf = _angular2Common.NgIf;
            NgClass = _angular2Common.NgClass;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_util) {
            util = _util;
        }, function (_utilDom) {
            raf = _utilDom.raf;
            CSS = _utilDom.CSS;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Refresher = (function () {
                /**
                 * @private
                 * @param {Content} content  TODO
                 * @param {ElementRef} elementRef  TODO
                 */

                function Refresher(content, element) {
                    _classCallCheck(this, Refresher);

                    this.ele = element.nativeElement;
                    this.ele.classList.add('content');
                    this.content = content;
                    this.refresh = new EventEmitter('refresh');
                    this.starting = new EventEmitter('starting');
                    this.pulling = new EventEmitter('pulling');
                }

                /**
                 * @private
                 */

                _createClass(Refresher, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        this.initEvents();
                    }

                    /**
                     * @private
                     * Initialize touch and scroll event listeners.
                     */
                }, {
                    key: "initEvents",
                    value: function initEvents() {
                        var sp = this.content.getNativeElement();
                        var sc = this.content.scrollElement;
                        this.isDragging = false;
                        this.isOverscrolling = false;
                        this.dragOffset = 0;
                        this.lastOverscroll = 0;
                        this.ptrThreshold = 60;
                        this.activated = false;
                        this.scrollTime = 500;
                        this.startY = null;
                        this.deltaY = null;
                        this.canOverscroll = true;
                        this.scrollHost = sp;
                        this.scrollChild = sc;
                        util.defaults(this, {
                            pullingIcon: 'ion-android-arrow-down',
                            refreshingIcon: 'ion-ionic'
                        });
                        this.showSpinner = !util.isDefined(this.refreshingIcon) && this.spinner != 'none';
                        this.showIcon = util.isDefined(this.refreshingIcon);
                        this._touchMoveListener = this._handleTouchMove.bind(this);
                        this._touchEndListener = this._handleTouchEnd.bind(this);
                        this._handleScrollListener = this._handleScroll.bind(this);
                        sc.addEventListener('touchmove', this._touchMoveListener);
                        sc.addEventListener('touchend', this._touchEndListener);
                        sc.addEventListener('scroll', this._handleScrollListener);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "onDehydrate",
                    value: function onDehydrate() {
                        console.log('DEHYDRATION');
                        var sc = this.content.scrollElement;
                        sc.removeEventListener('touchmove', this._touchMoveListener);
                        sc.removeEventListener('touchend', this._touchEndListener);
                        sc.removeEventListener('scroll', this._handleScrollListener);
                    }

                    /**
                     * @private
                     * @param {TODO} val  TODO
                     */
                }, {
                    key: "overscroll",
                    value: function overscroll(val) {
                        this.scrollChild.style[CSS.transform] = 'translateY(' + val + 'px)';
                        this.lastOverscroll = val;
                    }

                    /**
                     * @private
                     * @param {TODO} target  TODO
                     * @param {TODO} newScrollTop  TODO
                     */
                }, {
                    key: "nativescroll",
                    value: function nativescroll(target, newScrollTop) {
                        // creates a scroll event that bubbles, can be cancelled, and with its view
                        // and detail property initialized to window and 1, respectively
                        target.scrollTop = newScrollTop;
                        var e = document.createEvent("UIEvents");
                        e.initUIEvent("scroll", true, true, window, 1);
                        target.dispatchEvent(e);
                    }

                    /**
                     * @private
                     * @param {TODO} enabled  TODO
                     */
                }, {
                    key: "setScrollLock",
                    value: function setScrollLock(enabled) {
                        var _this = this;

                        // set the scrollbar to be position:fixed in preparation to overscroll
                        // or remove it so the app can be natively scrolled
                        if (enabled) {
                            raf(function () {
                                _this.scrollChild.classList.add('overscroll');
                                _this.show();
                            });
                        } else {
                            raf(function () {
                                _this.scrollChild.classList.remove('overscroll');
                                _this.hide();
                                _this.deactivate();
                            });
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "activate",
                    value: function activate() {
                        //this.ele.classList.add('active');
                        this.isActive = true;
                        //this.starting.next();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "deactivate",
                    value: function deactivate() {
                        var _this2 = this;

                        // give tail 150ms to finish
                        setTimeout(function () {
                            _this2.isActive = false;
                            _this2.isRefreshing = false;
                            _this2.isRefreshingTail = false;
                            // deactivateCallback
                            if (_this2.activated) _this2.activated = false;
                        }, 150);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "start",
                    value: function start() {
                        // startCallback
                        this.isRefreshing = true;
                        this.refresh.next(this);
                        //$scope.$onRefresh();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "show",
                    value: function show() {
                        // showCallback
                        this.ele.classList.remove('invisible');
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "hide",
                    value: function hide() {
                        // showCallback
                        this.ele.classList.add('invisible');
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "tail",
                    value: function tail() {
                        // tailCallback
                        this.ele.classList.add('refreshing-tail');
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "complete",
                    value: function complete() {
                        var _this3 = this;

                        setTimeout(function () {
                            raf(_this3.tail.bind(_this3));
                            // scroll back to home during tail animation
                            _this3.scrollTo(0, _this3.scrollTime, _this3.deactivate.bind(_this3));
                            // return to native scrolling after tail animation has time to finish
                            setTimeout(function () {
                                if (_this3.isOverscrolling) {
                                    _this3.isOverscrolling = false;
                                    _this3.setScrollLock(false);
                                }
                            }, _this3.scrollTime);
                        }, this.scrollTime);
                    }

                    /**
                     * @private
                     * @param {TODO} Y  TODO
                     * @param {TODO} duration  TODO
                     * @param {Function} callback  TODO
                     */
                }, {
                    key: "scrollTo",
                    value: function scrollTo(Y, duration, callback) {
                        // scroll animation loop w/ easing
                        // credit https://gist.github.com/dezinezync/5487119
                        var start = Date.now(),
                            from = this.lastOverscroll;
                        if (from === Y) {
                            callback();
                            return; /* Prevent scrolling to the Y point if already there */
                        }
                        // decelerating to zero velocity
                        function easeOutCubic(t) {
                            return --t * t * t + 1;
                        }
                        // scroll loop
                        function scroll() {
                            var currentTime = Date.now(),
                                time = Math.min(1, (currentTime - start) / duration),

                            // where .5 would be 50% of time on a linear scale easedT gives a
                            // fraction based on the easing method
                            easedT = easeOutCubic(time);
                            this.overscroll(parseInt(easedT * (Y - from) + from, 10));
                            if (time < 1) {
                                raf(scroll.bind(this));
                            } else {
                                if (Y < 5 && Y > -5) {
                                    this.isOverscrolling = false;
                                    this.setScrollLock(false);
                                }
                                callback && callback();
                            }
                        }
                        // start scroll loop
                        raf(scroll.bind(this));
                    }

                    /**
                     * @private
                     * TODO
                     * @param {Event} e  TODO
                     */
                }, {
                    key: "_handleTouchMove",
                    value: function _handleTouchMove(e) {
                        //console.log('TOUCHMOVE', e);
                        // if multitouch or regular scroll event, get out immediately
                        if (!this.canOverscroll || e.touches.length > 1) {
                            return;
                        }
                        //if this is a new drag, keep track of where we start
                        if (this.startY === null) {
                            this.startY = parseInt(e.touches[0].screenY, 10);
                        }
                        // how far have we dragged so far?
                        this.deltaY = parseInt(e.touches[0].screenY, 10) - this.startY;
                        // if we've dragged up and back down in to native scroll territory
                        if (this.deltaY - this.dragOffset <= 0 || this.scrollHost.scrollTop !== 0) {
                            if (this.isOverscrolling) {
                                this.isOverscrolling = false;
                                this.setScrollLock(false);
                            }
                            if (this.isDragging) {
                                this.nativescroll(this.scrollHost, parseInt(this.deltaY - this.dragOffset, 10) * -1);
                            }
                            // if we're not at overscroll 0 yet, 0 out
                            if (this.lastOverscroll !== 0) {
                                this.overscroll(0);
                            }
                            return;
                        } else if (this.deltaY > 0 && this.scrollHost.scrollTop === 0 && !this.isOverscrolling) {
                            // starting overscroll, but drag started below scrollTop 0, so we need to offset the position
                            this.dragOffset = this.deltaY;
                        }
                        // prevent native scroll events while overscrolling
                        e.preventDefault();
                        // if not overscrolling yet, initiate overscrolling
                        if (!this.isOverscrolling) {
                            this.isOverscrolling = true;
                            this.setScrollLock(true);
                        }
                        this.isDragging = true;
                        // overscroll according to the user's drag so far
                        this.overscroll(parseInt((this.deltaY - this.dragOffset) / 3, 10));
                        // Pass an incremental pull amount to the EventEmitter
                        this.pulling.next(this.lastOverscroll);
                        // update the icon accordingly
                        if (!this.activated && this.lastOverscroll > this.ptrThreshold) {
                            this.activated = true;
                            raf(this.activate.bind(this));
                        } else if (this.activated && this.lastOverscroll < this.ptrThreshold) {
                            this.activated = false;
                            raf(this.deactivate.bind(this));
                        }
                    }

                    /**
                     * @private
                     * TODO
                     * @param {Event} e  TODO
                     */
                }, {
                    key: "_handleTouchEnd",
                    value: function _handleTouchEnd(e) {
                        console.log('TOUCHEND', e);
                        // if this wasn't an overscroll, get out immediately
                        if (!this.canOverscroll && !this.isDragging) {
                            return;
                        }
                        // reset Y
                        this.startY = null;
                        // the user has overscrolled but went back to native scrolling
                        if (!this.isDragging) {
                            this.dragOffset = 0;
                            this.isOverscrolling = false;
                            this.setScrollLock(false);
                        } else {
                            this.isDragging = false;
                            this.dragOffset = 0;
                            // the user has scroll far enough to trigger a refresh
                            if (this.lastOverscroll > this.ptrThreshold) {
                                this.start();
                                this.scrollTo(this.ptrThreshold, this.scrollTime);
                            } else {
                                this.scrollTo(0, this.scrollTime, this.deactivate.bind(this));
                                this.isOverscrolling = false;
                            }
                        }
                    }

                    /**
                     * @private
                     * TODO
                     * @param {Event} e  TODO
                     */
                }, {
                    key: "_handleScroll",
                    value: function _handleScroll(e) {
                        console.log('SCROLL', e.target.scrollTop);
                    }
                }]);

                return Refresher;
            })();

            _export("Refresher", Refresher);

            _export("Refresher", Refresher = __decorate([Component({
                selector: 'ion-refresher',
                inputs: ['pullingIcon', 'pullingText', 'refreshingIcon', 'refreshingText', 'spinner', 'disablePullingRotation'],
                outputs: ['refresh', 'starting', 'pulling'],
                host: {
                    '[class.active]': 'isActive',
                    '[class.refreshing]': 'isRefreshing',
                    '[class.refreshingTail]': 'isRefreshingTail'
                },
                template: '<div class="refresher-content" [class.refresher-with-text]="pullingText || refreshingText">' + '<div class="icon-pulling">' + '<i class="icon" [ngClass]="pullingIcon"></i>' + '</div>' + '<div class="text-pulling" [innerHTML]="pullingText" *ngIf="pullingText"></div>' + '<div class="icon-refreshing">' + '<i class="icon" [ngClass]="refreshingIcon"></i>' + '</div>' + '<div class="text-refreshing" [innerHTML]="refreshingText" *ngIf="refreshingText"></div>' + '</div>',
                directives: [NgIf, NgClass]
            }), __param(0, Host()), __metadata('design:paramtypes', [typeof (_a = typeof Content !== 'undefined' && Content) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object])], Refresher));
        }
    };
});
System.register("ionic/components/scroll/scroll", ["angular2/core", "../ion", "../../config/config"], function (_export) {
    /**
     * @name Scroll
     * @description
     * Scroll is a non-flexboxed scroll area that can scroll horizontally or vertically. `ion-Scroll` Can be used in places were you may not need a full page scroller, but a highly customized one, such as image scubber or comment scroller.
     * @usage
     * ```html
     * <ion-scroll scroll-x="true">
     * </ion-scroll>
     *
     * <ion-scroll scroll-y="true">
     * </ion-scroll>
     *
     * <ion-scroll scroll-x="true" scroll-y="true">
     * </ion-scroll>
     * ```
     *@property {boolean} [scroll-x] - whether to enable scrolling along the X axis
     *@property {boolean} [scroll-y] - whether to enable scrolling along the Y axis
     *@property {boolean} [zoom] - whether to enable zooming
     *@property {number} [max-zoom] - set the max zoom amount for ion-scroll
     * @demo /docs/v3/demos/scroll/
     */
    "use strict";

    var Component, ElementRef, Ion, Config, __decorate, __metadata, Scroll, _a, _b;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            ElementRef = _angular2Core.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Scroll = (function (_Ion) {
                _inherits(Scroll, _Ion);

                function Scroll(elementRef, Config) {
                    _classCallCheck(this, Scroll);

                    _get(Object.getPrototypeOf(Scroll.prototype), "constructor", this).call(this, elementRef, Config);
                    this.maxScale = 3;
                    this.zoomDuration = 250;
                }

                /**
                 * @private
                 */

                _createClass(Scroll, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        this.scrollElement = this.getNativeElement().children[0];
                    }

                    /**
                     * Add a scroll event handler to the scroll element if it exists.
                     * @param {Function} handler  The scroll handler to add to the scroll element.
                     * @returns {?Function} a function to remove the specified handler, otherwise
                     * undefined if the scroll element doesn't exist.
                     */
                }, {
                    key: "addScrollEventListener",
                    value: function addScrollEventListener(handler) {
                        var _this = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        this.scrollElement.addEventListener('scroll', handler);
                        return function () {
                            _this.scrollElement.removeEventListener('scroll', handler);
                        };
                    }
                }]);

                return Scroll;
            })(Ion);

            _export("Scroll", Scroll);

            _export("Scroll", Scroll = __decorate([Component({
                selector: 'ion-scroll',
                inputs: ['scrollX', 'scrollY', 'zoom', 'maxZoom'],
                host: {
                    '[class.scroll-x]': 'scrollX',
                    '[class.scroll-y]': 'scrollY'
                },
                template: '<scroll-content>' + '<div class="scroll-zoom-wrapper">' + '<ng-content></ng-content>' + '</div>' + '</scroll-content>'
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof Config !== 'undefined' && Config) === 'function' && _b || Object])], Scroll));
        }
    };
});
System.register("ionic/components/searchbar/searchbar", ["angular2/core", "angular2/common", "../ion", "../../config/config", "../icon/icon", "../button/button", "../../util/util"], function (_export) {
    /**
    * @private
    */
    "use strict";

    var ElementRef, Component, Directive, HostBinding, HostListener, ViewChild, Input, Output, EventEmitter, Optional, NgIf, NgClass, NgControl, FORM_DIRECTIVES, Ion, Config, Icon, Button, isDefined, __decorate, __metadata, __param, SearchbarInput, Searchbar, _a, _b, _c, _d, _e, _f, _g, _h, _j;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            ElementRef = _angular2Core.ElementRef;
            Component = _angular2Core.Component;
            Directive = _angular2Core.Directive;
            HostBinding = _angular2Core.HostBinding;
            HostListener = _angular2Core.HostListener;
            ViewChild = _angular2Core.ViewChild;
            Input = _angular2Core.Input;
            Output = _angular2Core.Output;
            EventEmitter = _angular2Core.EventEmitter;
            Optional = _angular2Core.Optional;
        }, function (_angular2Common) {
            NgIf = _angular2Common.NgIf;
            NgClass = _angular2Common.NgClass;
            NgControl = _angular2Common.NgControl;
            FORM_DIRECTIVES = _angular2Common.FORM_DIRECTIVES;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_iconIcon) {
            Icon = _iconIcon.Icon;
        }, function (_buttonButton) {
            Button = _buttonButton.Button;
        }, function (_utilUtil) {
            isDefined = _utilUtil.isDefined;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            SearchbarInput = (function () {
                function SearchbarInput(_elementRef) {
                    _classCallCheck(this, SearchbarInput);

                    this._elementRef = _elementRef;
                }

                _createClass(SearchbarInput, [{
                    key: "stopInput",
                    value: function stopInput(ev) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }]);

                return SearchbarInput;
            })();

            _export("SearchbarInput", SearchbarInput);

            __decorate([HostListener('input', ['$event']), __metadata('design:type', Function), __metadata('design:paramtypes', [Object]), __metadata('design:returntype', void 0)], SearchbarInput.prototype, "stopInput", null);
            _export("SearchbarInput", SearchbarInput = __decorate([Directive({
                selector: '.searchbar-input'
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object])], SearchbarInput));
            /**
             * @name Searchbar
             * @module ionic
             * @description
             * Manages the display of a Searchbar which can be used to search or filter items.
             *
             * @usage
             * ```html
             * <ion-searchbar [(ngModel)]="defaultSearch" (input)="triggerInput($event)" (cancel)="onCancelSearchbar($event)" (clear)="onClearSearchbar($event)"></ion-searchbar>
             * ```
             *
             * @property {string} [cancelButtonText=Cancel] - Sets the cancel button text to the value passed in
             * @property {boolean} [hideCancelButton=false] - Hides the cancel button
             * @property {string} [placeholder=Search] - Sets input placeholder to the value passed in
             *
             * @property {Any} [input] - Expression to evaluate when the Searchbar input has changed including cleared
             * @property {Any} [keydown] - Expression to evaluate when a key is pushed down in the Searchbar input
             * @property {Any} [keypress] - Expression to evaluate when a character is inserted in the Searchbar input
             * @property {Any} [keyup] - Expression to evaluate when a key is released in the Searchbar input
             * @property {Any} [blur] - Expression to evaluate when the Searchbar input has blurred
             * @property {Any} [focus] - Expression to evaluate when the Searchbar input has focused
             * @property {Any} [cancel] - Expression to evaluate when the cancel button is clicked
             * @property {Any} [clear] - Expression to evaluate when the clear input button is clicked
             *
             * @see {@link /docs/v3/components#searchbar Searchbar Component Docs}
             */

            Searchbar = (function (_Ion) {
                _inherits(Searchbar, _Ion);

                function Searchbar(_elementRef, _config, ngControl) {
                    _classCallCheck(this, Searchbar);

                    _get(Object.getPrototypeOf(Searchbar.prototype), "constructor", this).call(this, _elementRef, _config);
                    this._elementRef = _elementRef;
                    this._config = _config;
                    /**
                     * @private
                     */
                    this.input = new EventEmitter();
                    /**
                     * @private
                     */
                    this.blur = new EventEmitter();
                    /**
                     * @private
                     */
                    this.focus = new EventEmitter();
                    /**
                     * @private
                     */
                    this.cancel = new EventEmitter();
                    /**
                     * @private
                     */
                    this.clear = new EventEmitter();
                    this.value = '';
                    this.blurInput = true;
                    this.onChange = function (_) {};
                    this.onTouched = function () {};
                    // If the user passed a ngControl we need to set the valueAccessor
                    if (ngControl) {
                        ngControl.valueAccessor = this;
                    }
                }

                /**
                 * @private
                 * On Initialization check for attributes
                 */

                _createClass(Searchbar, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        this.mode = this._config.get('mode');
                        var hideCancelButton = this.hideCancelButton;
                        if (typeof hideCancelButton === 'string') {
                            this.hideCancelButton = hideCancelButton === '' || hideCancelButton === 'true';
                        }
                        this.cancelButtonText = this.cancelButtonText || 'Cancel';
                        this.placeholder = this.placeholder || 'Search';
                        if (this.ngModel) this.value = this.ngModel;
                        this.onChange(this.value);
                        this.shouldLeftAlign = this.value && this.value.trim() != '';
                        // Using querySelector instead of searchbarInput because at this point it doesn't exist
                        this.inputElement = this._elementRef.nativeElement.querySelector('.searchbar-input');
                        this.searchIconElement = this._elementRef.nativeElement.querySelector('.searchbar-search-icon');
                        this.setElementLeft();
                    }

                    /**
                     * @private
                     * After View Initialization check the value
                     */
                }, {
                    key: "ngAfterViewInit",
                    value: function ngAfterViewInit() {
                        // If the user passes an undefined variable to ngModel this will warn
                        // and set the value to an empty string
                        if (!isDefined(this.value)) {
                            console.warn('Searchbar was passed an undefined value in ngModel. Please make sure the variable is defined.');
                            this.value = '';
                            this.onChange(this.value);
                        }
                    }

                    /**
                     * @private
                     * Determines whether or not to add style to the element
                     * to center it properly (ios only)
                     */
                }, {
                    key: "setElementLeft",
                    value: function setElementLeft() {
                        if (this.mode !== 'ios') return;
                        if (this.shouldLeftAlign) {
                            this.inputElement.removeAttribute("style");
                            this.searchIconElement.removeAttribute("style");
                        } else {
                            this.addElementLeft();
                        }
                    }

                    /**
                     * @private
                     * Calculates the amount of padding/margin left for the elements
                     * in order to center them based on the placeholder width
                     */
                }, {
                    key: "addElementLeft",
                    value: function addElementLeft() {
                        // Create a dummy span to get the placeholder width
                        var tempSpan = document.createElement('span');
                        tempSpan.innerHTML = this.placeholder;
                        document.body.appendChild(tempSpan);
                        // Get the width of the span then remove it
                        var textWidth = tempSpan.offsetWidth;
                        tempSpan.remove();
                        // Set the input padding left
                        var inputLeft = "calc(50% - " + textWidth / 2 + "px)";
                        this.inputElement.style.paddingLeft = inputLeft;
                        // Set the icon margin left
                        var iconLeft = "calc(50% - " + (textWidth / 2 + this.searchIconElement.offsetWidth + 15) + "px)";
                        this.searchIconElement.style.marginLeft = iconLeft;
                    }

                    /**
                     * @private
                     * Update the Searchbar input value when the input changes
                     */
                }, {
                    key: "inputChanged",
                    value: function inputChanged(ev) {
                        this.value = ev.target.value;
                        this.onChange(this.value);
                        this.input.emit(this);
                    }

                    /**
                     * @private
                     * Sets the Searchbar to focused and aligned left on input focus.
                     */
                }, {
                    key: "inputFocused",
                    value: function inputFocused() {
                        this.focus.emit(this);
                        this.isFocused = true;
                        this.shouldLeftAlign = true;
                        this.setElementLeft();
                    }

                    /**
                     * @private
                     * Sets the Searchbar to not focused and checks if it should align left
                     * based on whether there is a value in the searchbar or not.
                     */
                }, {
                    key: "inputBlurred",
                    value: function inputBlurred() {
                        // blurInput determines if it should blur
                        // if we are clearing the input we still want to stay focused in the input
                        if (this.blurInput == false) {
                            this.searchbarInput._elementRef.nativeElement.focus();
                            this.blurInput = true;
                            return;
                        }
                        this.blur.emit(this);
                        this.isFocused = false;
                        this.shouldLeftAlign = this.value && this.value.trim() != '';
                        this.setElementLeft();
                    }

                    /**
                     * @private
                     * Clears the input field and triggers the control change.
                     */
                }, {
                    key: "clearInput",
                    value: function clearInput() {
                        this.clear.emit(this);
                        this.value = '';
                        this.onChange(this.value);
                        this.input.emit(this);
                        this.blurInput = false;
                    }

                    /**
                     * @private
                     * Clears the input field and tells the input to blur since
                     * the clearInput function doesn't want the input to blur
                     * then calls the custom cancel function if the user passed one in.
                     */
                }, {
                    key: "cancelSearchbar",
                    value: function cancelSearchbar() {
                        this.cancel.emit(this);
                        this.clearInput();
                        this.blurInput = true;
                    }

                    /**
                     * @private
                     * Write a new value to the element.
                     */
                }, {
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.value = value;
                    }

                    /**
                     * @private
                     * Set the function to be called when the control receives a change event.
                     */
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }

                    /**
                     * @private
                     * Set the function to be called when the control receives a touch event.
                     */
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return Searchbar;
            })(Ion);

            _export("Searchbar", Searchbar);

            __decorate([ViewChild(SearchbarInput), __metadata('design:type', Object)], Searchbar.prototype, "searchbarInput", void 0);
            __decorate([Input(), __metadata('design:type', String)], Searchbar.prototype, "cancelButtonText", void 0);
            __decorate([Input(), __metadata('design:type', Object)], Searchbar.prototype, "hideCancelButton", void 0);
            __decorate([Input(), __metadata('design:type', String)], Searchbar.prototype, "placeholder", void 0);
            __decorate([Input(), __metadata('design:type', Object)], Searchbar.prototype, "ngModel", void 0);
            __decorate([Output(), __metadata('design:type', typeof (_b = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _b || Object)], Searchbar.prototype, "input", void 0);
            __decorate([Output(), __metadata('design:type', typeof (_c = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _c || Object)], Searchbar.prototype, "blur", void 0);
            __decorate([Output(), __metadata('design:type', typeof (_d = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _d || Object)], Searchbar.prototype, "focus", void 0);
            __decorate([Output(), __metadata('design:type', typeof (_e = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _e || Object)], Searchbar.prototype, "cancel", void 0);
            __decorate([Output(), __metadata('design:type', typeof (_f = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _f || Object)], Searchbar.prototype, "clear", void 0);
            __decorate([HostBinding('class.searchbar-focused'), __metadata('design:type', Object)], Searchbar.prototype, "isFocused", void 0);
            __decorate([HostBinding('class.searchbar-left-aligned'), __metadata('design:type', Object)], Searchbar.prototype, "shouldLeftAlign", void 0);
            _export("Searchbar", Searchbar = __decorate([Component({
                selector: 'ion-searchbar',
                template: '<div class="searchbar-input-container">' + '<button (click)="cancelSearchbar()" (mousedown)="cancelSearchbar()" clear dark class="searchbar-md-cancel">' + '<ion-icon name="arrow-back"></ion-icon>' + '</button>' + '<div class="searchbar-search-icon"></div>' + '<input [value]="value" (keyup)="inputChanged($event)" (blur)="inputBlurred()" (focus)="inputFocused()" class="searchbar-input" type="search" [attr.placeholder]="placeholder">' + '<button clear *ngIf="value" class="searchbar-clear-icon" (click)="clearInput()" (mousedown)="clearInput()"></button>' + '</div>' + '<button clear (click)="cancelSearchbar()" (mousedown)="cancelSearchbar()" [hidden]="hideCancelButton" class="searchbar-ios-cancel">{{cancelButtonText}}</button>',
                directives: [FORM_DIRECTIVES, NgIf, NgClass, Icon, Button, SearchbarInput]
            }), __param(2, Optional()), __metadata('design:paramtypes', [typeof (_g = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _g || Object, typeof (_h = typeof Config !== 'undefined' && Config) === 'function' && _h || Object, typeof (_j = typeof NgControl !== 'undefined' && NgControl) === 'function' && _j || Object])], Searchbar));
        }
    };
});
System.register("ionic/components/segment/segment", ["angular2/core", "angular2/common", "../../util/util"], function (_export) {
    /**
     * @name SegmentButton
     * @description
     * The child buttons of the `ion-segment` component. Each `ion-segment-button` must have a value.
     * @property {string} [value] - the value of the segment-button. Required.
     * @usage
     * ```html
     * <ion-segment [(ngModel)]="relationship" primary>
     *   <ion-segment-button value="friends" (select)="selectedFriends()">
     *     Friends
     *   </ion-segment-button>
     *   <ion-segment-button value="enemies" (select)="selectedEnemies()">
     *     Enemies
     *   </ion-segment-button>
     * </ion-segment>
     *```
     *
     * Or with `FormBuilder`
     *
     *```html
     * <form [ngFormModel]="myForm">
     *   <ion-segment ngControl="mapStyle" danger>
     *     <ion-segment-button value="standard">
     *       Standard
     *     </ion-segment-button>
     *     <ion-segment-button value="hybrid">
     *       Hybrid
     *     </ion-segment-button>
     *     <ion-segment-button value="sat">
     *       Satellite
     *     </ion-segment-button>
     *   </ion-segment>
     * </form>
     * ```
     *
     * @property {Any} [click] - expression to evaluate when a segment button has been clicked
     *
     * @demo /docs/v3/demos/segment/
     * @see {@link /docs/v3/components#segment Segment Component Docs}
     * @see {@link /docs/api/components/segment/Segment/ Segment API Docs}
     */
    "use strict";

    var Directive, ElementRef, Renderer, Optional, EventEmitter, Input, Output, HostListener, ContentChildren, NgControl, isDefined, __decorate, __metadata, __param, SegmentButton, Segment, _a, _b, _c, _d, _e;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            ElementRef = _angular2Core.ElementRef;
            Renderer = _angular2Core.Renderer;
            Optional = _angular2Core.Optional;
            EventEmitter = _angular2Core.EventEmitter;
            Input = _angular2Core.Input;
            Output = _angular2Core.Output;
            HostListener = _angular2Core.HostListener;
            ContentChildren = _angular2Core.ContentChildren;
        }, function (_angular2Common) {
            NgControl = _angular2Common.NgControl;
        }, function (_utilUtil) {
            isDefined = _utilUtil.isDefined;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            SegmentButton = (function () {
                function SegmentButton(_renderer, _elementRef) {
                    _classCallCheck(this, SegmentButton);

                    this._renderer = _renderer;
                    this._elementRef = _elementRef;
                    this.select = new EventEmitter();
                }

                /**
                 * @private
                 * On click of a SegmentButton
                 */

                _createClass(SegmentButton, [{
                    key: "onClick",
                    value: function onClick(ev) {
                        console.debug('SegmentButton, select', this.value);
                        this.select.emit(this);
                    }
                }, {
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        if (!isDefined(this.value)) {
                            console.warn('<ion-segment-button> requires a "value" attribute');
                        }
                    }
                }, {
                    key: "isActive",
                    set: function set(isActive) {
                        this._renderer.setElementClass(this._elementRef, 'segment-activated', isActive);
                        this._renderer.setElementAttribute(this._elementRef, 'aria-pressed', isActive);
                    }
                }]);

                return SegmentButton;
            })();

            _export("SegmentButton", SegmentButton);

            __decorate([Input(), __metadata('design:type', String)], SegmentButton.prototype, "value", void 0);
            __decorate([Output(), __metadata('design:type', typeof (_a = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _a || Object)], SegmentButton.prototype, "select", void 0);
            __decorate([HostListener('click', ['$event']), __metadata('design:type', Function), __metadata('design:paramtypes', [Object]), __metadata('design:returntype', void 0)], SegmentButton.prototype, "onClick", null);
            _export("SegmentButton", SegmentButton = __decorate([Directive({
                selector: 'ion-segment-button',
                host: {
                    'tappable': '',
                    'class': 'segment-button',
                    'role': 'button'
                }
            }), __metadata('design:paramtypes', [typeof (_b = typeof Renderer !== 'undefined' && Renderer) === 'function' && _b || Object, typeof (_c = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _c || Object])], SegmentButton));
            /**
             * @name Segment
             * @description
             * A Segment is a group of buttons, sometimes known as Segmented Controls, that allow the user to interact with a compact group of a number of controls.
             * Segments provide functionality similar to tabs, selecting one will unselect all others. You should use a tab bar instead of a segmented control when you want to let the user move back and forth between distinct pages in your app.
             * You could use Angular 2's `ngModel` or `FormBuilder` API. For an overview on how `FormBuilder` works, checkout [Angular 2 Forms](http://learnangular2.com/forms/), or [Angular FormBuilder](https://angular.io/docs/ts/latest/api/common/FormBuilder-class.html)
             *
             *
             * @usage
             * ```html
             * <ion-segment [(ngModel)]="relationship" (change)="onSegmentChanged($event)" danger>
             *   <ion-segment-button value="friends">
             *     Friends
             *   </ion-segment-button>
             *   <ion-segment-button value="enemies">
             *     Enemies
             *   </ion-segment-button>
             * </ion-segment>
             *```
             *
             * Or with `FormBuilder`
             *
             *```html
             * <form [ngFormModel]="myForm">
             *   <ion-segment ngControl="mapStyle" danger>
             *     <ion-segment-button value="standard">
             *       Standard
             *     </ion-segment-button>
             *     <ion-segment-button value="hybrid">
             *       Hybrid
             *     </ion-segment-button>
             *     <ion-segment-button value="sat">
             *       Satellite
             *     </ion-segment-button>
             *   </ion-segment>
             * </form>
             * ```
             *
             * @property {Any} [change] - expression to evaluate when a segment button has been changed
             *
             * @demo /docs/v3/demos/segment/
             * @see {@link /docs/v3/components#segment Segment Component Docs}
             * @see [Angular 2 Forms](http://learnangular2.com/forms/)
             */

            Segment = (function () {
                function Segment(ngControl) {
                    _classCallCheck(this, Segment);

                    this.change = new EventEmitter();
                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    if (ngControl) {
                        ngControl.valueAccessor = this;
                    }
                }

                /**
                 * @private
                 * Write a new value to the element.
                 */

                _createClass(Segment, [{
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.value = isDefined(value) ? value : '';
                        if (this._buttons) {
                            var buttons = this._buttons.toArray();
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = buttons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var button = _step.value;

                                    button.isActive = button.value === this.value;
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                                        _iterator["return"]();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "ngAfterViewInit",
                    value: function ngAfterViewInit() {
                        var _this = this;

                        var buttons = this._buttons.toArray();
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = buttons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var button = _step2.value;

                                button.select.subscribe(function (selectedButton) {
                                    _this.writeValue(selectedButton.value);
                                    _this.onChange(selectedButton.value);
                                    _this.change.emit(selectedButton);
                                });
                                if (isDefined(this.value)) {
                                    button.isActive = button.value === this.value;
                                }
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                    _iterator2["return"]();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }

                    /**
                     * @private
                     * Set the function to be called when the control receives a change event.
                     */
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }

                    /**
                     * @private
                     * Set the function to be called when the control receives a touch event.
                     */
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return Segment;
            })();

            _export("Segment", Segment);

            __decorate([ContentChildren(SegmentButton), __metadata('design:type', Object)], Segment.prototype, "_buttons", void 0);
            __decorate([Output(), __metadata('design:type', typeof (_d = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _d || Object)], Segment.prototype, "change", void 0);
            _export("Segment", Segment = __decorate([Directive({
                selector: 'ion-segment'
            }), __param(0, Optional()), __metadata('design:paramtypes', [typeof (_e = typeof NgControl !== 'undefined' && NgControl) === 'function' && _e || Object])], Segment));
        }
    };
});
System.register("ionic/components/show-hide-when/show-hide-when", ["angular2/core", "../../platform/platform"], function (_export) {
    /**
     * @private
     */
    "use strict";

    var Directive, Attribute, NgZone, Platform, __decorate, __metadata, __param, DisplayWhen, ShowWhen, HideWhen, _a, _b, _c, _d;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            Attribute = _angular2Core.Attribute;
            NgZone = _angular2Core.NgZone;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            DisplayWhen = (function () {
                function DisplayWhen(conditions, platform, ngZone) {
                    var _this = this;

                    _classCallCheck(this, DisplayWhen);

                    this.isMatch = false;
                    this.platform = platform;
                    if (!conditions) return;
                    this.conditions = conditions.split(',');
                    // check if its one of the matching platforms first
                    // a platform does not change during the life of an app
                    for (var i = 0; i < this.conditions.length; i++) {
                        if (this.conditions[i] && platform.is(this.conditions[i])) {
                            this.isMatch = true;
                            return;
                        }
                    }
                    if (this.orientation()) {
                        // add window resize listener
                        platform.onResize(function () {
                            ngZone.run(function () {
                                _this.orientation();
                            });
                        });
                        return;
                    }
                }

                /**
                 *
                 * The `showWhen` attribute takes a string that represents a plaform or screen orientation.
                 * The element the attribute is added to will only be shown when that platform or screen orientation is active.
                 * Complements the [hideWhen attribute](../HideWhen).
                 * @usage
                 * ```html
                 * <div showWhen="ios">I am only visible on iOS!</div>
                 * ```
                 * @demo /docs/v3/demos/show-when/
                 * @see {@link ../HideWhen HideWhen API Docs}
                 */

                _createClass(DisplayWhen, [{
                    key: "orientation",
                    value: function orientation() {
                        for (var i = 0; i < this.conditions.length; i++) {
                            if (this.conditions[i] == 'portrait') {
                                this.isMatch = this.platform.isPortrait();
                                return true;
                            }
                            if (this.conditions[i] == 'landscape') {
                                this.isMatch = this.platform.isLandscape();
                                return true;
                            }
                        }
                    }
                }]);

                return DisplayWhen;
            })();

            _export("DisplayWhen", DisplayWhen);

            ShowWhen = (function (_DisplayWhen) {
                _inherits(ShowWhen, _DisplayWhen);

                function ShowWhen(showWhen, platform, ngZone) {
                    _classCallCheck(this, ShowWhen);

                    _get(Object.getPrototypeOf(ShowWhen.prototype), "constructor", this).call(this, showWhen, platform, ngZone);
                }

                /**
                 * @private
                 */

                _createClass(ShowWhen, [{
                    key: "hidden",
                    get: function get() {
                        return !this.isMatch;
                    }
                }]);

                return ShowWhen;
            })(DisplayWhen);

            _export("ShowWhen", ShowWhen);

            _export("ShowWhen", ShowWhen = __decorate([Directive({
                selector: '[showWhen]',
                host: {
                    '[hidden]': 'hidden'
                }
            }), __param(0, Attribute('showWhen')), __metadata('design:paramtypes', [String, typeof (_a = typeof Platform !== 'undefined' && Platform) === 'function' && _a || Object, typeof (_b = typeof NgZone !== 'undefined' && NgZone) === 'function' && _b || Object])], ShowWhen));
            /**
             *
             * The `hideWhen` attribute takes a string that represents a plaform or screen orientation.
             * The element the attribute is added to will only be hidden when that platform or screen orientation is active.
             * Complements the [showWhen attribute](../ShowWhen).
             * @usage
             * ```html
             * <div hideWhen="android">I am hidden on Android!</div>
             * ```
             * @demo /docs/v3/demos/hide-when/
             * @see {@link ../ShowWhen ShowWhen API Docs}
             */

            HideWhen = (function (_DisplayWhen2) {
                _inherits(HideWhen, _DisplayWhen2);

                function HideWhen(hideWhen, platform, ngZone) {
                    _classCallCheck(this, HideWhen);

                    _get(Object.getPrototypeOf(HideWhen.prototype), "constructor", this).call(this, hideWhen, platform, ngZone);
                }

                /**
                 * @private
                 */

                _createClass(HideWhen, [{
                    key: "hidden",
                    get: function get() {
                        return this.isMatch;
                    }
                }]);

                return HideWhen;
            })(DisplayWhen);

            _export("HideWhen", HideWhen);

            _export("HideWhen", HideWhen = __decorate([Directive({
                selector: '[hideWhen]',
                host: {
                    '[hidden]': 'hidden'
                }
            }), __param(0, Attribute('hideWhen')), __metadata('design:paramtypes', [String, typeof (_c = typeof Platform !== 'undefined' && Platform) === 'function' && _c || Object, typeof (_d = typeof NgZone !== 'undefined' && NgZone) === 'function' && _d || Object])], HideWhen));
        }
    };
});
System.register("ionic/components/slides/slides", ["angular2/core", "angular2/common", "../ion", "../../animations/animation", "../../gestures/gesture", "../../config/config", "../../util", "../../util/dom", "./swiper-widget"], function (_export) {
    /**
     * @name Slides
     * @description
     * Slides is a slide box implementation based on Swiper.js
     *
     * Swiper.js:
     * The most modern mobile touch slider and framework with hardware accelerated transitions
     *
     * http://www.idangero.us/swiper/
     *
     * Copyright 2015, Vladimir Kharlampidi
     * The iDangero.us
     * http://www.idangero.us/
     *
     * Licensed under MIT
     *
     * @usage
     * ```ts
     * @Page({
     *  template: `
     *     <ion-slides pager (change)="onSlideChanged($event)" loop="true" autoplay="true">
     *      <ion-slide>
     *        <h3>Thank you for choosing the Awesome App!</h3>
     *        <p>
     *          The number one app for everything awesome.
     *        </p>
     *      </ion-slide>
     *      <ion-slide>
     *        <h3>Using Awesome</h3>
     *         <div id="list">
     *           <h5>Just three steps:</h5>
     *           <ol>
     *             <li>Be awesome</li>
     *             <li>Stay awesome</li>
     *             <li>There is no step 3</li>
     *           </ol>
     *         </div>
     *      </ion-slide>
     *      <ion-slide>
     *        <h3>Any questions?</h3>
     *      </ion-slide>
     *    </ion-slides>
     *    `
     *})
     *
     *```
     * @property {Boolean} [autoplay] - whether or not the slides should automatically change
     * @property {Boolean} [loop] - whether the slides should loop from the last slide back to the first
     * @property {Boolean} [bounce] - whether the slides should bounce
     * @property {Number} [index] - The slide index to start on
     * @property [pager] - add this property to enable the slide pager
     * @property {Any} [change] - expression to evaluate when a slide has been changed
     * @demo /docs/v3/demos/slides/
     * @see {@link /docs/v3/components#slides Slides Component Docs}
     */
    "use strict";

    var Directive, Component, ElementRef, Host, EventEmitter, Output, NgClass, Ion, Animation, Gesture, Config, dom, util, CSS, Swiper, __decorate, __metadata, __param, Slides, Slide, SlideLazy, _a, _b, _c, _d, _e;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            Component = _angular2Core.Component;
            ElementRef = _angular2Core.ElementRef;
            Host = _angular2Core.Host;
            EventEmitter = _angular2Core.EventEmitter;
            Output = _angular2Core.Output;
        }, function (_angular2Common) {
            NgClass = _angular2Common.NgClass;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_gesturesGesture) {
            Gesture = _gesturesGesture.Gesture;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_util) {
            dom = _util.dom;
            util = _util;
        }, function (_utilDom) {
            CSS = _utilDom.CSS;
        }, function (_swiperWidget) {
            Swiper = _swiperWidget.Swiper;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Slides = (function (_Ion) {
                _inherits(Slides, _Ion);

                /**
                 * @private
                 * @param {ElementRef} elementRef  TODO
                 */

                function Slides(elementRef, config) {
                    var _this = this;

                    _classCallCheck(this, Slides);

                    _get(Object.getPrototypeOf(Slides.prototype), "constructor", this).call(this, elementRef, config);
                    this.change = new EventEmitter();
                    this.rapidUpdate = util.debounce(function () {
                        _this.update();
                    }, 10);
                    console.warn("(slideChanged) deprecated. Use (change) to track slide changes.");
                }

                /**
                 * @private
                 */

                _createClass(Slides, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        var _this2 = this;

                        if (!this.options) {
                            this.options = {};
                        }
                        this.showPager = util.isTrueProperty(this.pager);
                        var options = util.defaults({
                            loop: this.loop,
                            pagination: '.swiper-pagination',
                            paginationClickable: true,
                            lazyLoading: true,
                            preloadImages: false
                        }, this.options);
                        options.onTap = function (swiper, e) {
                            _this2.onTap(swiper, e);
                            return _this2.options.onTap && _this2.options.onTap(swiper, e);
                        };
                        options.onClick = function (swiper, e) {
                            _this2.onClick(swiper, e);
                            return _this2.options.onClick && _this2.options.onClick(swiper, e);
                        };
                        options.onDoubleTap = function (swiper, e) {
                            _this2.onDoubleTap(swiper, e);
                            return _this2.options.onDoubleTap && _this2.options.onDoubleTap(swiper, e);
                        };
                        options.onTransitionStart = function (swiper, e) {
                            _this2.onTransitionStart(swiper, e);
                            return _this2.options.onTransitionStart && _this2.options.onTransitionStart(swiper, e);
                        };
                        options.onTransitionEnd = function (swiper, e) {
                            _this2.onTransitionEnd(swiper, e);
                            return _this2.options.onTransitionEnd && _this2.options.onTransitionEnd(swiper, e);
                        };
                        options.onSlideChangeStart = function (swiper) {
                            return _this2.options.onSlideChangeStart && _this2.options.onSlideChangeStart(swiper);
                        };
                        options.onSlideChangeEnd = function (swiper) {
                            _this2.change.emit(swiper);
                            return _this2.options.onSlideChangeEnd && _this2.options.onSlideChangeEnd(swiper);
                        };
                        options.onLazyImageLoad = function (swiper, slide, img) {
                            return _this2.options.onLazyImageLoad && _this2.options.onLazyImageLoad(swiper, slide, img);
                        };
                        options.onLazyImageReady = function (swiper, slide, img) {
                            return _this2.options.onLazyImageReady && _this2.options.onLazyImageReady(swiper, slide, img);
                        };
                        var swiper = new Swiper(this.getNativeElement().children[0], options);
                        this.slider = swiper;
                        /*
                        * TODO: Finish this
                        if(util.isTrueProperty(this.zoom)) {
                          this.enableZoom = true;
                          setTimeout(() => {
                            this.initZoom();
                          })
                        }
                        */
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "onTap",
                    value: function onTap(swiper, e) {}

                    /**
                     * @private
                     */
                }, {
                    key: "onClick",
                    value: function onClick(swiper, e) {}

                    /**
                     * @private
                     */
                }, {
                    key: "onDoubleTap",
                    value: function onDoubleTap(swiper, e) {
                        this.toggleZoom(swiper, e);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "onLazyImageLoad",
                    value: function onLazyImageLoad(swiper, slide, img) {}

                    /**
                     * @private
                     */
                }, {
                    key: "onLazyImageReady",
                    value: function onLazyImageReady(swiper, slide, img) {}

                    /*
                    nextButton(swiper, e) {
                    }
                    prevButton() {
                    }
                    indexButton() {
                    }
                    */
                    /**
                     * @private
                     */
                }, {
                    key: "initZoom",
                    value: function initZoom() {
                        var _this3 = this;

                        this.zoomDuration = this.zoomDuration || 230;
                        this.maxScale = this.zoomMax || 3;
                        this.zoomElement = this.getNativeElement().children[0].children[0];
                        this.zoomElement && this.zoomElement.classList.add('ion-scroll-zoom');
                        this.zoomGesture = new Gesture(this.zoomElement);
                        this.zoomGesture.listen();
                        this.scale = 1;
                        this.zoomLastPosX = 0;
                        this.zoomLastPosY = 0;
                        var last_scale = undefined,
                            startX = undefined,
                            startY = undefined,
                            posX = 0,
                            posY = 0,
                            zoomRect = undefined;
                        this.viewportWidth = this.getNativeElement().offsetWidth;
                        this.viewportHeight = this.getNativeElement().offsetHeight;
                        this.zoomElement.addEventListener('touchstart', function (e) {
                            _this3.onTouchStart(e);
                        });
                        this.zoomElement.addEventListener('touchmove', function (e) {
                            _this3.onTouchMove(e);
                        });
                        this.zoomElement.addEventListener('touchend', function (e) {
                            _this3.onTouchEnd(e);
                        });
                        this.zoomGesture.on('pinchstart', function (e) {
                            last_scale = _this3.scale;
                            console.log('Last scale', e.scale);
                        });
                        this.zoomGesture.on('pinch', function (e) {
                            _this3.scale = Math.max(1, Math.min(last_scale * e.scale, 10));
                            console.log('Scaling', _this3.scale);
                            _this3.zoomElement.style[CSS.transform] = 'scale(' + _this3.scale + ')';
                            zoomRect = _this3.zoomElement.getBoundingClientRect();
                        });
                        this.zoomGesture.on('pinchend', function (e) {
                            //last_scale = Math.max(1, Math.min(last_scale * e.scale, 10));
                            if (_this3.scale > _this3.maxScale) {
                                var za = new Animation(_this3.zoomElement).duration(_this3.zoomDuration).easing('linear').from('scale', _this3.scale).to('scale', _this3.maxScale);
                                za.play();
                                _this3.scale = _this3.maxScale;
                            }
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "resetZoom",
                    value: function resetZoom() {
                        if (this.zoomElement) {
                            this.zoomElement.parentElement.style[CSS.transform] = '';
                            this.zoomElement.style[CSS.transform] = 'scale(1)';
                        }
                        this.scale = 1;
                        this.zoomLastPosX = 0;
                        this.zoomLastPosY = 0;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "toggleZoom",
                    value: function toggleZoom(swiper, e) {
                        console.log('Try toggle zoom');
                        if (!this.enableZoom) {
                            return;
                        }
                        console.log('Toggling zoom', e);
                        /*
                        let x = e.pointers[0].clientX;
                        let y = e.pointers[0].clientY;
                             let mx = this.viewportWidth / 2;
                        let my = this.viewportHeight / 2;
                             let tx, ty;
                             if(x > mx) {
                          // Greater than half
                          tx = -x;
                        } else {
                          // Less than or equal to half
                          tx = (this.viewportWidth - x);
                        }
                        if(y > my) {
                          ty = -y;
                        } else {
                          ty = y-my;
                        }
                             console.log(y);
                        */
                        var zi = new Animation(this.touch.target.children[0]).duration(this.zoomDuration).easing('linear').fill('none');
                        var zw = new Animation(this.touch.target.children[0]).duration(this.zoomDuration).easing('linear');
                        var za = new Animation();
                        za.fill('none');
                        za.add(zi); //, zw);
                        if (this.scale > 1) {
                            // Zoom out
                            //zw.fromTo('translateX', posX + 'px', '0px');
                            //zw.fromTo('translateY', posY + 'px', '0px');
                            zi.from('scale', this.scale);
                            zi.to('scale', 1);
                            za.play();
                            //posX = 0;
                            //posY = 0;
                            this.scale = 1;
                        } else {
                            // Zoom in
                            //zw.fromTo('translateX', posX + 'px', tx + 'px');
                            //zw.fromTo('translateY', posY + 'px', ty + 'px');
                            zi.from('scale', this.scale);
                            zi.to('scale', this.maxScale);
                            za.play();
                            //posX = tx;
                            //posY = ty;
                            this.scale = this.maxScale;
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "onTransitionStart",
                    value: function onTransitionStart(swiper) {}

                    /**
                     * @private
                     */
                }, {
                    key: "onTransitionEnd",
                    value: function onTransitionEnd(swiper) {}

                    /**
                     * @private
                     */
                }, {
                    key: "onTouchStart",
                    value: function onTouchStart(e) {
                        console.log('Touch start', e);
                        //TODO: Support mice as well
                        var target = dom.closest(e.target, '.slide').children[0].children[0];
                        this.touch = {
                            startX: e.touches[0].clientX,
                            startY: e.touches[0].clientY,
                            deltaX: 0,
                            deltaY: 0,
                            lastX: 0,
                            lastY: 0,
                            target: target.parentElement,
                            zoomable: target,
                            zoomableWidth: target.offsetWidth,
                            zoomableHeight: target.offsetHeight
                        };
                        console.log('Target', this.touch.target);
                        //TODO: android prevent default
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "onTouchMove",
                    value: function onTouchMove(e) {
                        this.touch.deltaX = e.touches[0].clientX - this.touch.startX;
                        this.touch.deltaY = e.touches[0].clientY - this.touch.startY;
                        // TODO: Make sure we need to transform (image is bigger than viewport)
                        var zoomableScaledWidth = this.touch.zoomableWidth * this.scale;
                        var zoomableScaledHeight = this.touch.zoomableHeight * this.scale;
                        var x1 = Math.min(this.viewportWidth / 2 - zoomableScaledWidth / 2, 0);
                        var x2 = -x1;
                        var y1 = Math.min(this.viewportHeight / 2 - zoomableScaledHeight / 2, 0);
                        var y2 = -y1;
                        console.log('BOUNDS', x1, x2, y1, y2);
                        if (this.scale <= 1) {
                            return;
                        }
                        console.log('PAN', e);
                        // Move image
                        this.touch.x = this.touch.deltaX + this.touch.lastX;
                        this.touch.y = this.touch.deltaY + this.touch.lastY;
                        console.log(this.touch.x, this.touch.y);
                        if (this.touch.x < x1) {
                            console.log('OUT ON LEFT');
                        }
                        if (this.touch.x > x2) {
                            console.log('OUT ON RIGHT');
                        }
                        if (this.touch.x > this.viewportWidth) {} else if (-this.touch.x > this.viewportWidth) {} else {
                            console.log('TRANSFORM', this.touch.x, this.touch.y, this.touch.target);
                            //this.touch.target.style[CSS.transform] = 'translateX(' + this.touch.x + 'px) translateY(' + this.touch.y + 'px)';
                            this.touch.target.style[CSS.transform] = 'translateX(' + this.touch.x + 'px) translateY(' + this.touch.y + 'px)';
                            e.preventDefault();
                            e.stopPropagation();
                            return false;
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "onTouchEnd",
                    value: function onTouchEnd(e) {
                        console.log('PANEND', e);
                        if (this.scale > 1) {
                            if (Math.abs(this.touch.x) > this.viewportWidth) {
                                posX = posX > 0 ? this.viewportWidth - 1 : -(this.viewportWidth - 1);
                                console.log('Setting on posx', this.touch.x);
                            }
                            /*
                            if(posY > this.viewportHeight/2) {
                              let z = new Animation(this.zoomElement.parentElement);
                              z.fromTo('translateY', posY + 'px', Math.min(this.viewportHeight/2 + 30, posY));
                              z.play();
                            } else {
                              let z = new Animation(this.zoomElement.parentElement);
                              z.fromTo('translateY', posY + 'px', Math.max(this.viewportHeight/2 - 30, posY));
                              z.play();
                            }
                            */
                            this.touch.lastX = this.touch.x;
                            this.touch.lastY = this.touch.y;
                        }
                    }

                    /**
                     * @private
                     * Update the underlying slider implementation. Call this if you've added or removed
                     * child slides.
                     */
                }, {
                    key: "update",
                    value: function update() {
                        var _this4 = this;

                        setTimeout(function () {
                            _this4.slider.update();
                            // Don't allow pager to show with > 10 slides
                            if (_this4.slider.slides.length > 10) {
                                _this4.showPager = false;
                            }
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "next",
                    value: function next() {
                        this.slider.slideNext();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "prev",
                    value: function prev() {
                        this.slider.slidePrev();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getIndex",
                    value: function getIndex() {
                        return this.slider.activeIndex;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getNumSlides",
                    value: function getNumSlides() {
                        return this.slider.slides.length;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "isAtEnd",
                    value: function isAtEnd() {
                        return this.slider.isEnd;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "isAtBeginning",
                    value: function isAtBeginning() {
                        return this.slider.isBeginning;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getSliderWidget",
                    value: function getSliderWidget() {
                        return this.slider;
                    }
                }]);

                return Slides;
            })(Ion);

            _export("Slides", Slides);

            __decorate([Output(), __metadata('design:type', typeof (_a = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _a || Object)], Slides.prototype, "change", void 0);
            _export("Slides", Slides = __decorate([Component({
                selector: 'ion-slides',
                inputs: ['autoplay', 'loop', 'index', 'bounce', 'pager', 'options', 'zoom', 'zoomDuration', 'zoomMax'],
                template: '<div class="swiper-container">' + '<div class="swiper-wrapper">' + '<ng-content></ng-content>' + '</div>' + '<div [class.hide]="!showPager" class="swiper-pagination"></div>' + '</div>',
                directives: [NgClass]
            }), __metadata('design:paramtypes', [typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof Config !== 'undefined' && Config) === 'function' && _c || Object])], Slides));
            /**
             * @private
             */

            Slide =
            /**
             * TODO
             * @param {Slides} slides  The containing slidebox.
             * @param {ElementRef} elementRef  TODO
             */
            function Slide(elementRef, slides) {
                _classCallCheck(this, Slide);

                this.ele = elementRef.nativeElement;
                this.ele.classList.add('swiper-slide');
                slides.rapidUpdate();
            };

            _export("Slide", Slide);

            _export("Slide", Slide = __decorate([Component({
                selector: 'ion-slide',
                inputs: ['zoom'],
                template: '<div class="slide-zoom"><ng-content></ng-content></div>'
            }), __param(1, Host()), __metadata('design:paramtypes', [typeof (_d = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _d || Object, Slides])], Slide));
            /**
             * @private
             */

            SlideLazy = function SlideLazy(elementRef) {
                _classCallCheck(this, SlideLazy);

                elementRef.getNativeElement().classList.add('swiper-lazy');
            };

            _export("SlideLazy", SlideLazy);

            _export("SlideLazy", SlideLazy = __decorate([Directive({
                selector: 'slide-lazy'
            }), __metadata('design:paramtypes', [typeof (_e = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _e || Object])], SlideLazy));
        }
    };
});
System.register('ionic/components/slides/swiper-widget',[],function(_export){ /**
 * Swiper 3.1.2
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 *
 * http://www.idangero.us/swiper/
 *
 * Copyright 2015, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 *
 * Licensed under MIT
 *
 * Released on: August 22, 2015
 */'use strict';var $,Dom7,swiperDomPlugins,i,domLib;_export('Swiper',Swiper); /*===========================
Swiper
===========================*/function Swiper(container,params){if(!(this instanceof Swiper))return new Swiper(container,params);var defaults={direction:'horizontal',touchEventsTarget:'container',initialSlide:0,speed:300, // autoplay
autoplay:false,autoplayDisableOnInteraction:true, // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
iOSEdgeSwipeDetection:false,iOSEdgeSwipeThreshold:20, // Free mode
freeMode:false,freeModeMomentum:true,freeModeMomentumRatio:1,freeModeMomentumBounce:true,freeModeMomentumBounceRatio:1,freeModeSticky:false, // Set wrapper width
setWrapperSize:false, // Virtual Translate
virtualTranslate:false, // Effects
effect:'slide',coverflow:{rotate:50,stretch:0,depth:100,modifier:1,slideShadows:true},cube:{slideShadows:true,shadow:true,shadowOffset:20,shadowScale:0.94},fade:{crossFade:false}, // Parallax
parallax:false, // Scrollbar
scrollbar:null,scrollbarHide:true, // Keyboard Mousewheel
keyboardControl:false,mousewheelControl:false,mousewheelReleaseOnEdges:false,mousewheelInvert:false,mousewheelForceToAxis:false,mousewheelSensitivity:1, // Hash Navigation
hashnav:false, // Slides grid
spaceBetween:0,slidesPerView:1,slidesPerColumn:1,slidesPerColumnFill:'column',slidesPerGroup:1,centeredSlides:false,slidesOffsetBefore:0,slidesOffsetAfter:0, // Round length
roundLengths:false, // Touches
touchRatio:1,touchAngle:45,simulateTouch:true,shortSwipes:true,longSwipes:true,longSwipesRatio:0.5,longSwipesMs:300,followFinger:true,onlyExternal:false,threshold:0,touchMoveStopPropagation:true, // Pagination
pagination:null,paginationElement:'span',paginationClickable:false,paginationHide:false,paginationBulletRender:null, // Resistance
resistance:true,resistanceRatio:0.85, // Next/prev buttons
nextButton:null,prevButton:null, // Progress
watchSlidesProgress:false,watchSlidesVisibility:false, // Cursor
grabCursor:false, // Clicks
preventClicks:true,preventClicksPropagation:true,slideToClickedSlide:false, // Lazy Loading
lazyLoading:false,lazyLoadingInPrevNext:false,lazyLoadingOnTransitionStart:false, // Images
preloadImages:true,updateOnImagesReady:true, // loop
loop:false,loopAdditionalSlides:0,loopedSlides:null, // Control
control:undefined,controlInverse:false,controlBy:'slide', // Swiping/no swiping
allowSwipeToPrev:true,allowSwipeToNext:true,swipeHandler:null,noSwiping:true,noSwipingClass:'swiper-no-swiping', // NS
slideClass:'swiper-slide',slideActiveClass:'swiper-slide-active',slideVisibleClass:'swiper-slide-visible',slideDuplicateClass:'swiper-slide-duplicate',slideNextClass:'swiper-slide-next',slidePrevClass:'swiper-slide-prev',wrapperClass:'swiper-wrapper',bulletClass:'swiper-pagination-bullet',bulletActiveClass:'swiper-pagination-bullet-active',buttonDisabledClass:'swiper-button-disabled',paginationHiddenClass:'swiper-pagination-hidden', // Observer
observer:false,observeParents:false, // Accessibility
a11y:false,prevSlideMessage:'Previous slide',nextSlideMessage:'Next slide',firstSlideMessage:'This is the first slide',lastSlideMessage:'This is the last slide',paginationBulletMessage:'Go to slide {{index}}', // Callbacks
runCallbacksOnInit:true};var initialVirtualTranslate=params && params.virtualTranslate;params = params || {};for(var def in defaults) {if(typeof params[def] === 'undefined'){params[def] = defaults[def];}else if(typeof params[def] === 'object'){for(var deepDef in defaults[def]) {if(typeof params[def][deepDef] === 'undefined'){params[def][deepDef] = defaults[def][deepDef];}}}} // Swiper
var s=this; // Version
s.version = '3.1.0'; // Params
s.params = params; // Classname
s.classNames = []; /*=========================
      Dom Library and plugins
      ===========================*/if(typeof $ !== 'undefined' && typeof Dom7 !== 'undefined'){$ = Dom7;}if(typeof $ === 'undefined'){if(typeof Dom7 === 'undefined'){$ = window.Dom7 || window.Zepto || window.jQuery;}else {$ = Dom7;}if(!$)return;} // Export it to Swiper instance
s.$ = $; /*=========================
      Preparation - Define Container, Wrapper and Pagination
      ===========================*/s.container = $(container);if(s.container.length === 0)return;if(s.container.length > 1){s.container.each(function(){new Swiper(this,params);});return;} // Save instance in container HTML Element and in data
s.container[0].swiper = s;s.container.data('swiper',s);s.classNames.push('swiper-container-' + s.params.direction);if(s.params.freeMode){s.classNames.push('swiper-container-free-mode');}if(!s.support.flexbox){s.classNames.push('swiper-container-no-flexbox');s.params.slidesPerColumn = 1;} // Enable slides progress when required
if(s.params.parallax || s.params.watchSlidesVisibility){s.params.watchSlidesProgress = true;} // Coverflow / 3D
if(['cube','coverflow'].indexOf(s.params.effect) >= 0){if(s.support.transforms3d){s.params.watchSlidesProgress = true;s.classNames.push('swiper-container-3d');}else {s.params.effect = 'slide';}}if(s.params.effect !== 'slide'){s.classNames.push('swiper-container-' + s.params.effect);}if(s.params.effect === 'cube'){s.params.resistanceRatio = 0;s.params.slidesPerView = 1;s.params.slidesPerColumn = 1;s.params.slidesPerGroup = 1;s.params.centeredSlides = false;s.params.spaceBetween = 0;s.params.virtualTranslate = true;s.params.setWrapperSize = false;}if(s.params.effect === 'fade'){s.params.slidesPerView = 1;s.params.slidesPerColumn = 1;s.params.slidesPerGroup = 1;s.params.watchSlidesProgress = true;s.params.spaceBetween = 0;if(typeof initialVirtualTranslate === 'undefined'){s.params.virtualTranslate = true;}} // Grab Cursor
if(s.params.grabCursor && s.support.touch){s.params.grabCursor = false;} // Wrapper
s.wrapper = s.container.children('.' + s.params.wrapperClass); // Pagination
if(s.params.pagination){s.paginationContainer = $(s.params.pagination);if(s.params.paginationClickable){s.paginationContainer.addClass('swiper-pagination-clickable');}} // Is Horizontal
function isH(){return s.params.direction === 'horizontal';} // RTL
s.rtl = isH() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');if(s.rtl){s.classNames.push('swiper-container-rtl');} // Wrong RTL support
if(s.rtl){s.wrongRTL = s.wrapper.css('display') === '-webkit-box';} // Columns
if(s.params.slidesPerColumn > 1){s.classNames.push('swiper-container-multirow');} // Check for Android
if(s.device.android){s.classNames.push('swiper-container-android');} // Add classes
s.container.addClass(s.classNames.join(' ')); // Translate
s.translate = 0; // Progress
s.progress = 0; // Velocity
s.velocity = 0; /*=========================
      Locks, unlocks
      ===========================*/s.lockSwipeToNext = function(){s.params.allowSwipeToNext = false;};s.lockSwipeToPrev = function(){s.params.allowSwipeToPrev = false;};s.lockSwipes = function(){s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;};s.unlockSwipeToNext = function(){s.params.allowSwipeToNext = true;};s.unlockSwipeToPrev = function(){s.params.allowSwipeToPrev = true;};s.unlockSwipes = function(){s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;}; /*=========================
      Round helper
      ===========================*/function round(a){return Math.floor(a);} /*=========================
      Set grab cursor
      ===========================*/if(s.params.grabCursor){s.container[0].style.cursor = 'move';s.container[0].style.cursor = '-webkit-grab';s.container[0].style.cursor = '-moz-grab';s.container[0].style.cursor = 'grab';} /*=========================
      Update on Images Ready
      ===========================*/s.imagesToLoad = [];s.imagesLoaded = 0;s.loadImage = function(imgElement,src,checkForComplete,callback){var image;function onReady(){if(callback)callback();}if(!imgElement.complete || !checkForComplete){if(src){image = new window.Image();image.onload = onReady;image.onerror = onReady;image.src = src;}else {onReady();}}else {onReady();}};s.preloadImages = function(){s.imagesToLoad = s.container.find('img');function _onReady(){if(typeof s === 'undefined' || s === null)return;if(s.imagesLoaded !== undefined)s.imagesLoaded++;if(s.imagesLoaded === s.imagesToLoad.length){if(s.params.updateOnImagesReady)s.update();s.emit('onImagesReady',s);}}for(var i=0;i < s.imagesToLoad.length;i++) {s.loadImage(s.imagesToLoad[i],s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src'),true,_onReady);}}; /*=========================
      Autoplay
      ===========================*/s.autoplayTimeoutId = undefined;s.autoplaying = false;s.autoplayPaused = false;function autoplay(){s.autoplayTimeoutId = setTimeout(function(){if(s.params.loop){s.fixLoop();s._slideNext();}else {if(!s.isEnd){s._slideNext();}else {if(!params.autoplayStopOnLast){s._slideTo(0);}else {s.stopAutoplay();}}}},s.params.autoplay);}s.startAutoplay = function(){if(typeof s.autoplayTimeoutId !== 'undefined')return false;if(!s.params.autoplay)return false;if(s.autoplaying)return false;s.autoplaying = true;s.emit('onAutoplayStart',s);autoplay();};s.stopAutoplay = function(internal){if(!s.autoplayTimeoutId)return;if(s.autoplayTimeoutId)clearTimeout(s.autoplayTimeoutId);s.autoplaying = false;s.autoplayTimeoutId = undefined;s.emit('onAutoplayStop',s);};s.pauseAutoplay = function(speed){if(s.autoplayPaused)return;if(s.autoplayTimeoutId)clearTimeout(s.autoplayTimeoutId);s.autoplayPaused = true;if(speed === 0){s.autoplayPaused = false;autoplay();}else {s.wrapper.transitionEnd(function(){if(!s)return;s.autoplayPaused = false;if(!s.autoplaying){s.stopAutoplay();}else {autoplay();}});}}; /*=========================
      Min/Max Translate
      ===========================*/s.minTranslate = function(){return -s.snapGrid[0];};s.maxTranslate = function(){return -s.snapGrid[s.snapGrid.length - 1];}; /*=========================
      Slider/slides sizes
      ===========================*/s.updateContainerSize = function(){var width,height;if(typeof s.params.width !== 'undefined'){width = s.params.width;}else {width = s.container[0].clientWidth;}if(typeof s.params.height !== 'undefined'){height = s.params.height;}else {height = s.container[0].clientHeight;}if(width === 0 && isH() || height === 0 && !isH()){return;} //Subtract paddings
width = width - parseInt(s.container.css('padding-left'),10) - parseInt(s.container.css('padding-right'),10);height = height - parseInt(s.container.css('padding-top'),10) - parseInt(s.container.css('padding-bottom'),10); // Store values
s.width = width;s.height = height;s.size = isH()?s.width:s.height;};s.updateSlidesSize = function(){s.slides = s.wrapper.children('.' + s.params.slideClass);s.snapGrid = [];s.slidesGrid = [];s.slidesSizesGrid = [];var spaceBetween=s.params.spaceBetween,slidePosition=-s.params.slidesOffsetBefore,i,prevSlideSize=0,index=0;if(typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0){spaceBetween = parseFloat(spaceBetween.replace('%','')) / 100 * s.size;}s.virtualSize = -spaceBetween; // reset margins
if(s.rtl)s.slides.css({marginLeft:'',marginTop:''});else s.slides.css({marginRight:'',marginBottom:''});var slidesNumberEvenToRows;if(s.params.slidesPerColumn > 1){if(Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn){slidesNumberEvenToRows = s.slides.length;}else {slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;}} // Calc slides
var slideSize;var slidesPerColumn=s.params.slidesPerColumn;var slidesPerRow=slidesNumberEvenToRows / slidesPerColumn;var numFullColumns=slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);for(i = 0;i < s.slides.length;i++) {slideSize = 0;var slide=s.slides.eq(i);if(s.params.slidesPerColumn > 1){ // Set slides order
var newSlideOrderIndex;var column,row;if(s.params.slidesPerColumnFill === 'column'){column = Math.floor(i / slidesPerColumn);row = i - column * slidesPerColumn;if(column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1){if(++row >= slidesPerColumn){row = 0;column++;}}newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;slide.css({'-webkit-box-ordinal-group':newSlideOrderIndex,'-moz-box-ordinal-group':newSlideOrderIndex,'-ms-flex-order':newSlideOrderIndex,'-webkit-order':newSlideOrderIndex,'order':newSlideOrderIndex});}else {row = Math.floor(i / slidesPerRow);column = i - row * slidesPerRow;}slide.css({'margin-top':row !== 0 && s.params.spaceBetween && s.params.spaceBetween + 'px'}).attr('data-swiper-column',column).attr('data-swiper-row',row);}if(slide.css('display') === 'none')continue;if(s.params.slidesPerView === 'auto'){slideSize = isH()?slide.outerWidth(true):slide.outerHeight(true);if(s.params.roundLengths)slideSize = round(slideSize);}else {slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;if(s.params.roundLengths)slideSize = round(slideSize);if(isH()){s.slides[i].style.width = slideSize + 'px';}else {s.slides[i].style.height = slideSize + 'px';}}s.slides[i].swiperSlideSize = slideSize;s.slidesSizesGrid.push(slideSize);if(s.params.centeredSlides){slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;if(i === 0)slidePosition = slidePosition - s.size / 2 - spaceBetween;if(Math.abs(slidePosition) < 1 / 1000)slidePosition = 0;if(index % s.params.slidesPerGroup === 0)s.snapGrid.push(slidePosition);s.slidesGrid.push(slidePosition);}else {if(index % s.params.slidesPerGroup === 0)s.snapGrid.push(slidePosition);s.slidesGrid.push(slidePosition);slidePosition = slidePosition + slideSize + spaceBetween;}s.virtualSize += slideSize + spaceBetween;prevSlideSize = slideSize;index++;}s.virtualSize = Math.max(s.virtualSize,s.size) + s.params.slidesOffsetAfter;var newSlidesGrid;if(s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')){s.wrapper.css({width:s.virtualSize + s.params.spaceBetween + 'px'});}if(!s.support.flexbox || s.params.setWrapperSize){if(isH())s.wrapper.css({width:s.virtualSize + s.params.spaceBetween + 'px'});else s.wrapper.css({height:s.virtualSize + s.params.spaceBetween + 'px'});}if(s.params.slidesPerColumn > 1){s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;s.wrapper.css({width:s.virtualSize + s.params.spaceBetween + 'px'});if(s.params.centeredSlides){newSlidesGrid = [];for(i = 0;i < s.snapGrid.length;i++) {if(s.snapGrid[i] < s.virtualSize + s.snapGrid[0])newSlidesGrid.push(s.snapGrid[i]);}s.snapGrid = newSlidesGrid;}} // Remove last grid elements depending on width
if(!s.params.centeredSlides){newSlidesGrid = [];for(i = 0;i < s.snapGrid.length;i++) {if(s.snapGrid[i] <= s.virtualSize - s.size){newSlidesGrid.push(s.snapGrid[i]);}}s.snapGrid = newSlidesGrid;if(Math.floor(s.virtualSize - s.size) > Math.floor(s.snapGrid[s.snapGrid.length - 1])){s.snapGrid.push(s.virtualSize - s.size);}}if(s.snapGrid.length === 0)s.snapGrid = [0];if(s.params.spaceBetween !== 0){if(isH()){if(s.rtl)s.slides.css({marginLeft:spaceBetween + 'px'});else s.slides.css({marginRight:spaceBetween + 'px'});}else s.slides.css({marginBottom:spaceBetween + 'px'});}if(s.params.watchSlidesProgress){s.updateSlidesOffset();}};s.updateSlidesOffset = function(){for(var i=0;i < s.slides.length;i++) {s.slides[i].swiperSlideOffset = isH()?s.slides[i].offsetLeft:s.slides[i].offsetTop;}}; /*=========================
      Slider/slides progress
      ===========================*/s.updateSlidesProgress = function(translate){if(typeof translate === 'undefined'){translate = s.translate || 0;}if(s.slides.length === 0)return;if(typeof s.slides[0].swiperSlideOffset === 'undefined')s.updateSlidesOffset();var offsetCenter=-translate;if(s.rtl)offsetCenter = translate; // Visible Slides
var containerBox=s.container[0].getBoundingClientRect();var sideBefore=isH()?'left':'top';var sideAfter=isH()?'right':'bottom';s.slides.removeClass(s.params.slideVisibleClass);for(var i=0;i < s.slides.length;i++) {var slide=s.slides[i];var slideProgress=(offsetCenter - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);if(s.params.watchSlidesVisibility){var slideBefore=-(offsetCenter - slide.swiperSlideOffset);var slideAfter=slideBefore + s.slidesSizesGrid[i];var isVisible=slideBefore >= 0 && slideBefore < s.size || slideAfter > 0 && slideAfter <= s.size || slideBefore <= 0 && slideAfter >= s.size;if(isVisible){s.slides.eq(i).addClass(s.params.slideVisibleClass);}}slide.progress = s.rtl?-slideProgress:slideProgress;}};s.updateProgress = function(translate){if(typeof translate === 'undefined'){translate = s.translate || 0;}var translatesDiff=s.maxTranslate() - s.minTranslate();if(translatesDiff === 0){s.progress = 0;s.isBeginning = s.isEnd = true;}else {s.progress = (translate - s.minTranslate()) / translatesDiff;s.isBeginning = s.progress <= 0;s.isEnd = s.progress >= 1;}if(s.isBeginning)s.emit('onReachBeginning',s);if(s.isEnd)s.emit('onReachEnd',s);if(s.params.watchSlidesProgress)s.updateSlidesProgress(translate);s.emit('onProgress',s,s.progress);};s.updateActiveIndex = function(){var translate=s.rtl?s.translate:-s.translate;var newActiveIndex,i,snapIndex;for(i = 0;i < s.slidesGrid.length;i++) {if(typeof s.slidesGrid[i + 1] !== 'undefined'){if(translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2){newActiveIndex = i;}else if(translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]){newActiveIndex = i + 1;}}else {if(translate >= s.slidesGrid[i]){newActiveIndex = i;}}} // Normalize slideIndex
if(newActiveIndex < 0 || typeof newActiveIndex === 'undefined')newActiveIndex = 0; // for (i = 0; i < s.slidesGrid.length; i++) {
// if (- translate >= s.slidesGrid[i]) {
// newActiveIndex = i;
// }
// }
snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);if(snapIndex >= s.snapGrid.length)snapIndex = s.snapGrid.length - 1;if(newActiveIndex === s.activeIndex){return;}s.snapIndex = snapIndex;s.previousIndex = s.activeIndex;s.activeIndex = newActiveIndex;s.updateClasses();}; /*=========================
      Classes
      ===========================*/s.updateClasses = function(){s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass);var activeSlide=s.slides.eq(s.activeIndex); // Active classes
activeSlide.addClass(s.params.slideActiveClass);activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass); // Pagination
if(s.bullets && s.bullets.length > 0){s.bullets.removeClass(s.params.bulletActiveClass);var bulletIndex;if(s.params.loop){bulletIndex = Math.ceil(s.activeIndex - s.loopedSlides) / s.params.slidesPerGroup;if(bulletIndex > s.slides.length - 1 - s.loopedSlides * 2){bulletIndex = bulletIndex - (s.slides.length - s.loopedSlides * 2);}if(bulletIndex > s.bullets.length - 1)bulletIndex = bulletIndex - s.bullets.length;}else {if(typeof s.snapIndex !== 'undefined'){bulletIndex = s.snapIndex;}else {bulletIndex = s.activeIndex || 0;}}if(s.paginationContainer.length > 1){s.bullets.each(function(){if($(this).index() === bulletIndex)$(this).addClass(s.params.bulletActiveClass);});}else {s.bullets.eq(bulletIndex).addClass(s.params.bulletActiveClass);}} // Next/active buttons
if(!s.params.loop){if(s.params.prevButton){if(s.isBeginning){$(s.params.prevButton).addClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.disable($(s.params.prevButton));}else {$(s.params.prevButton).removeClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.enable($(s.params.prevButton));}}if(s.params.nextButton){if(s.isEnd){$(s.params.nextButton).addClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.disable($(s.params.nextButton));}else {$(s.params.nextButton).removeClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.enable($(s.params.nextButton));}}}}; /*=========================
      Pagination
      ===========================*/s.updatePagination = function(){if(!s.params.pagination)return;if(s.paginationContainer && s.paginationContainer.length > 0){var bulletsHTML='';var numberOfBullets=s.params.loop?Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup):s.snapGrid.length;for(var i=0;i < numberOfBullets;i++) {if(s.params.paginationBulletRender){bulletsHTML += s.params.paginationBulletRender(i,s.params.bulletClass);}else {bulletsHTML += '<' + s.params.paginationElement + ' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';}}s.paginationContainer.html(bulletsHTML);s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);if(s.params.paginationClickable && s.params.a11y && s.a11y){s.a11y.initPagination();}}}; /*=========================
      Common update method
      ===========================*/s.update = function(updateTranslate){s.updateContainerSize();s.updateSlidesSize();s.updateProgress();s.updatePagination();s.updateClasses();if(s.params.scrollbar && s.scrollbar){s.scrollbar.set();}function forceSetTranslate(){newTranslate = Math.min(Math.max(s.translate,s.maxTranslate()),s.minTranslate());s.setWrapperTranslate(newTranslate);s.updateActiveIndex();s.updateClasses();}if(updateTranslate){var translated,newTranslate;if(s.controller && s.controller.spline){s.controller.spline = undefined;}if(s.params.freeMode){forceSetTranslate();}else {if((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides){translated = s.slideTo(s.slides.length - 1,0,false,true);}else {translated = s.slideTo(s.activeIndex,0,false,true);}if(!translated){forceSetTranslate();}}}}; /*=========================
      Resize Handler
      ===========================*/s.onResize = function(forceUpdatePagination){ // Disable locks on resize
var allowSwipeToPrev=s.params.allowSwipeToPrev;var allowSwipeToNext=s.params.allowSwipeToNext;s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;s.updateContainerSize();s.updateSlidesSize();if(s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination)s.updatePagination();if(s.params.scrollbar && s.scrollbar){s.scrollbar.set();}if(s.controller && s.controller.spline){s.controller.spline = undefined;}if(s.params.freeMode){var newTranslate=Math.min(Math.max(s.translate,s.maxTranslate()),s.minTranslate());s.setWrapperTranslate(newTranslate);s.updateActiveIndex();s.updateClasses();}else {s.updateClasses();if((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides){s.slideTo(s.slides.length - 1,0,false,true);}else {s.slideTo(s.activeIndex,0,false,true);}} // Return locks after resize
s.params.allowSwipeToPrev = allowSwipeToPrev;s.params.allowSwipeToNext = allowSwipeToNext;}; /*=========================
      Events
      ===========================*/ //Define Touch Events
var desktopEvents=['mousedown','mousemove','mouseup'];if(window.navigator.pointerEnabled)desktopEvents = ['pointerdown','pointermove','pointerup'];else if(window.navigator.msPointerEnabled)desktopEvents = ['MSPointerDown','MSPointerMove','MSPointerUp'];s.touchEvents = {start:s.support.touch || !s.params.simulateTouch?'touchstart':desktopEvents[0],move:s.support.touch || !s.params.simulateTouch?'touchmove':desktopEvents[1],end:s.support.touch || !s.params.simulateTouch?'touchend':desktopEvents[2]}; // WP8 Touch Events Fix
if(window.navigator.pointerEnabled || window.navigator.msPointerEnabled){(s.params.touchEventsTarget === 'container'?s.container:s.wrapper).addClass('swiper-wp8-' + s.params.direction);} // Attach/detach events
s.initEvents = function(detach){console.debug('swiper initEvents',detach?'detach':'attach');var actionDom=detach?'off':'on';var action=detach?'removeEventListener':'addEventListener';var touchEventsTarget=s.params.touchEventsTarget === 'container'?s.container[0]:s.wrapper[0];var target=s.support.touch?touchEventsTarget:document;var moveCapture=s.params.nested?true:false; //Touch Events
if(s.browser.ie){touchEventsTarget[action](s.touchEvents.start,s.onTouchStart,false);target[action](s.touchEvents.move,s.onTouchMove,moveCapture);target[action](s.touchEvents.end,s.onTouchEnd,false);}else {if(s.support.touch){touchEventsTarget[action](s.touchEvents.start,s.onTouchStart,false);touchEventsTarget[action](s.touchEvents.move,s.onTouchMove,moveCapture);touchEventsTarget[action](s.touchEvents.end,s.onTouchEnd,false);}if(params.simulateTouch && !s.device.ios && !s.device.android){touchEventsTarget[action]('mousedown',s.onTouchStart,false);document[action]('mousemove',s.onTouchMove,moveCapture);document[action]('mouseup',s.onTouchEnd,false);}}window[action]('resize',s.onResize); // Next, Prev, Index
if(s.params.nextButton){$(s.params.nextButton)[actionDom]('click',s.onClickNext);if(s.params.a11y && s.a11y)$(s.params.nextButton)[actionDom]('keydown',s.a11y.onEnterKey);}if(s.params.prevButton){$(s.params.prevButton)[actionDom]('click',s.onClickPrev);if(s.params.a11y && s.a11y)$(s.params.prevButton)[actionDom]('keydown',s.a11y.onEnterKey);}if(s.params.pagination && s.params.paginationClickable){$(s.paginationContainer)[actionDom]('click','.' + s.params.bulletClass,s.onClickIndex);if(s.params.a11y && s.a11y)$(s.paginationContainer)[actionDom]('keydown','.' + s.params.bulletClass,s.a11y.onEnterKey);} // Prevent Links Clicks
if(s.params.preventClicks || s.params.preventClicksPropagation)touchEventsTarget[action]('click',s.preventClicks,true);};s.attachEvents = function(detach){s.initEvents();};s.detachEvents = function(){s.initEvents(true);}; /*=========================
      Handle Clicks
      ===========================*/ // Prevent Clicks
s.allowClick = true;s.preventClicks = function(e){if(!s.allowClick){if(s.params.preventClicks)e.preventDefault();if(s.params.preventClicksPropagation && s.animating){e.stopPropagation();e.stopImmediatePropagation();}}}; // Clicks
s.onClickNext = function(e){e.preventDefault();if(s.isEnd && !s.params.loop)return;s.slideNext();};s.onClickPrev = function(e){e.preventDefault();if(s.isBeginning && !s.params.loop)return;s.slidePrev();};s.onClickIndex = function(e){e.preventDefault();var index=$(this).index() * s.params.slidesPerGroup;if(s.params.loop)index = index + s.loopedSlides;s.slideTo(index);}; /*=========================
      Handle Touches
      ===========================*/function findElementInEvent(e,selector){var el=$(e.target);if(!el.is(selector)){if(typeof selector === 'string'){el = el.parents(selector);}else if(selector.nodeType){var found;el.parents().each(function(index,_el){if(_el === selector)found = selector;});if(!found)return undefined;else return selector;}}if(el.length === 0){return undefined;}return el[0];}s.updateClickedSlide = function(e){var slide=findElementInEvent(e,'.' + s.params.slideClass);var slideFound=false;if(slide){for(var i=0;i < s.slides.length;i++) {if(s.slides[i] === slide)slideFound = true;}}if(slide && slideFound){s.clickedSlide = slide;s.clickedIndex = $(slide).index();}else {s.clickedSlide = undefined;s.clickedIndex = undefined;return;}if(s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex){var slideToIndex=s.clickedIndex,realIndex;if(s.params.loop){realIndex = $(s.clickedSlide).attr('data-swiper-slide-index');if(slideToIndex > s.slides.length - s.params.slidesPerView){s.fixLoop();slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]').eq(0).index();setTimeout(function(){s.slideTo(slideToIndex);},0);}else if(slideToIndex < s.params.slidesPerView - 1){s.fixLoop();var duplicatedSlides=s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]');slideToIndex = duplicatedSlides.eq(duplicatedSlides.length - 1).index();setTimeout(function(){s.slideTo(slideToIndex);},0);}else {s.slideTo(slideToIndex);}}else {s.slideTo(slideToIndex);}}};var isTouched,isMoved,touchStartTime,isScrolling,currentTranslate,startTranslate,allowThresholdMove, // Form elements to match
formElements='input, select, textarea, button', // Last click time
lastClickTime=Date.now(),clickTimeout, //Velocities
velocities=[],allowMomentumBounce; // Animating Flag
s.animating = false; // Touches information
s.touches = {startX:0,startY:0,currentX:0,currentY:0,diff:0}; // Touch handlers
var isTouchEvent,startMoving;s.onTouchStart = function(e){if(e.originalEvent)e = e.originalEvent;isTouchEvent = e.type === 'touchstart';if(!isTouchEvent && 'which' in e && e.which === 3)return;if(s.params.noSwiping && findElementInEvent(e,'.' + s.params.noSwipingClass)){s.allowClick = true;return;}if(s.params.swipeHandler){if(!findElementInEvent(e,s.params.swipeHandler))return;}var startX=s.touches.currentX = e.type === 'touchstart'?e.targetTouches[0].pageX:e.pageX;var startY=s.touches.currentY = e.type === 'touchstart'?e.targetTouches[0].pageY:e.pageY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
if(s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold){return;}isTouched = true;isMoved = false;isScrolling = undefined;startMoving = undefined;s.touches.startX = startX;s.touches.startY = startY;touchStartTime = Date.now();s.allowClick = true;s.updateContainerSize();s.swipeDirection = undefined;if(s.params.threshold > 0)allowThresholdMove = false;if(e.type !== 'touchstart'){var preventDefault=true;if($(e.target).is(formElements))preventDefault = false;if(document.activeElement && $(document.activeElement).is(formElements)){document.activeElement.blur();}if(preventDefault){e.preventDefault();}}s.emit('onTouchStart',s,e);};s.onTouchMove = function(e){if(e.originalEvent)e = e.originalEvent;if(isTouchEvent && e.type === 'mousemove')return;if(e.preventedByNestedSwiper)return;if(s.params.onlyExternal){ // isMoved = true;
s.allowClick = false;if(isTouched){s.touches.startX = s.touches.currentX = e.type === 'touchmove'?e.targetTouches[0].pageX:e.pageX;s.touches.startY = s.touches.currentY = e.type === 'touchmove'?e.targetTouches[0].pageY:e.pageY;touchStartTime = Date.now();}return;}if(isTouchEvent && document.activeElement){if(e.target === document.activeElement && $(e.target).is(formElements)){isMoved = true;s.allowClick = false;return;}}s.emit('onTouchMove',s,e);if(e.targetTouches && e.targetTouches.length > 1)return;s.touches.currentX = e.type === 'touchmove'?e.targetTouches[0].pageX:e.pageX;s.touches.currentY = e.type === 'touchmove'?e.targetTouches[0].pageY:e.pageY;if(typeof isScrolling === 'undefined'){var touchAngle=Math.atan2(Math.abs(s.touches.currentY - s.touches.startY),Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;isScrolling = isH()?touchAngle > s.params.touchAngle:90 - touchAngle > s.params.touchAngle;}if(isScrolling){s.emit('onTouchMoveOpposite',s,e);}if(typeof startMoving === 'undefined' && s.browser.ieTouch){if(s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY){startMoving = true;}}if(!isTouched)return;if(isScrolling){isTouched = false;return;}if(!startMoving && s.browser.ieTouch){return;}s.allowClick = false;s.emit('onSliderMove',s,e);e.preventDefault();if(s.params.touchMoveStopPropagation && !s.params.nested){e.stopPropagation();}if(!isMoved){if(params.loop){s.fixLoop();}startTranslate = s.getWrapperTranslate();s.setWrapperTransition(0);if(s.animating){s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');}if(s.params.autoplay && s.autoplaying){if(s.params.autoplayDisableOnInteraction){s.stopAutoplay();}else {s.pauseAutoplay();}}allowMomentumBounce = false; //Grab Cursor
if(s.params.grabCursor){s.container[0].style.cursor = 'move';s.container[0].style.cursor = '-webkit-grabbing';s.container[0].style.cursor = '-moz-grabbin';s.container[0].style.cursor = 'grabbing';}}isMoved = true;var diff=s.touches.diff = isH()?s.touches.currentX - s.touches.startX:s.touches.currentY - s.touches.startY;diff = diff * s.params.touchRatio;if(s.rtl)diff = -diff;s.swipeDirection = diff > 0?'prev':'next';currentTranslate = diff + startTranslate;var disableParentSwiper=true;if(diff > 0 && currentTranslate > s.minTranslate()){disableParentSwiper = false;if(s.params.resistance)currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff,s.params.resistanceRatio);}else if(diff < 0 && currentTranslate < s.maxTranslate()){disableParentSwiper = false;if(s.params.resistance)currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff,s.params.resistanceRatio);}if(disableParentSwiper){e.preventedByNestedSwiper = true;} // Directions locks
if(!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate){currentTranslate = startTranslate;}if(!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate){currentTranslate = startTranslate;}if(!s.params.followFinger)return; // Threshold
if(s.params.threshold > 0){if(Math.abs(diff) > s.params.threshold || allowThresholdMove){if(!allowThresholdMove){allowThresholdMove = true;s.touches.startX = s.touches.currentX;s.touches.startY = s.touches.currentY;currentTranslate = startTranslate;s.touches.diff = isH()?s.touches.currentX - s.touches.startX:s.touches.currentY - s.touches.startY;return;}}else {currentTranslate = startTranslate;return;}} // Update active index in free mode
if(s.params.freeMode || s.params.watchSlidesProgress){s.updateActiveIndex();}if(s.params.freeMode){ //Velocity
if(velocities.length === 0){velocities.push({position:s.touches[isH()?'startX':'startY'],time:touchStartTime});}velocities.push({position:s.touches[isH()?'currentX':'currentY'],time:new window.Date().getTime()});} // Update progress
s.updateProgress(currentTranslate); // Update translate
s.setWrapperTranslate(currentTranslate);};s.onTouchEnd = function(e){if(e.originalEvent)e = e.originalEvent;s.emit('onTouchEnd',s,e);if(!isTouched)return; //Return Grab Cursor
if(s.params.grabCursor && isMoved && isTouched){s.container[0].style.cursor = 'move';s.container[0].style.cursor = '-webkit-grab';s.container[0].style.cursor = '-moz-grab';s.container[0].style.cursor = 'grab';} // Time diff
var touchEndTime=Date.now();var timeDiff=touchEndTime - touchStartTime; // Tap, doubleTap, Click
if(s.allowClick){s.updateClickedSlide(e);s.emit('onTap',s,e);if(timeDiff < 300 && touchEndTime - lastClickTime > 300){if(clickTimeout)clearTimeout(clickTimeout);clickTimeout = setTimeout(function(){if(!s)return;if(s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)){s.paginationContainer.toggleClass(s.params.paginationHiddenClass);}s.emit('onClick',s,e);},300);}if(timeDiff < 300 && touchEndTime - lastClickTime < 300){if(clickTimeout)clearTimeout(clickTimeout);s.emit('onDoubleTap',s,e);}}lastClickTime = Date.now();setTimeout(function(){if(s)s.allowClick = true;},0);if(!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate){isTouched = isMoved = false;return;}isTouched = isMoved = false;var currentPos;if(s.params.followFinger){currentPos = s.rtl?s.translate:-s.translate;}else {currentPos = -currentTranslate;}if(s.params.freeMode){if(currentPos < -s.minTranslate()){s.slideTo(s.activeIndex);return;}else if(currentPos > -s.maxTranslate()){if(s.slides.length < s.snapGrid.length){s.slideTo(s.snapGrid.length - 1);}else {s.slideTo(s.slides.length - 1);}return;}if(s.params.freeModeMomentum){if(velocities.length > 1){var lastMoveEvent=velocities.pop(),velocityEvent=velocities.pop();var distance=lastMoveEvent.position - velocityEvent.position;var time=lastMoveEvent.time - velocityEvent.time;s.velocity = distance / time;s.velocity = s.velocity / 2;if(Math.abs(s.velocity) < 0.02){s.velocity = 0;} // this implies that the user stopped moving a finger then released.
// There would be no events with distance zero, so the last event is stale.
if(time > 150 || new window.Date().getTime() - lastMoveEvent.time > 300){s.velocity = 0;}}else {s.velocity = 0;}velocities.length = 0;var momentumDuration=1000 * s.params.freeModeMomentumRatio;var momentumDistance=s.velocity * momentumDuration;var newPosition=s.translate + momentumDistance;if(s.rtl)newPosition = -newPosition;var doBounce=false;var afterBouncePosition;var bounceAmount=Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;if(newPosition < s.maxTranslate()){if(s.params.freeModeMomentumBounce){if(newPosition + s.maxTranslate() < -bounceAmount){newPosition = s.maxTranslate() - bounceAmount;}afterBouncePosition = s.maxTranslate();doBounce = true;allowMomentumBounce = true;}else {newPosition = s.maxTranslate();}}else if(newPosition > s.minTranslate()){if(s.params.freeModeMomentumBounce){if(newPosition - s.minTranslate() > bounceAmount){newPosition = s.minTranslate() + bounceAmount;}afterBouncePosition = s.minTranslate();doBounce = true;allowMomentumBounce = true;}else {newPosition = s.minTranslate();}}else if(s.params.freeModeSticky){var j=0,nextSlide;for(j = 0;j < s.snapGrid.length;j += 1) {if(s.snapGrid[j] > -newPosition){nextSlide = j;break;}}if(Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next'){newPosition = s.snapGrid[nextSlide];}else {newPosition = s.snapGrid[nextSlide - 1];}if(!s.rtl)newPosition = -newPosition;} //Fix duration
if(s.velocity !== 0){if(s.rtl){momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);}else {momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);}}else if(s.params.freeModeSticky){s.slideReset();return;}if(s.params.freeModeMomentumBounce && doBounce){s.updateProgress(afterBouncePosition);s.setWrapperTransition(momentumDuration);s.setWrapperTranslate(newPosition);s.onTransitionStart();s.animating = true;s.wrapper.transitionEnd(function(){if(!s || !allowMomentumBounce)return;s.emit('onMomentumBounce',s);s.setWrapperTransition(s.params.speed);s.setWrapperTranslate(afterBouncePosition);s.wrapper.transitionEnd(function(){if(!s)return;s.onTransitionEnd();});});}else if(s.velocity){s.updateProgress(newPosition);s.setWrapperTransition(momentumDuration);s.setWrapperTranslate(newPosition);s.onTransitionStart();if(!s.animating){s.animating = true;s.wrapper.transitionEnd(function(){if(!s)return;s.onTransitionEnd();});}}else {s.updateProgress(newPosition);}s.updateActiveIndex();}if(!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs){s.updateProgress();s.updateActiveIndex();}return;} // Find current slide
var i,stopIndex=0,groupSize=s.slidesSizesGrid[0];for(i = 0;i < s.slidesGrid.length;i += s.params.slidesPerGroup) {if(typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined'){if(currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]){stopIndex = i;groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];}}else {if(currentPos >= s.slidesGrid[i]){stopIndex = i;groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];}}} // Find current slide size
var ratio=(currentPos - s.slidesGrid[stopIndex]) / groupSize;if(timeDiff > s.params.longSwipesMs){ // Long touches
if(!s.params.longSwipes){s.slideTo(s.activeIndex);return;}if(s.swipeDirection === 'next'){if(ratio >= s.params.longSwipesRatio)s.slideTo(stopIndex + s.params.slidesPerGroup);else s.slideTo(stopIndex);}if(s.swipeDirection === 'prev'){if(ratio > 1 - s.params.longSwipesRatio)s.slideTo(stopIndex + s.params.slidesPerGroup);else s.slideTo(stopIndex);}}else { // Short swipes
if(!s.params.shortSwipes){s.slideTo(s.activeIndex);return;}if(s.swipeDirection === 'next'){s.slideTo(stopIndex + s.params.slidesPerGroup);}if(s.swipeDirection === 'prev'){s.slideTo(stopIndex);}}}; /*=========================
      Transitions
      ===========================*/s._slideTo = function(slideIndex,speed){return s.slideTo(slideIndex,speed,true,true);};s.slideTo = function(slideIndex,speed,runCallbacks,internal){if(typeof runCallbacks === 'undefined')runCallbacks = true;if(typeof slideIndex === 'undefined')slideIndex = 0;if(slideIndex < 0)slideIndex = 0;s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);if(s.snapIndex >= s.snapGrid.length)s.snapIndex = s.snapGrid.length - 1;var translate=-s.snapGrid[s.snapIndex]; // Stop autoplay
if(s.params.autoplay && s.autoplaying){if(internal || !s.params.autoplayDisableOnInteraction){s.pauseAutoplay(speed);}else {s.stopAutoplay();}} // Update progress
s.updateProgress(translate); // Normalize slideIndex
for(var i=0;i < s.slidesGrid.length;i++) {if(-Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)){slideIndex = i;}} // Directions locks
if(!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()){return false;}if(!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()){if((s.activeIndex || 0) !== slideIndex)return false;} // Update Index
if(typeof speed === 'undefined')speed = s.params.speed;s.previousIndex = s.activeIndex || 0;s.activeIndex = slideIndex;if(translate === s.translate){s.updateClasses();return false;}s.updateClasses();s.onTransitionStart(runCallbacks);var translateX=isH()?translate:0,translateY=isH()?0:translate;if(speed === 0){s.setWrapperTransition(0);s.setWrapperTranslate(translate);s.onTransitionEnd(runCallbacks);}else {s.setWrapperTransition(speed);s.setWrapperTranslate(translate);if(!s.animating){s.animating = true;s.wrapper.transitionEnd(function(){if(!s)return;s.onTransitionEnd(runCallbacks);});}}return true;};s.onTransitionStart = function(runCallbacks){if(typeof runCallbacks === 'undefined')runCallbacks = true;if(s.lazy)s.lazy.onTransitionStart();if(runCallbacks){s.emit('onTransitionStart',s);if(s.activeIndex !== s.previousIndex){s.emit('onSlideChangeStart',s);}}};s.onTransitionEnd = function(runCallbacks){s.animating = false;s.setWrapperTransition(0);if(typeof runCallbacks === 'undefined')runCallbacks = true;if(s.lazy)s.lazy.onTransitionEnd();if(runCallbacks){s.emit('onTransitionEnd',s);if(s.activeIndex !== s.previousIndex){s.emit('onSlideChangeEnd',s);}}if(s.params.hashnav && s.hashnav){s.hashnav.setHash();}};s.slideNext = function(runCallbacks,speed,internal){if(s.params.loop){if(s.animating)return false;s.fixLoop();var clientLeft=s.container[0].clientLeft;return s.slideTo(s.activeIndex + s.params.slidesPerGroup,speed,runCallbacks,internal);}else return s.slideTo(s.activeIndex + s.params.slidesPerGroup,speed,runCallbacks,internal);};s._slideNext = function(speed){return s.slideNext(true,speed,true);};s.slidePrev = function(runCallbacks,speed,internal){if(s.params.loop){if(s.animating)return false;s.fixLoop();var clientLeft=s.container[0].clientLeft;return s.slideTo(s.activeIndex - 1,speed,runCallbacks,internal);}else return s.slideTo(s.activeIndex - 1,speed,runCallbacks,internal);};s._slidePrev = function(speed){return s.slidePrev(true,speed,true);};s.slideReset = function(runCallbacks,speed,internal){return s.slideTo(s.activeIndex,speed,runCallbacks);}; /*=========================
      Translate/transition helpers
      ===========================*/s.setWrapperTransition = function(duration,byController){s.wrapper.transition(duration);if(s.params.effect !== 'slide' && s.effects[s.params.effect]){s.effects[s.params.effect].setTransition(duration);}if(s.params.parallax && s.parallax){s.parallax.setTransition(duration);}if(s.params.scrollbar && s.scrollbar){s.scrollbar.setTransition(duration);}if(s.params.control && s.controller){s.controller.setTransition(duration,byController);}s.emit('onSetTransition',s,duration);};s.setWrapperTranslate = function(translate,updateActiveIndex,byController){var x=0,y=0,z=0;if(isH()){x = s.rtl?-translate:translate;}else {y = translate;}if(!s.params.virtualTranslate){if(s.support.transforms3d)s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');else s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');}s.translate = isH()?x:y;if(updateActiveIndex)s.updateActiveIndex();if(s.params.effect !== 'slide' && s.effects[s.params.effect]){s.effects[s.params.effect].setTranslate(s.translate);}if(s.params.parallax && s.parallax){s.parallax.setTranslate(s.translate);}if(s.params.scrollbar && s.scrollbar){s.scrollbar.setTranslate(s.translate);}if(s.params.control && s.controller){s.controller.setTranslate(s.translate,byController);}s.emit('onSetTranslate',s,s.translate);};s.getTranslate = function(el,axis){var matrix,curTransform,curStyle,transformMatrix; // automatic axis detection
if(typeof axis === 'undefined'){axis = 'x';}if(s.params.virtualTranslate){return s.rtl?-s.translate:s.translate;}curStyle = window.getComputedStyle(el,null);if(window.WebKitCSSMatrix){ // Some old versions of Webkit choke when 'none' is passed; pass
// empty string instead in this case
transformMatrix = new window.WebKitCSSMatrix(curStyle.webkitTransform === 'none'?'':curStyle.webkitTransform);}else {transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(','matrix(1, 0, 0, 1,');matrix = transformMatrix.toString().split(',');}if(axis === 'x'){ //Latest Chrome and webkits Fix
if(window.WebKitCSSMatrix)curTransform = transformMatrix.m41;else if(matrix.length === 16)curTransform = parseFloat(matrix[12]);else curTransform = parseFloat(matrix[4]);}if(axis === 'y'){ //Latest Chrome and webkits Fix
if(window.WebKitCSSMatrix)curTransform = transformMatrix.m42;else if(matrix.length === 16)curTransform = parseFloat(matrix[13]);else curTransform = parseFloat(matrix[5]);}if(s.rtl && curTransform)curTransform = -curTransform;return curTransform || 0;};s.getWrapperTranslate = function(axis){if(typeof axis === 'undefined'){axis = isH()?'x':'y';}return s.getTranslate(s.wrapper[0],axis);}; /*=========================
      Observer
      ===========================*/s.observers = [];function initObserver(target,options){options = options || {}; // create an observer instance
var ObserverFunc=window.MutationObserver || window.WebkitMutationObserver;var observer=new ObserverFunc(function(mutations){mutations.forEach(function(mutation){s.onResize(true);s.emit('onObserverUpdate',s,mutation);});});observer.observe(target,{attributes:typeof options.attributes === 'undefined'?true:options.attributes,childList:typeof options.childList === 'undefined'?true:options.childList,characterData:typeof options.characterData === 'undefined'?true:options.characterData});s.observers.push(observer);}s.initObservers = function(){if(s.params.observeParents){var containerParents=s.container.parents();for(var i=0;i < containerParents.length;i++) {initObserver(containerParents[i]);}} // Observe container
initObserver(s.container[0],{childList:false}); // Observe wrapper
initObserver(s.wrapper[0],{attributes:false});};s.disconnectObservers = function(){for(var i=0;i < s.observers.length;i++) {s.observers[i].disconnect();}s.observers = [];}; /*=========================
      Loop
      ===========================*/ // Create looped slides
s.createLoop = function(){ // Remove duplicated slides
s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();var slides=s.wrapper.children('.' + s.params.slideClass);if(s.params.slidesPerView === 'auto' && !s.params.loopedSlides)s.params.loopedSlides = slides.length;s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView,10);s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;if(s.loopedSlides > slides.length){s.loopedSlides = slides.length;}var prependSlides=[],appendSlides=[],i;slides.each(function(index,el){var slide=$(this);if(index < s.loopedSlides)appendSlides.push(el);if(index < slides.length && index >= slides.length - s.loopedSlides)prependSlides.push(el);slide.attr('data-swiper-slide-index',index);});for(i = 0;i < appendSlides.length;i++) {s.wrapper.append($(appendSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));}for(i = prependSlides.length - 1;i >= 0;i--) {s.wrapper.prepend($(prependSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));}};s.destroyLoop = function(){s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();s.slides.removeAttr('data-swiper-slide-index');};s.fixLoop = function(){var newIndex; //Fix For Negative Oversliding
if(s.activeIndex < s.loopedSlides){newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;newIndex = newIndex + s.loopedSlides;s.slideTo(newIndex,0,false,true);}else if(s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2 || s.activeIndex > s.slides.length - s.params.slidesPerView * 2){newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;newIndex = newIndex + s.loopedSlides;s.slideTo(newIndex,0,false,true);}}; /*=========================
      Append/Prepend/Remove Slides
      ===========================*/s.appendSlide = function(slides){if(s.params.loop){s.destroyLoop();}if(typeof slides === 'object' && slides.length){for(var i=0;i < slides.length;i++) {if(slides[i])s.wrapper.append(slides[i]);}}else {s.wrapper.append(slides);}if(s.params.loop){s.createLoop();}if(!(s.params.observer && s.support.observer)){s.update(true);}};s.prependSlide = function(slides){if(s.params.loop){s.destroyLoop();}var newActiveIndex=s.activeIndex + 1;if(typeof slides === 'object' && slides.length){for(var i=0;i < slides.length;i++) {if(slides[i])s.wrapper.prepend(slides[i]);}newActiveIndex = s.activeIndex + slides.length;}else {s.wrapper.prepend(slides);}if(s.params.loop){s.createLoop();}if(!(s.params.observer && s.support.observer)){s.update(true);}s.slideTo(newActiveIndex,0,false);};s.removeSlide = function(slidesIndexes){if(s.params.loop){s.destroyLoop();s.slides = s.wrapper.children('.' + s.params.slideClass);}var newActiveIndex=s.activeIndex,indexToRemove;if(typeof slidesIndexes === 'object' && slidesIndexes.length){for(var i=0;i < slidesIndexes.length;i++) {indexToRemove = slidesIndexes[i];if(s.slides[indexToRemove])s.slides.eq(indexToRemove).remove();if(indexToRemove < newActiveIndex)newActiveIndex--;}newActiveIndex = Math.max(newActiveIndex,0);}else {indexToRemove = slidesIndexes;if(s.slides[indexToRemove])s.slides.eq(indexToRemove).remove();if(indexToRemove < newActiveIndex)newActiveIndex--;newActiveIndex = Math.max(newActiveIndex,0);}if(s.params.loop){s.createLoop();}if(!(s.params.observer && s.support.observer)){s.update(true);}if(s.params.loop){s.slideTo(newActiveIndex + s.loopedSlides,0,false);}else {s.slideTo(newActiveIndex,0,false);}};s.removeAllSlides = function(){var slidesIndexes=[];for(var i=0;i < s.slides.length;i++) {slidesIndexes.push(i);}s.removeSlide(slidesIndexes);}; /*=========================
      Effects
      ===========================*/s.effects = {fade:{setTranslate:function setTranslate(){for(var i=0;i < s.slides.length;i++) {var slide=s.slides.eq(i);var offset=slide[0].swiperSlideOffset;var tx=-offset;if(!s.params.virtualTranslate)tx = tx - s.translate;var ty=0;if(!isH()){ty = tx;tx = 0;}var slideOpacity=s.params.fade.crossFade?Math.max(1 - Math.abs(slide[0].progress),0):1 + Math.min(Math.max(slide[0].progress,-1),0);slide.css({opacity:slideOpacity}).transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');}},setTransition:function setTransition(duration){s.slides.transition(duration);if(s.params.virtualTranslate && duration !== 0){var eventTriggered=false;s.slides.transitionEnd(function(){if(eventTriggered)return;if(!s)return;eventTriggered = true;s.animating = false;var triggerEvents=['webkitTransitionEnd','transitionend','oTransitionEnd','MSTransitionEnd','msTransitionEnd'];for(var i=0;i < triggerEvents.length;i++) {s.wrapper.trigger(triggerEvents[i]);}});}}},cube:{setTranslate:function setTranslate(){var wrapperRotate=0,cubeShadow;if(s.params.cube.shadow){if(isH()){cubeShadow = s.wrapper.find('.swiper-cube-shadow');if(cubeShadow.length === 0){cubeShadow = $('<div class="swiper-cube-shadow"></div>');s.wrapper.append(cubeShadow);}cubeShadow.css({height:s.width + 'px'});}else {cubeShadow = s.container.find('.swiper-cube-shadow');if(cubeShadow.length === 0){cubeShadow = $('<div class="swiper-cube-shadow"></div>');s.container.append(cubeShadow);}}}for(var i=0;i < s.slides.length;i++) {var slide=s.slides.eq(i);var slideAngle=i * 90;var round=Math.floor(slideAngle / 360);if(s.rtl){slideAngle = -slideAngle;round = Math.floor(-slideAngle / 360);}var progress=Math.max(Math.min(slide[0].progress,1),-1);var tx=0,ty=0,tz=0;if(i % 4 === 0){tx = -round * 4 * s.size;tz = 0;}else if((i - 1) % 4 === 0){tx = 0;tz = -round * 4 * s.size;}else if((i - 2) % 4 === 0){tx = s.size + round * 4 * s.size;tz = s.size;}else if((i - 3) % 4 === 0){tx = -s.size;tz = 3 * s.size + s.size * 4 * round;}if(s.rtl){tx = -tx;}if(!isH()){ty = tx;tx = 0;}var transform='rotateX(' + (isH()?0:-slideAngle) + 'deg) rotateY(' + (isH()?slideAngle:0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';if(progress <= 1 && progress > -1){wrapperRotate = i * 90 + progress * 90;if(s.rtl)wrapperRotate = -i * 90 - progress * 90;}slide.transform(transform);if(s.params.cube.slideShadows){ //Set shadows
var shadowBefore=isH()?slide.find('.swiper-slide-shadow-left'):slide.find('.swiper-slide-shadow-top');var shadowAfter=isH()?slide.find('.swiper-slide-shadow-right'):slide.find('.swiper-slide-shadow-bottom');if(shadowBefore.length === 0){shadowBefore = $('<div class="swiper-slide-shadow-' + (isH()?'left':'top') + '"></div>');slide.append(shadowBefore);}if(shadowAfter.length === 0){shadowAfter = $('<div class="swiper-slide-shadow-' + (isH()?'right':'bottom') + '"></div>');slide.append(shadowAfter);}var shadowOpacity=slide[0].progress;if(shadowBefore.length)shadowBefore[0].style.opacity = -slide[0].progress;if(shadowAfter.length)shadowAfter[0].style.opacity = slide[0].progress;}}s.wrapper.css({'-webkit-transform-origin':'50% 50% -' + s.size / 2 + 'px','-moz-transform-origin':'50% 50% -' + s.size / 2 + 'px','-ms-transform-origin':'50% 50% -' + s.size / 2 + 'px','transform-origin':'50% 50% -' + s.size / 2 + 'px'});if(s.params.cube.shadow){if(isH()){cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + -s.width / 2 + 'px) rotateX(90deg) rotateZ(0deg) scale(' + s.params.cube.shadowScale + ')');}else {var shadowAngle=Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;var multiplier=1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);var scale1=s.params.cube.shadowScale,scale2=s.params.cube.shadowScale / multiplier,offset=s.params.cube.shadowOffset;cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + -s.height / 2 / scale2 + 'px) rotateX(-90deg)');}}var zFactor=s.isSafari || s.isUiWebView?-s.size / 2:0;s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (isH()?0:wrapperRotate) + 'deg) rotateY(' + (isH()?-wrapperRotate:0) + 'deg)');},setTransition:function setTransition(duration){s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);if(s.params.cube.shadow && !isH()){s.container.find('.swiper-cube-shadow').transition(duration);}}},coverflow:{setTranslate:function setTranslate(){var transform=s.translate;var center=isH()?-transform + s.width / 2:-transform + s.height / 2;var rotate=isH()?s.params.coverflow.rotate:-s.params.coverflow.rotate;var translate=s.params.coverflow.depth; //Each slide offset from center
for(var i=0,length=s.slides.length;i < length;i++) {var slide=s.slides.eq(i);var slideSize=s.slidesSizesGrid[i];var slideOffset=slide[0].swiperSlideOffset;var offsetMultiplier=(center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;var rotateY=isH()?rotate * offsetMultiplier:0;var rotateX=isH()?0:rotate * offsetMultiplier; // var rotateZ = 0
var translateZ=-translate * Math.abs(offsetMultiplier);var translateY=isH()?0:s.params.coverflow.stretch * offsetMultiplier;var translateX=isH()?s.params.coverflow.stretch * offsetMultiplier:0; //Fix for ultra small values
if(Math.abs(translateX) < 0.001)translateX = 0;if(Math.abs(translateY) < 0.001)translateY = 0;if(Math.abs(translateZ) < 0.001)translateZ = 0;if(Math.abs(rotateY) < 0.001)rotateY = 0;if(Math.abs(rotateX) < 0.001)rotateX = 0;var slideTransform='translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';slide.transform(slideTransform);slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;if(s.params.coverflow.slideShadows){ //Set shadows
var shadowBefore=isH()?slide.find('.swiper-slide-shadow-left'):slide.find('.swiper-slide-shadow-top');var shadowAfter=isH()?slide.find('.swiper-slide-shadow-right'):slide.find('.swiper-slide-shadow-bottom');if(shadowBefore.length === 0){shadowBefore = $('<div class="swiper-slide-shadow-' + (isH()?'left':'top') + '"></div>');slide.append(shadowBefore);}if(shadowAfter.length === 0){shadowAfter = $('<div class="swiper-slide-shadow-' + (isH()?'right':'bottom') + '"></div>');slide.append(shadowAfter);}if(shadowBefore.length)shadowBefore[0].style.opacity = offsetMultiplier > 0?offsetMultiplier:0;if(shadowAfter.length)shadowAfter[0].style.opacity = -offsetMultiplier > 0?-offsetMultiplier:0;}} //Set correct perspective for IE10
if(s.browser.ie){var ws=s.wrapper[0].style;ws.perspectiveOrigin = center + 'px 50%';}},setTransition:function setTransition(duration){s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);}}}; /*=========================
      Images Lazy Loading
      ===========================*/s.lazy = {initialImageLoaded:false,loadImageInSlide:function loadImageInSlide(index,loadInDuplicate){if(typeof index === 'undefined')return;if(typeof loadInDuplicate === 'undefined')loadInDuplicate = true;if(s.slides.length === 0)return;var slide=s.slides.eq(index);var img=slide.find('.swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)');if(slide.hasClass('swiper-lazy') && !slide.hasClass('swiper-lazy-loaded') && !slide.hasClass('swiper-lazy-loading')){img.add(slide[0]);}if(img.length === 0)return;img.each(function(){var _img=$(this);_img.addClass('swiper-lazy-loading');var background=_img.attr('data-background');var src=_img.attr('data-src');s.loadImage(_img[0],src || background,false,function(){if(background){_img.css('background-image','url(' + background + ')');_img.removeAttr('data-background');}else {_img.attr('src',src);_img.removeAttr('data-src');}_img.addClass('swiper-lazy-loaded').removeClass('swiper-lazy-loading');slide.find('.swiper-lazy-preloader, .preloader').remove();if(s.params.loop && loadInDuplicate){var slideOriginalIndex=slide.attr('data-swiper-slide-index');if(slide.hasClass(s.params.slideDuplicateClass)){var originalSlide=s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');s.lazy.loadImageInSlide(originalSlide.index(),false);}else {var duplicatedSlide=s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');s.lazy.loadImageInSlide(duplicatedSlide.index(),false);}}s.emit('onLazyImageReady',s,slide[0],_img[0]);});s.emit('onLazyImageLoad',s,slide[0],_img[0]);});},load:function load(){var i;if(s.params.watchSlidesVisibility){s.wrapper.children('.' + s.params.slideVisibleClass).each(function(){s.lazy.loadImageInSlide($(this).index());});}else {if(s.params.slidesPerView > 1){for(i = s.activeIndex;i < s.activeIndex + s.params.slidesPerView;i++) {if(s.slides[i])s.lazy.loadImageInSlide(i);}}else {s.lazy.loadImageInSlide(s.activeIndex);}}if(s.params.lazyLoadingInPrevNext){if(s.params.slidesPerView > 1){ // Next Slides
for(i = s.activeIndex + s.params.slidesPerView;i < s.activeIndex + s.params.slidesPerView + s.params.slidesPerView;i++) {if(s.slides[i])s.lazy.loadImageInSlide(i);} // Prev Slides
for(i = s.activeIndex - s.params.slidesPerView;i < s.activeIndex;i++) {if(s.slides[i])s.lazy.loadImageInSlide(i);}}else {var nextSlide=s.wrapper.children('.' + s.params.slideNextClass);if(nextSlide.length > 0)s.lazy.loadImageInSlide(nextSlide.index());var prevSlide=s.wrapper.children('.' + s.params.slidePrevClass);if(prevSlide.length > 0)s.lazy.loadImageInSlide(prevSlide.index());}}},onTransitionStart:function onTransitionStart(){if(s.params.lazyLoading){if(s.params.lazyLoadingOnTransitionStart || !s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded){s.lazy.load();}}},onTransitionEnd:function onTransitionEnd(){if(s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart){s.lazy.load();}}}; /*=========================
      Scrollbar
      ===========================*/s.scrollbar = {set:function set(){if(!s.params.scrollbar)return;var sb=s.scrollbar;sb.track = $(s.params.scrollbar);sb.drag = sb.track.find('.swiper-scrollbar-drag');if(sb.drag.length === 0){sb.drag = $('<div class="swiper-scrollbar-drag"></div>');sb.track.append(sb.drag);}sb.drag[0].style.width = '';sb.drag[0].style.height = '';sb.trackSize = isH()?sb.track[0].offsetWidth:sb.track[0].offsetHeight;sb.divider = s.size / s.virtualSize;sb.moveDivider = sb.divider * (sb.trackSize / s.size);sb.dragSize = sb.trackSize * sb.divider;if(isH()){sb.drag[0].style.width = sb.dragSize + 'px';}else {sb.drag[0].style.height = sb.dragSize + 'px';}if(sb.divider >= 1){sb.track[0].style.display = 'none';}else {sb.track[0].style.display = '';}if(s.params.scrollbarHide){sb.track[0].style.opacity = 0;}},setTranslate:function setTranslate(){if(!s.params.scrollbar)return;var diff;var sb=s.scrollbar;var translate=s.translate || 0;var newPos;var newSize=sb.dragSize;newPos = (sb.trackSize - sb.dragSize) * s.progress;if(s.rtl && isH()){newPos = -newPos;if(newPos > 0){newSize = sb.dragSize - newPos;newPos = 0;}else if(-newPos + sb.dragSize > sb.trackSize){newSize = sb.trackSize + newPos;}}else {if(newPos < 0){newSize = sb.dragSize + newPos;newPos = 0;}else if(newPos + sb.dragSize > sb.trackSize){newSize = sb.trackSize - newPos;}}if(isH()){if(s.support.transforms3d){sb.drag.transform('translate3d(' + newPos + 'px, 0, 0)');}else {sb.drag.transform('translateX(' + newPos + 'px)');}sb.drag[0].style.width = newSize + 'px';}else {if(s.support.transforms3d){sb.drag.transform('translate3d(0px, ' + newPos + 'px, 0)');}else {sb.drag.transform('translateY(' + newPos + 'px)');}sb.drag[0].style.height = newSize + 'px';}if(s.params.scrollbarHide){clearTimeout(sb.timeout);sb.track[0].style.opacity = 1;sb.timeout = setTimeout(function(){sb.track[0].style.opacity = 0;sb.track.transition(400);},1000);}},setTransition:function setTransition(duration){if(!s.params.scrollbar)return;s.scrollbar.drag.transition(duration);}}; /*=========================
      Controller
      ===========================*/s.controller = {LinearSpline:function LinearSpline(x,y){this.x = x;this.y = y;this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
// (x1,y1) is the known point before given value,
// (x3,y3) is the known point after given value.
var i1,i3;var l=this.x.length;this.interpolate = function(x2){if(!x2)return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):
i3 = binarySearch(this.x,x2);i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
// y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];};var binarySearch=(function(){var maxIndex,minIndex,guess;return function(array,val){minIndex = -1;maxIndex = array.length;while(maxIndex - minIndex > 1) if(array[guess = maxIndex + minIndex >> 1] <= val){minIndex = guess;}else {maxIndex = guess;}return maxIndex;};})();}, //xxx: for now i will just save one spline function to to
getInterpolateFunction:function getInterpolateFunction(c){if(!s.controller.spline)s.controller.spline = s.params.loop?new s.controller.LinearSpline(s.slidesGrid,c.slidesGrid):new s.controller.LinearSpline(s.snapGrid,c.snapGrid);},setTranslate:function setTranslate(translate,byController){var controlled=s.params.control;var multiplier,controlledTranslate;function setControlledTranslate(c){ // this will create an Interpolate function based on the snapGrids
// x is the Grid of the scrolled scroller and y will be the controlled scroller
// it makes sense to create this only once and recall it for the interpolation
// the function does a lot of value caching for performance
translate = c.rtl && c.params.direction === 'horizontal'?-s.translate:s.translate;if(s.params.controlBy === 'slide'){s.controller.getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
// but it did not work out
controlledTranslate = -s.controller.spline.interpolate(-translate);}if(!controlledTranslate || s.params.controlBy === 'container'){multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();}if(s.params.controlInverse){controlledTranslate = c.maxTranslate() - controlledTranslate;}c.updateProgress(controlledTranslate);c.setWrapperTranslate(controlledTranslate,false,s);c.updateActiveIndex();}if(s.isArray(controlled)){for(var i=0;i < controlled.length;i++) {if(controlled[i] !== byController && controlled[i] instanceof Swiper){setControlledTranslate(controlled[i]);}}}else if(controlled instanceof Swiper && byController !== controlled){setControlledTranslate(controlled);}},setTransition:function setTransition(duration,byController){var controlled=s.params.control;var i;function setControlledTransition(c){c.setWrapperTransition(duration,s);if(duration !== 0){c.onTransitionStart();c.wrapper.transitionEnd(function(){if(!controlled)return;if(c.params.loop && s.params.controlBy === 'slide'){c.fixLoop();}c.onTransitionEnd();});}}if(s.isArray(controlled)){for(i = 0;i < controlled.length;i++) {if(controlled[i] !== byController && controlled[i] instanceof Swiper){setControlledTransition(controlled[i]);}}}else if(controlled instanceof Swiper && byController !== controlled){setControlledTransition(controlled);}}}; /*=========================
      Hash Navigation
      ===========================*/s.hashnav = {init:function init(){if(!s.params.hashnav)return;s.hashnav.initialized = true;var hash=document.location.hash.replace('#','');if(!hash)return;var speed=0;for(var i=0,length=s.slides.length;i < length;i++) {var slide=s.slides.eq(i);var slideHash=slide.attr('data-hash');if(slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)){var index=slide.index();s.slideTo(index,speed,s.params.runCallbacksOnInit,true);}}},setHash:function setHash(){if(!s.hashnav.initialized || !s.params.hashnav)return;document.location.hash = s.slides.eq(s.activeIndex).attr('data-hash') || '';}}; /*=========================
      Keyboard Control
      ===========================*/function handleKeyboard(e){if(e.originalEvent)e = e.originalEvent; //jquery fix
var kc=e.keyCode || e.charCode; // Directions locks
if(!s.params.allowSwipeToNext && (isH() && kc === 39 || !isH() && kc === 40)){return false;}if(!s.params.allowSwipeToPrev && (isH() && kc === 37 || !isH() && kc === 38)){return false;}if(e.shiftKey || e.altKey || e.ctrlKey || e.metaKey){return;}if(document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')){return;}if(kc === 37 || kc === 39 || kc === 38 || kc === 40){var inView=false; //Check that swiper should be inside of visible area of window
if(s.container.parents('.swiper-slide').length > 0 && s.container.parents('.swiper-slide-active').length === 0){return;}var windowScroll={left:window.pageXOffset,top:window.pageYOffset};var windowWidth=window.innerWidth;var windowHeight=window.innerHeight;var swiperOffset=s.container.offset();if(s.rtl)swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;var swiperCoord=[[swiperOffset.left,swiperOffset.top],[swiperOffset.left + s.width,swiperOffset.top],[swiperOffset.left,swiperOffset.top + s.height],[swiperOffset.left + s.width,swiperOffset.top + s.height]];for(var i=0;i < swiperCoord.length;i++) {var point=swiperCoord[i];if(point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth && point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight){inView = true;}}if(!inView)return;}if(isH()){if(kc === 37 || kc === 39){if(e.preventDefault)e.preventDefault();else e.returnValue = false;}if(kc === 39 && !s.rtl || kc === 37 && s.rtl)s.slideNext();if(kc === 37 && !s.rtl || kc === 39 && s.rtl)s.slidePrev();}else {if(kc === 38 || kc === 40){if(e.preventDefault)e.preventDefault();else e.returnValue = false;}if(kc === 40)s.slideNext();if(kc === 38)s.slidePrev();}}s.disableKeyboardControl = function(){$(document).off('keydown',handleKeyboard);};s.enableKeyboardControl = function(){$(document).on('keydown',handleKeyboard);}; /*=========================
      Mousewheel Control
      ===========================*/s.mousewheel = {event:false,lastScrollTime:new window.Date().getTime()};if(s.params.mousewheelControl){try{new window.WheelEvent('wheel');s.mousewheel.event = 'wheel';}catch(e) {}if(!s.mousewheel.event && document.onmousewheel !== undefined){s.mousewheel.event = 'mousewheel';}if(!s.mousewheel.event){s.mousewheel.event = 'DOMMouseScroll';}}function handleMousewheel(e){if(e.originalEvent)e = e.originalEvent; //jquery fix
var we=s.mousewheel.event;var delta=0; //Opera & IE
if(e.detail)delta = -e.detail;else if(we === 'mousewheel'){if(s.params.mousewheelForceToAxis){if(isH()){if(Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY))delta = e.wheelDeltaX;else return;}else {if(Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX))delta = e.wheelDeltaY;else return;}}else {delta = e.wheelDelta;}}else if(we === 'DOMMouseScroll')delta = -e.detail;else if(we === 'wheel'){if(s.params.mousewheelForceToAxis){if(isH()){if(Math.abs(e.deltaX) > Math.abs(e.deltaY))delta = -e.deltaX;else return;}else {if(Math.abs(e.deltaY) > Math.abs(e.deltaX))delta = -e.deltaY;else return;}}else {delta = Math.abs(e.deltaX) > Math.abs(e.deltaY)?-e.deltaX:-e.deltaY;}}if(s.params.mousewheelInvert)delta = -delta;if(!s.params.freeMode){if(new window.Date().getTime() - s.mousewheel.lastScrollTime > 60){if(delta < 0){if((!s.isEnd || s.params.loop) && !s.animating)s.slideNext();else if(s.params.mousewheelReleaseOnEdges)return true;}else {if((!s.isBeginning || s.params.loop) && !s.animating)s.slidePrev();else if(s.params.mousewheelReleaseOnEdges)return true;}}s.mousewheel.lastScrollTime = new window.Date().getTime();}else { //Freemode or scrollContainer:
var position=s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;if(position > 0)position = 0;if(position < s.maxTranslate())position = s.maxTranslate();s.setWrapperTransition(0);s.setWrapperTranslate(position);s.updateProgress();s.updateActiveIndex();if(s.params.freeModeSticky){clearTimeout(s.mousewheel.timeout);s.mousewheel.timeout = setTimeout(function(){s.slideReset();},300);} // Return page scroll on edge positions
if(position === 0 || position === s.maxTranslate())return;}if(s.params.autoplay)s.stopAutoplay();if(e.preventDefault)e.preventDefault();else e.returnValue = false;return false;}s.disableMousewheelControl = function(){if(!s.mousewheel.event)return false;s.container.off(s.mousewheel.event,handleMousewheel);return true;};s.enableMousewheelControl = function(){if(!s.mousewheel.event)return false;s.container.on(s.mousewheel.event,handleMousewheel);return true;}; /*=========================
      Parallax
      ===========================*/function setParallaxTransform(el,progress){el = $(el);var p,pX,pY;p = el.attr('data-swiper-parallax') || '0';pX = el.attr('data-swiper-parallax-x');pY = el.attr('data-swiper-parallax-y');if(pX || pY){pX = pX || '0';pY = pY || '0';}else {if(isH()){pX = p;pY = '0';}else {pY = p;pX = '0';}}if(pX.indexOf('%') >= 0){pX = parseInt(pX,10) * progress + '%';}else {pX = pX * progress + 'px';}if(pY.indexOf('%') >= 0){pY = parseInt(pY,10) * progress + '%';}else {pY = pY * progress + 'px';}el.transform('translate3d(' + pX + ', ' + pY + ',0px)');}s.parallax = {setTranslate:function setTranslate(){s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){setParallaxTransform(this,s.progress);});s.slides.each(function(){var slide=$(this);slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){var progress=Math.min(Math.max(slide[0].progress,-1),1);setParallaxTransform(this,progress);});});},setTransition:function setTransition(duration){if(typeof duration === 'undefined')duration = s.params.speed;s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){var el=$(this);var parallaxDuration=parseInt(el.attr('data-swiper-parallax-duration'),10) || duration;if(duration === 0)parallaxDuration = 0;el.transition(parallaxDuration);});}}; /*=========================
      Plugins API. Collect all and init all plugins
      ===========================*/s._plugins = [];for(var plugin in s.plugins) {var p=s.plugins[plugin](s,s.params[plugin]);if(p)s._plugins.push(p);} // Method to call all plugins event/method
s.callPlugins = function(eventName){for(var i=0;i < s._plugins.length;i++) {if(eventName in s._plugins[i]){s._plugins[i][eventName](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);}}}; /*=========================
      Events/Callbacks/Plugins Emitter
      ===========================*/function normalizeEventName(eventName){if(eventName.indexOf('on') !== 0){if(eventName[0] !== eventName[0].toUpperCase()){eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);}else {eventName = 'on' + eventName;}}return eventName;}s.emitterEventListeners = {};s.emit = function(eventName){ // Trigger callbacks
if(s.params[eventName]){s.params[eventName](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);}var i; // Trigger events
if(s.emitterEventListeners[eventName]){for(i = 0;i < s.emitterEventListeners[eventName].length;i++) {s.emitterEventListeners[eventName][i](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);}} // Trigger plugins
if(s.callPlugins)s.callPlugins(eventName,arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);};s.on = function(eventName,handler){eventName = normalizeEventName(eventName);if(!s.emitterEventListeners[eventName])s.emitterEventListeners[eventName] = [];s.emitterEventListeners[eventName].push(handler);return s;};s.off = function(eventName,handler){var i;eventName = normalizeEventName(eventName);if(typeof handler === 'undefined'){ // Remove all handlers for such event
s.emitterEventListeners[eventName] = [];return s;}if(!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0)return;for(i = 0;i < s.emitterEventListeners[eventName].length;i++) {if(s.emitterEventListeners[eventName][i] === handler)s.emitterEventListeners[eventName].splice(i,1);}return s;};s.once = function(eventName,handler){eventName = normalizeEventName(eventName);var _handler=function _handler(){handler(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);s.off(eventName,_handler);};s.on(eventName,_handler);return s;}; // Accessibility tools
s.a11y = {makeFocusable:function makeFocusable($el){$el.attr('tabIndex','0');return $el;},addRole:function addRole($el,role){$el.attr('role',role);return $el;},addLabel:function addLabel($el,label){$el.attr('aria-label',label);return $el;},disable:function disable($el){$el.attr('aria-disabled',true);return $el;},enable:function enable($el){$el.attr('aria-disabled',false);return $el;},onEnterKey:function onEnterKey(event){if(event.keyCode !== 13)return;if($(event.target).is(s.params.nextButton)){s.onClickNext(event);if(s.isEnd){s.a11y.notify(s.params.lastSlideMessage);}else {s.a11y.notify(s.params.nextSlideMessage);}}else if($(event.target).is(s.params.prevButton)){s.onClickPrev(event);if(s.isBeginning){s.a11y.notify(s.params.firstSlideMessage);}else {s.a11y.notify(s.params.prevSlideMessage);}}if($(event.target).is('.' + s.params.bulletClass)){$(event.target)[0].click();}},liveRegion:$('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'),notify:function notify(message){var notification=s.a11y.liveRegion;if(notification.length === 0)return;notification.html('');notification.html(message);},init:function init(){ // Setup accessibility
if(s.params.nextButton){var nextButton=$(s.params.nextButton);s.a11y.makeFocusable(nextButton);s.a11y.addRole(nextButton,'button');s.a11y.addLabel(nextButton,s.params.nextSlideMessage);}if(s.params.prevButton){var prevButton=$(s.params.prevButton);s.a11y.makeFocusable(prevButton);s.a11y.addRole(prevButton,'button');s.a11y.addLabel(prevButton,s.params.prevSlideMessage);}$(s.container).append(s.a11y.liveRegion);},initPagination:function initPagination(){if(s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length){s.bullets.each(function(){var bullet=$(this);s.a11y.makeFocusable(bullet);s.a11y.addRole(bullet,'button');s.a11y.addLabel(bullet,s.params.paginationBulletMessage.replace(/{{index}}/,bullet.index() + 1));});}},destroy:function destroy(){if(s.a11y.liveRegion && s.a11y.liveRegion.length > 0)s.a11y.liveRegion.remove();}}; /*=========================
      Init/Destroy
      ===========================*/s.init = function(){if(s.params.loop)s.createLoop();s.updateContainerSize();s.updateSlidesSize();s.updatePagination();if(s.params.scrollbar && s.scrollbar){s.scrollbar.set();}if(s.params.effect !== 'slide' && s.effects[s.params.effect]){if(!s.params.loop)s.updateProgress();s.effects[s.params.effect].setTranslate();}if(s.params.loop){s.slideTo(s.params.initialSlide + s.loopedSlides,0,s.params.runCallbacksOnInit);}else {s.slideTo(s.params.initialSlide,0,s.params.runCallbacksOnInit);if(s.params.initialSlide === 0){if(s.parallax && s.params.parallax)s.parallax.setTranslate();if(s.lazy && s.params.lazyLoading){s.lazy.load();s.lazy.initialImageLoaded = true;}}}s.attachEvents();if(s.params.observer && s.support.observer){s.initObservers();}if(s.params.preloadImages && !s.params.lazyLoading){s.preloadImages();}if(s.params.autoplay){s.startAutoplay();}if(s.params.keyboardControl){if(s.enableKeyboardControl)s.enableKeyboardControl();}if(s.params.mousewheelControl){if(s.enableMousewheelControl)s.enableMousewheelControl();}if(s.params.hashnav){if(s.hashnav)s.hashnav.init();}if(s.params.a11y && s.a11y)s.a11y.init();s.emit('onInit',s);}; // Cleanup dynamic styles
s.cleanupStyles = function(){ // Container
s.container.removeClass(s.classNames.join(' ')).removeAttr('style'); // Wrapper
s.wrapper.removeAttr('style'); // Slides
if(s.slides && s.slides.length){s.slides.removeClass([s.params.slideVisibleClass,s.params.slideActiveClass,s.params.slideNextClass,s.params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-column').removeAttr('data-swiper-row');} // Pagination/Bullets
if(s.paginationContainer && s.paginationContainer.length){s.paginationContainer.removeClass(s.params.paginationHiddenClass);}if(s.bullets && s.bullets.length){s.bullets.removeClass(s.params.bulletActiveClass);} // Buttons
if(s.params.prevButton)$(s.params.prevButton).removeClass(s.params.buttonDisabledClass);if(s.params.nextButton)$(s.params.nextButton).removeClass(s.params.buttonDisabledClass); // Scrollbar
if(s.params.scrollbar && s.scrollbar){if(s.scrollbar.track && s.scrollbar.track.length)s.scrollbar.track.removeAttr('style');if(s.scrollbar.drag && s.scrollbar.drag.length)s.scrollbar.drag.removeAttr('style');}}; // Destroy
s.destroy = function(deleteInstance,cleanupStyles){ // Detach evebts
s.detachEvents(); // Stop autoplay
s.stopAutoplay(); // Destroy loop
if(s.params.loop){s.destroyLoop();} // Cleanup styles
if(cleanupStyles){s.cleanupStyles();} // Disconnect observer
s.disconnectObservers(); // Disable keyboard/mousewheel
if(s.params.keyboardControl){if(s.disableKeyboardControl)s.disableKeyboardControl();}if(s.params.mousewheelControl){if(s.disableMousewheelControl)s.disableMousewheelControl();} // Disable a11y
if(s.params.a11y && s.a11y)s.a11y.destroy(); // Destroy callback
s.emit('onDestroy'); // Delete instance
if(deleteInstance !== false)s = null;};s.init(); // Return swiper instance
return s;} /*===========================
Add .swiper plugin from Dom libraries
===========================*/function addLibraryPlugin(lib){lib.fn.swiper = function(params){var firstInstance;lib(this).each(function(){var s=new Swiper(this,params);if(!firstInstance)firstInstance = s;});return firstInstance;};}return {setters:[],execute:function(){; /*==================================================
    Prototype
====================================================*/Swiper.prototype = {isSafari:(function(){var ua=navigator.userAgent.toLowerCase();return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;})(),isUiWebView:/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),isArray:function isArray(arr){return Object.prototype.toString.apply(arr) === '[object Array]';}, /*==================================================
    Browser
    ====================================================*/browser:{ie:window.navigator.pointerEnabled || window.navigator.msPointerEnabled,ieTouch:window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1 || window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1}, /*==================================================
    Devices
    ====================================================*/device:(function(){var ua=navigator.userAgent;var android=ua.match(/(Android);?[\s\/]+([\d.]+)?/);var ipad=ua.match(/(iPad).*OS\s([\d_]+)/);var ipod=ua.match(/(iPod)(.*OS\s([\d_]+))?/);var iphone=!ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);return {ios:ipad || iphone || ipod,android:android};})(), /*==================================================
    Feature Detection
    ====================================================*/support:{touch:window.Modernizr && Modernizr.touch === true || (function(){return !!('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch);})(),transforms3d:window.Modernizr && Modernizr.csstransforms3d === true || (function(){var div=document.createElement('div').style;return 'webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div;})(),flexbox:(function(){var div=document.createElement('div').style;var styles='alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient'.split(' ');for(var i=0;i < styles.length;i++) {if(styles[i] in div)return true;}})(),observer:(function(){return 'MutationObserver' in window || 'WebkitMutationObserver' in window;})()}, /*==================================================
    Plugins
    ====================================================*/plugins:{}}; /*===========================
Dom7 Library
===========================*/Dom7 = (function(){var Dom7=function Dom7(arr){var _this=this,i=0; // Create array-like object
for(i = 0;i < arr.length;i++) {_this[i] = arr[i];}_this.length = arr.length; // Return collection with methods
return this;};var $=function $(selector,context){var arr=[],i=0;if(selector && !context){if(selector instanceof Dom7){return selector;}}if(selector){ // String
if(typeof selector === 'string'){var els,tempParent,html=selector.trim();if(html.indexOf('<') >= 0 && html.indexOf('>') >= 0){var toCreate='div';if(html.indexOf('<li') === 0)toCreate = 'ul';if(html.indexOf('<tr') === 0)toCreate = 'tbody';if(html.indexOf('<td') === 0 || html.indexOf('<th') === 0)toCreate = 'tr';if(html.indexOf('<tbody') === 0)toCreate = 'table';if(html.indexOf('<option') === 0)toCreate = 'select';tempParent = document.createElement(toCreate);tempParent.innerHTML = selector;for(i = 0;i < tempParent.childNodes.length;i++) {arr.push(tempParent.childNodes[i]);}}else {if(!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)){ // Pure ID selector
els = [document.getElementById(selector.split('#')[1])];}else { // Other selectors
els = (context || document).querySelectorAll(selector);}for(i = 0;i < els.length;i++) {if(els[i])arr.push(els[i]);}}}else if(selector.nodeType || selector === window || selector === document){arr.push(selector);}else if(selector.length > 0 && selector[0].nodeType){for(i = 0;i < selector.length;i++) {arr.push(selector[i]);}}}return new Dom7(arr);};Dom7.prototype = { // Classes and attriutes
addClass:function addClass(className){if(typeof className === 'undefined'){return this;}var classes=className.split(' ');for(var i=0;i < classes.length;i++) {for(var j=0;j < this.length;j++) {this[j].classList.add(classes[i]);}}return this;},removeClass:function removeClass(className){var classes=className.split(' ');for(var i=0;i < classes.length;i++) {for(var j=0;j < this.length;j++) {this[j].classList.remove(classes[i]);}}return this;},hasClass:function hasClass(className){if(!this[0])return false;else return this[0].classList.contains(className);},toggleClass:function toggleClass(className){var classes=className.split(' ');for(var i=0;i < classes.length;i++) {for(var j=0;j < this.length;j++) {this[j].classList.toggle(classes[i]);}}return this;},attr:function attr(attrs,value){if(arguments.length === 1 && typeof attrs === 'string'){ // Get attr
if(this[0])return this[0].getAttribute(attrs);else return undefined;}else { // Set attrs
for(var i=0;i < this.length;i++) {if(arguments.length === 2){ // String
this[i].setAttribute(attrs,value);}else { // Object
for(var attrName in attrs) {this[i][attrName] = attrs[attrName];this[i].setAttribute(attrName,attrs[attrName]);}}}return this;}},removeAttr:function removeAttr(attr){for(var i=0;i < this.length;i++) {this[i].removeAttribute(attr);}return this;},data:function data(key,value){if(typeof value === 'undefined'){ // Get value
if(this[0]){var dataKey=this[0].getAttribute('data-' + key);if(dataKey)return dataKey;else if(this[0].dom7ElementDataStorage && key in this[0].dom7ElementDataStorage)return this[0].dom7ElementDataStorage[key];else return undefined;}else return undefined;}else { // Set value
for(var i=0;i < this.length;i++) {var el=this[i];if(!el.dom7ElementDataStorage)el.dom7ElementDataStorage = {};el.dom7ElementDataStorage[key] = value;}return this;}}, // Transforms
transform:function transform(_transform){for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = _transform;}return this;},transition:function transition(duration){if(typeof duration !== 'string'){duration = duration + 'ms';}for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;}return this;}, //Events
on:function on(eventName,targetSelector,listener,capture){function handleLiveEvent(e){var target=e.target;if($(target).is(targetSelector))listener.call(target,e);else {var parents=$(target).parents();for(var k=0;k < parents.length;k++) {if($(parents[k]).is(targetSelector))listener.call(parents[k],e);}}}var events=eventName.split(' ');var i,j;for(i = 0;i < this.length;i++) {if(typeof targetSelector === 'function' || targetSelector === false){ // Usual events
if(typeof targetSelector === 'function'){listener = arguments[1];capture = arguments[2] || false;}for(j = 0;j < events.length;j++) {this[i].addEventListener(events[j],listener,capture);}}else { //Live events
for(j = 0;j < events.length;j++) {if(!this[i].dom7LiveListeners)this[i].dom7LiveListeners = [];this[i].dom7LiveListeners.push({listener:listener,liveListener:handleLiveEvent});this[i].addEventListener(events[j],handleLiveEvent,capture);}}}return this;},off:function off(eventName,targetSelector,listener,capture){var events=eventName.split(' ');for(var i=0;i < events.length;i++) {for(var j=0;j < this.length;j++) {if(typeof targetSelector === 'function' || targetSelector === false){ // Usual events
if(typeof targetSelector === 'function'){listener = arguments[1];capture = arguments[2] || false;}this[j].removeEventListener(events[i],listener,capture);}else { // Live event
if(this[j].dom7LiveListeners){for(var k=0;k < this[j].dom7LiveListeners.length;k++) {if(this[j].dom7LiveListeners[k].listener === listener){this[j].removeEventListener(events[i],this[j].dom7LiveListeners[k].liveListener,capture);}}}}}}return this;},once:function once(eventName,targetSelector,listener,capture){var dom=this;if(typeof targetSelector === 'function'){targetSelector = false;listener = arguments[1];capture = arguments[2];}function proxy(e){listener(e);dom.off(eventName,targetSelector,proxy,capture);}dom.on(eventName,targetSelector,proxy,capture);},trigger:function trigger(eventName,eventData){for(var i=0;i < this.length;i++) {var evt;try{evt = new window.CustomEvent(eventName,{detail:eventData,bubbles:true,cancelable:true});}catch(e) {evt = document.createEvent('Event');evt.initEvent(eventName,true,true);evt.detail = eventData;}this[i].dispatchEvent(evt);}return this;},transitionEnd:function transitionEnd(callback){var events=['webkitTransitionEnd','transitionend','oTransitionEnd','MSTransitionEnd','msTransitionEnd'],i,j,dom=this;function fireCallBack(e){ /*jshint validthis:true */if(e.target !== this)return;callback.call(this,e);for(i = 0;i < events.length;i++) {dom.off(events[i],fireCallBack);}}if(callback){for(i = 0;i < events.length;i++) {dom.on(events[i],fireCallBack);}}return this;}, // Sizing/Styles
width:function width(){if(this[0] === window){return window.innerWidth;}else {if(this.length > 0){return parseFloat(this.css('width'));}else {return null;}}},outerWidth:function outerWidth(includeMargins){if(this.length > 0){if(includeMargins)return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));else return this[0].offsetWidth;}else return null;},height:function height(){if(this[0] === window){return window.innerHeight;}else {if(this.length > 0){return parseFloat(this.css('height'));}else {return null;}}},outerHeight:function outerHeight(includeMargins){if(this.length > 0){if(includeMargins)return this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom'));else return this[0].offsetHeight;}else return null;},offset:function offset(){if(this.length > 0){var el=this[0];var box=el.getBoundingClientRect();var body=document.body;var clientTop=el.clientTop || body.clientTop || 0;var clientLeft=el.clientLeft || body.clientLeft || 0;var scrollTop=window.pageYOffset || el.scrollTop;var scrollLeft=window.pageXOffset || el.scrollLeft;return {top:box.top + scrollTop - clientTop,left:box.left + scrollLeft - clientLeft};}else {return null;}},css:function css(props,value){var i;if(arguments.length === 1){if(typeof props === 'string'){if(this[0])return window.getComputedStyle(this[0],null).getPropertyValue(props);}else {for(i = 0;i < this.length;i++) {for(var prop in props) {this[i].style[prop] = props[prop];}}return this;}}if(arguments.length === 2 && typeof props === 'string'){for(i = 0;i < this.length;i++) {this[i].style[props] = value;}return this;}return this;}, //Dom manipulation
each:function each(callback){for(var i=0;i < this.length;i++) {callback.call(this[i],i,this[i]);}return this;},html:function html(_html){if(typeof _html === 'undefined'){return this[0]?this[0].innerHTML:undefined;}else {for(var i=0;i < this.length;i++) {this[i].innerHTML = _html;}return this;}},is:function is(selector){if(!this[0])return false;var compareWith,i;if(typeof selector === 'string'){var el=this[0];if(el === document)return selector === document;if(el === window)return selector === window;if(el.matches)return el.matches(selector);else if(el.webkitMatchesSelector)return el.webkitMatchesSelector(selector);else if(el.mozMatchesSelector)return el.mozMatchesSelector(selector);else if(el.msMatchesSelector)return el.msMatchesSelector(selector);else {compareWith = $(selector);for(i = 0;i < compareWith.length;i++) {if(compareWith[i] === this[0])return true;}return false;}}else if(selector === document)return this[0] === document;else if(selector === window)return this[0] === window;else {if(selector.nodeType || selector instanceof Dom7){compareWith = selector.nodeType?[selector]:selector;for(i = 0;i < compareWith.length;i++) {if(compareWith[i] === this[0])return true;}return false;}return false;}},index:function index(){if(this[0]){var child=this[0];var i=0;while((child = child.previousSibling) !== null) {if(child.nodeType === 1)i++;}return i;}else return undefined;},eq:function eq(index){if(typeof index === 'undefined')return this;var length=this.length;var returnIndex;if(index > length - 1){return new Dom7([]);}if(index < 0){returnIndex = length + index;if(returnIndex < 0)return new Dom7([]);else return new Dom7([this[returnIndex]]);}return new Dom7([this[index]]);},append:function append(newChild){var i,j;for(i = 0;i < this.length;i++) {if(typeof newChild === 'string'){var tempDiv=document.createElement('div');tempDiv.innerHTML = newChild;while(tempDiv.firstChild) {this[i].appendChild(tempDiv.firstChild);}}else if(newChild instanceof Dom7){for(j = 0;j < newChild.length;j++) {this[i].appendChild(newChild[j]);}}else {this[i].appendChild(newChild);}}return this;},prepend:function prepend(newChild){var i,j;for(i = 0;i < this.length;i++) {if(typeof newChild === 'string'){var tempDiv=document.createElement('div');tempDiv.innerHTML = newChild;for(j = tempDiv.childNodes.length - 1;j >= 0;j--) {this[i].insertBefore(tempDiv.childNodes[j],this[i].childNodes[0]);}}else if(newChild instanceof Dom7){for(j = 0;j < newChild.length;j++) {this[i].insertBefore(newChild[j],this[i].childNodes[0]);}}else {this[i].insertBefore(newChild,this[i].childNodes[0]);}}return this;},insertBefore:function insertBefore(selector){var before=$(selector);for(var i=0;i < this.length;i++) {if(before.length === 1){before[0].parentNode.insertBefore(this[i],before[0]);}else if(before.length > 1){for(var j=0;j < before.length;j++) {before[j].parentNode.insertBefore(this[i].cloneNode(true),before[j]);}}}},insertAfter:function insertAfter(selector){var after=$(selector);for(var i=0;i < this.length;i++) {if(after.length === 1){after[0].parentNode.insertBefore(this[i],after[0].nextSibling);}else if(after.length > 1){for(var j=0;j < after.length;j++) {after[j].parentNode.insertBefore(this[i].cloneNode(true),after[j].nextSibling);}}}},next:function next(selector){if(this.length > 0){if(selector){if(this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector))return new Dom7([this[0].nextElementSibling]);else return new Dom7([]);}else {if(this[0].nextElementSibling)return new Dom7([this[0].nextElementSibling]);else return new Dom7([]);}}else return new Dom7([]);},nextAll:function nextAll(selector){var nextEls=[];var el=this[0];if(!el)return new Dom7([]);while(el.nextElementSibling) {var next=el.nextElementSibling;if(selector){if($(next).is(selector))nextEls.push(next);}else nextEls.push(next);el = next;}return new Dom7(nextEls);},prev:function prev(selector){if(this.length > 0){if(selector){if(this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector))return new Dom7([this[0].previousElementSibling]);else return new Dom7([]);}else {if(this[0].previousElementSibling)return new Dom7([this[0].previousElementSibling]);else return new Dom7([]);}}else return new Dom7([]);},prevAll:function prevAll(selector){var prevEls=[];var el=this[0];if(!el)return new Dom7([]);while(el.previousElementSibling) {var prev=el.previousElementSibling;if(selector){if($(prev).is(selector))prevEls.push(prev);}else prevEls.push(prev);el = prev;}return new Dom7(prevEls);},parent:function parent(selector){var parents=[];for(var i=0;i < this.length;i++) {if(selector){if($(this[i].parentNode).is(selector))parents.push(this[i].parentNode);}else {parents.push(this[i].parentNode);}}return $($.unique(parents));},parents:function parents(selector){var parents=[];for(var i=0;i < this.length;i++) {var parent=this[i].parentNode;while(parent) {if(selector){if($(parent).is(selector))parents.push(parent);}else {parents.push(parent);}parent = parent.parentNode;}}return $($.unique(parents));},find:function find(selector){var foundElements=[];for(var i=0;i < this.length;i++) {var found=this[i].querySelectorAll(selector);for(var j=0;j < found.length;j++) {foundElements.push(found[j]);}}return new Dom7(foundElements);},children:function children(selector){var children=[];for(var i=0;i < this.length;i++) {var childNodes=this[i].childNodes;for(var j=0;j < childNodes.length;j++) {if(!selector){if(childNodes[j].nodeType === 1)children.push(childNodes[j]);}else {if(childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector))children.push(childNodes[j]);}}}return new Dom7($.unique(children));},remove:function remove(){for(var i=0;i < this.length;i++) {if(this[i].parentNode)this[i].parentNode.removeChild(this[i]);}return this;},add:function add(){var dom=this;var i,j;for(i = 0;i < arguments.length;i++) {var toAdd=$(arguments[i]);for(j = 0;j < toAdd.length;j++) {dom[dom.length] = toAdd[j];dom.length++;}}return dom;}};$.fn = Dom7.prototype;$.unique = function(arr){var unique=[];for(var i=0;i < arr.length;i++) {if(unique.indexOf(arr[i]) === -1)unique.push(arr[i]);}return unique;};return $;})(); /*===========================
 Get Dom libraries
 ===========================*/swiperDomPlugins = ['jQuery','Zepto','Dom7'];for(i = 0;i < swiperDomPlugins.length;i++) {if(window[swiperDomPlugins[i]]){addLibraryPlugin(window[swiperDomPlugins[i]]);}} // Required DOM Plugins
if(typeof Dom7 === 'undefined'){domLib = window.Dom7 || window.Zepto || window.jQuery;}else {domLib = Dom7;}if(domLib){if(!('transitionEnd' in domLib.fn)){domLib.fn.transitionEnd = function(callback){var events=['webkitTransitionEnd','transitionend','oTransitionEnd','MSTransitionEnd','msTransitionEnd'],i,j,dom=this;function fireCallBack(e){ /*jshint validthis:true */if(e.target !== this)return;callback.call(this,e);for(i = 0;i < events.length;i++) {dom.off(events[i],fireCallBack);}}if(callback){for(i = 0;i < events.length;i++) {dom.on(events[i],fireCallBack);}}return this;};}if(!('transform' in domLib.fn)){domLib.fn.transform = function(transform){for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;}return this;};}if(!('transition' in domLib.fn)){domLib.fn.transition = function(duration){if(typeof duration !== 'string'){duration = duration + 'ms';}for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;}return this;};}}}};});
System.register("ionic/components/tabs/tab", ["angular2/core", "../app/app", "../../config/config", "../../util/keyboard", "../nav/nav-controller", "./tabs"], function (_export) {
    /**
     * @name Tab
     * @usage
     * ```html
     * <ion-tabs>
     * 	 <ion-tab tabTitle="Home" tabIcon="home" [root]="tabOneRoot"></ion-tab>
     * 	 <ion-tab tabTitle="Login" tabIcon="star" [root]="tabTwoRoot"></ion-tab>
     * </ion-tabs>
     * ```
     *
     * @description
     * _For basic Tabs usage, see the [Tabs section](../../../../components/#tabs)
     * of the Component docs._
     *
     * Tab components are basic navigation controllers used with Tabs.  Much like
     * Nav, they are a subclass of NavController and can be used to navigate
     * to pages in and manipulate the navigation stack of a particular tab.
     *
     * For more information on using navigation controllers like Tab or [Nav](../../nav/Nav/),
     * take a look at the [NavController API reference](../NavController/).
     *
     * See the [Tabs API reference](../Tabs/) for more details on configuring Tabs
     * and the TabBar.
     *
     * For most cases, you can give tab a `[root]` property along with the component you want to load.
     *
     * ```html
     * <ion-tabs>
     *  <ion-tab [root]="chatRoot"><ion-tab>
     * </ion-tabs>
     * ```
     *
     * ```ts
     * import {Chat} from '../chat/chat';
     * export class Tabs {
     *    constructor(){
     *      // here we'll set the property of chatRoot to
     *      // the imported class of Chat
     *      this.chatRoot = Chat
     *    }
     * }
     * ```
     *
     * In other cases, you may not want to navigate to a new component, but just
     * call a method. You can use the `(select)` event to call a method on your
     * class. Below is an example of presenting a modal from one of the tabs.
     *
     * ```html
     * <ion-tabs preloadTabs="false">
     *   <ion-tab (select)="chat()"></ion-tab>
     * </ion-tabs>
     * ```
     *
     * ```ts
     * export class Tabs {
     *   constructor(nav: NavController){
     *     this.nav = nav;
     *   }
     *   chat() {
     *     let modal = Modal.create(ChatPage);
     *     this.nav.present(modal);
     *   }
     * }
     * ```
     *
     *
     * @property {any} [root] - set the root page for this tab
     * @property {any} [tabTitle] - set the title of this tab
     * @property {any} [tabIcon] - set the icon for this tab
     * @property {any} [select] - method to call when the current tab is selected
     *
     */
    "use strict";

    var ChangeDetectorRef, Component, Host, ElementRef, Compiler, AppViewManager, NgZone, Renderer, EventEmitter, Output, IonicApp, Config, Keyboard, NavController, Tabs, __decorate, __metadata, __param, Tab, _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            ChangeDetectorRef = _angular2Core.ChangeDetectorRef;
            Component = _angular2Core.Component;
            Host = _angular2Core.Host;
            ElementRef = _angular2Core.ElementRef;
            Compiler = _angular2Core.Compiler;
            AppViewManager = _angular2Core.AppViewManager;
            NgZone = _angular2Core.NgZone;
            Renderer = _angular2Core.Renderer;
            EventEmitter = _angular2Core.EventEmitter;
            Output = _angular2Core.Output;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_utilKeyboard) {
            Keyboard = _utilKeyboard.Keyboard;
        }, function (_navNavController) {
            NavController = _navNavController.NavController;
        }, function (_tabs) {
            Tabs = _tabs.Tabs;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Tab = (function (_NavController) {
                _inherits(Tab, _NavController);

                function Tab(parentTabs, app, config, keyboard, elementRef, compiler, viewManager, zone, renderer, cd) {
                    _classCallCheck(this, Tab);

                    // A Tab is a NavController for its child pages
                    _get(Object.getPrototypeOf(Tab.prototype), "constructor", this).call(this, parentTabs, app, config, keyboard, elementRef, 'contents', compiler, viewManager, zone, renderer, cd);
                    this.select = new EventEmitter();
                    this._isInitial = parentTabs.add(this);
                    this._panelId = 'tabpanel-' + this.id;
                    this._btnId = 'tab-' + this.id;
                }

                /**
                 * @private
                 */

                _createClass(Tab, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        var _this = this;

                        if (this._isInitial) {
                            this.parent.select(this);
                        } else if (this.parent.preloadTabs) {
                            this._loadTimer = setTimeout(function () {
                                if (!_this._loaded) {
                                    _this.load({
                                        animate: false,
                                        preload: true,
                                        postLoad: function postLoad(viewCtrl) {
                                            var navbar = viewCtrl.getNavbar();
                                            navbar && navbar.setHidden(true);
                                        }
                                    }, function () {});
                                }
                            }, 1000 * this.index);
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "load",
                    value: function load(opts, done) {
                        if (!this._loaded && this.root) {
                            this.push(this.root, null, opts, done);
                            this._loaded = true;
                        } else {
                            done();
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "loadPage",
                    value: function loadPage(viewCtrl, navbarContainerRef, opts, done) {
                        // by default a page's navbar goes into the shared tab's navbar section
                        navbarContainerRef = this.parent.navbarContainerRef;
                        var isTabSubPage = this.parent.subPages && viewCtrl.index > 0;
                        if (isTabSubPage) {
                            // a subpage, that's not the first index
                            // should not use the shared tabs navbar section, but use it's own
                            navbarContainerRef = null;
                        }
                        _get(Object.getPrototypeOf(Tab.prototype), "loadPage", this).call(this, viewCtrl, navbarContainerRef, opts, function () {
                            if (viewCtrl.instance) {
                                viewCtrl.instance._tabSubPage = isTabSubPage;
                            }
                            done();
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setSelected",
                    value: function setSelected(isSelected) {
                        this.isSelected = isSelected;
                        this.hideNavbars(!isSelected);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "emitSelect",
                    value: function emitSelect() {
                        this.select.emit();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "hideNavbars",
                    value: function hideNavbars(shouldHideNavbars) {
                        this._views.forEach(function (viewCtrl) {
                            var navbar = viewCtrl.getNavbar();
                            navbar && navbar.setHidden(shouldHideNavbars);
                        });
                    }

                    /**
                     *
                     * ```ts
                     * export class MyClass{
                     *  constructor(tab: Tab){
                     *    this.tab = tab;
                     *    console.log(this.tab.index);
                     *  }
                     * }
                     * ```
                     *
                     * @returns {Number} Returns the index of this page within its NavController.
                     *
                     */
                }, {
                    key: "ngOnDestroy",

                    /**
                     * @private
                     */
                    value: function ngOnDestroy() {
                        clearTimeout(this._loadTimer);
                    }
                }, {
                    key: "index",
                    get: function get() {
                        return this.parent.getIndex(this);
                    }
                }]);

                return Tab;
            })(NavController);

            _export("Tab", Tab);

            __decorate([Output(), __metadata('design:type', typeof (_a = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _a || Object)], Tab.prototype, "select", void 0);
            _export("Tab", Tab = __decorate([Component({
                selector: 'ion-tab',
                inputs: ['root', 'tabTitle', 'tabIcon'],
                host: {
                    '[class.show-tab]': 'isSelected',
                    '[attr.id]': '_panelId',
                    '[attr.aria-labelledby]': '_btnId',
                    'role': 'tabpanel'
                },
                template: '<template #contents></template>'
            }), __param(0, Host()), __metadata('design:paramtypes', [typeof (_b = typeof Tabs !== 'undefined' && Tabs) === 'function' && _b || Object, typeof (_c = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _c || Object, typeof (_d = typeof Config !== 'undefined' && Config) === 'function' && _d || Object, typeof (_e = typeof Keyboard !== 'undefined' && Keyboard) === 'function' && _e || Object, typeof (_f = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _f || Object, typeof (_g = typeof Compiler !== 'undefined' && Compiler) === 'function' && _g || Object, typeof (_h = typeof AppViewManager !== 'undefined' && AppViewManager) === 'function' && _h || Object, typeof (_j = typeof NgZone !== 'undefined' && NgZone) === 'function' && _j || Object, typeof (_k = typeof Renderer !== 'undefined' && Renderer) === 'function' && _k || Object, typeof (_l = typeof ChangeDetectorRef !== 'undefined' && ChangeDetectorRef) === 'function' && _l || Object])], Tab));
        }
    };
});
System.register("ionic/components/tabs/tabs", ["angular2/core", "angular2/common", "../ion", "../app/id", "../../config/config", "../../platform/platform", "../nav/nav-controller", "../nav/view-controller", "../../decorators/config-component", "../icon/icon", "../../util/dom"], function (_export) {
    /**
     * @name Tabs
     * @property {any} [tabbarPlacement] - set position of the tabbar, top or bottom
     * @property {any} [tabbarIcons] - set the position of the tabbar's icons: top, bottom, left, right, hide
     * @property {any} [preloadTabs] - sets whether to preload all the tabs, true or false
     * @usage
    * ```html
     * <ion-tabs>
     *   <ion-tab [root]="tabRoot"></ion-tab>
     * </ion-tabs>
     * ```
     * @description
     * _For basic Tabs usage, see the [Tabs section](../../../../components/#tabs)
     * of the Component docs._
     *
     * The Tabs component is a container with a TabBar and any number of
     * individual Tab components. On iOS, the TabBar is placed on the bottom of
     * the screen, while on Android it is at the top.
     *
     * @see {@link /docs/v3/components#tabs Tabs Component Docs}
     * @see {@link ../Tab Tab API Docs}
     */
    "use strict";

    var Directive, ElementRef, Optional, Host, forwardRef, ViewContainerRef, HostListener, EventEmitter, Output, NgFor, NgIf, Ion, Attr, Config, Platform, NavController, ViewController, ConfigComponent, Icon, rafFrames, __decorate, __metadata, __param, Tabs, tabIds, TabButton, TabHighlight, TabNavBarAnchor, _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Directive = _angular2Core.Directive;
            ElementRef = _angular2Core.ElementRef;
            Optional = _angular2Core.Optional;
            Host = _angular2Core.Host;
            forwardRef = _angular2Core.forwardRef;
            ViewContainerRef = _angular2Core.ViewContainerRef;
            HostListener = _angular2Core.HostListener;
            EventEmitter = _angular2Core.EventEmitter;
            Output = _angular2Core.Output;
        }, function (_angular2Common) {
            NgFor = _angular2Common.NgFor;
            NgIf = _angular2Common.NgIf;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_appId) {
            Attr = _appId.Attr;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }, function (_navNavController) {
            NavController = _navNavController.NavController;
        }, function (_navViewController) {
            ViewController = _navViewController.ViewController;
        }, function (_decoratorsConfigComponent) {
            ConfigComponent = _decoratorsConfigComponent.ConfigComponent;
        }, function (_iconIcon) {
            Icon = _iconIcon.Icon;
        }, function (_utilDom) {
            rafFrames = _utilDom.rafFrames;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Tabs = (function (_Ion) {
                _inherits(Tabs, _Ion);

                /**
                 * Hi, I'm "Tabs". I'm really just another Page, with a few special features.
                 * "Tabs" can be a sibling to other pages that can be navigated to, which those
                 * sibling pages may or may not have their own tab bars (doesn't matter). The fact
                 * that "Tabs" can happen to have children "Tab" classes, and each "Tab" can have
                 * children pages with their own "ViewController" instance, as nothing to do with the
                 * point that "Tabs" is itself is just a page with its own instance of ViewController.
                 */

                function Tabs(config, elementRef, viewCtrl, navCtrl, _platform) {
                    var _this = this;

                    _classCallCheck(this, Tabs);

                    _get(Object.getPrototypeOf(Tabs.prototype), "constructor", this).call(this, elementRef, config);
                    this._platform = _platform;
                    this.change = new EventEmitter();
                    this.parent = navCtrl;
                    this.subPages = config.get('tabSubPages');
                    this._tabs = [];
                    this._id = ++tabIds;
                    this._ids = -1;
                    this._onReady = null;
                    // Tabs may also be an actual ViewController which was navigated to
                    // if Tabs is static and not navigated to within a NavController
                    // then skip this and don't treat it as it's own ViewController
                    if (viewCtrl) {
                        viewCtrl.setContent(this);
                        viewCtrl.setContentRef(elementRef);
                        viewCtrl.onReady = function (done) {
                            _this._onReady = done;
                        };
                    }
                }

                /**
                 * @private
                 */

                _createClass(Tabs, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        var _this2 = this;

                        _get(Object.getPrototypeOf(Tabs.prototype), "ngOnInit", this).call(this);
                        this.preloadTabs = this.preloadTabs !== "false" && this.preloadTabs !== false;
                        if (this._highlight) {
                            this._platform.onResize(function () {
                                _this2._highlight.select(_this2.getSelected());
                            });
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "add",
                    value: function add(tab) {
                        tab.id = this._id + '-' + ++this._ids;
                        this._tabs.push(tab);
                        return this._tabs.length === 1;
                    }

                    /**
                     * @param {Number} index Index of the tab you want to select
                     */
                }, {
                    key: "select",
                    value: function select(tabOrIndex) {
                        var _this3 = this;

                        var selectedTab = typeof tabOrIndex === 'number' ? this.getByIndex(tabOrIndex) : tabOrIndex;
                        if (!selectedTab) {
                            return Promise.reject();
                        }
                        var deselectedTab = this.getSelected();
                        if (selectedTab === deselectedTab) {
                            // no change
                            return this._touchActive(selectedTab);
                        }
                        console.time('Tabs#select ' + selectedTab.id);
                        var opts = {
                            animate: false
                        };
                        var deselectedPage = undefined;
                        if (deselectedTab) {
                            deselectedPage = deselectedTab.getActive();
                            deselectedPage && deselectedPage.willLeave();
                        }
                        var selectedPage = selectedTab.getActive();
                        selectedPage && selectedPage.willEnter();
                        selectedTab.load(opts, function () {
                            selectedTab.emitSelect();
                            _this3.change.emit(selectedTab);
                            if (selectedTab.root) {
                                // only show the selectedTab if it has a root
                                // it's possible the tab is only for opening modal's or signing out
                                // and doesn't actually have content. In the case there's no content
                                // for a tab then do nothing and leave the current view as is
                                _this3._tabs.forEach(function (tab) {
                                    tab.setSelected(tab === selectedTab);
                                });
                            }
                            _this3._highlight && _this3._highlight.select(selectedTab);
                            selectedPage && selectedPage.didEnter();
                            deselectedPage && deselectedPage.didLeave();
                            if (_this3._onReady) {
                                _this3._onReady();
                                _this3._onReady = null;
                            }
                            console.time('Tabs#select ' + selectedTab.id);
                        });
                    }

                    /**
                     * @param {Number} index Index of the tab you want to get
                     * @returns {Any} Tab Returs the tab who's index matches the one passed
                     */
                }, {
                    key: "getByIndex",
                    value: function getByIndex(index) {
                        if (index < this._tabs.length && index > -1) {
                            return this._tabs[index];
                        }
                        return null;
                    }

                    /**
                     * @return {Any} Tab Returns the currently selected tab
                     */
                }, {
                    key: "getSelected",
                    value: function getSelected() {
                        for (var i = 0; i < this._tabs.length; i++) {
                            if (this._tabs[i].isSelected) {
                                return this._tabs[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getIndex",
                    value: function getIndex(tab) {
                        return this._tabs.indexOf(tab);
                    }

                    /**
                     * @private
                     * "Touch" the active tab, going back to the root view of the tab
                     * or optionally letting the tab handle the event
                     */
                }, {
                    key: "_touchActive",
                    value: function _touchActive(tab) {
                        var active = tab.getActive();
                        if (!active) {
                            return Promise.resolve();
                        }
                        var instance = active.instance;
                        // If they have a custom tab selected handler, call it
                        if (instance.tabSelected) {
                            return instance.tabSelected();
                        }
                        // If we're a few pages deep, pop to root
                        if (tab.length() > 1) {
                            // Pop to the root view
                            return tab.popToRoot();
                        }
                        // Otherwise, if the page we're on is not our real root, reset it to our
                        // default root type
                        if (tab.root != active.componentType) {
                            return tab.setRoot(tab.root);
                        }
                        // And failing all of that, we do something safe and secure
                        return Promise.resolve();
                    }

                    /**
                     * Returns the root NavController. Returns `null` if Tabs is not
                     * within a NavController.
                     * @returns {NavController}
                     */
                }, {
                    key: "rootNav",
                    get: function get() {
                        var nav = this.parent;
                        while (nav.parent) {
                            nav = nav.parent;
                        }
                        return nav;
                    }
                }]);

                return Tabs;
            })(Ion);

            _export("Tabs", Tabs);

            __decorate([Output(), __metadata('design:type', typeof (_a = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _a || Object)], Tabs.prototype, "change", void 0);
            _export("Tabs", Tabs = __decorate([ConfigComponent({
                selector: 'ion-tabs',
                defaultInputs: {
                    'tabbarPlacement': 'bottom',
                    'tabbarIcons': 'top',
                    'preloadTabs': false
                },
                template: '<ion-navbar-section>' + '<template navbar-anchor></template>' + '</ion-navbar-section>' + '<ion-tabbar-section>' + '<tabbar role="tablist">' + '<a *ngFor="#t of _tabs" [tab]="t" class="tab-button" role="tab">' + '<ion-icon [name]="t.tabIcon" [isActive]="t.isSelected" class="tab-button-icon"></ion-icon>' + '<span class="tab-button-text">{{t.tabTitle}}</span>' + '</a>' + '<tab-highlight></tab-highlight>' + '</tabbar>' + '</ion-tabbar-section>' + '<ion-content-section>' + '<ng-content></ng-content>' + '</ion-content-section>',
                directives: [Icon, NgFor, NgIf, Attr, forwardRef(function () {
                    return TabButton;
                }), forwardRef(function () {
                    return TabHighlight;
                }), forwardRef(function () {
                    return TabNavBarAnchor;
                })]
            }), __param(2, Optional()), __param(3, Optional()), __metadata('design:paramtypes', [typeof (_b = typeof Config !== 'undefined' && Config) === 'function' && _b || Object, typeof (_c = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _c || Object, typeof (_d = typeof ViewController !== 'undefined' && ViewController) === 'function' && _d || Object, typeof (_e = typeof NavController !== 'undefined' && NavController) === 'function' && _e || Object, typeof (_f = typeof Platform !== 'undefined' && Platform) === 'function' && _f || Object])], Tabs));
            tabIds = -1;

            /**
             * @private
             */

            TabButton = (function (_Ion2) {
                _inherits(TabButton, _Ion2);

                function TabButton(tabs, config, elementRef) {
                    _classCallCheck(this, TabButton);

                    _get(Object.getPrototypeOf(TabButton.prototype), "constructor", this).call(this, elementRef, config);
                    this.tabs = tabs;
                    this.disHover = config.get('hoverCSS') === false;
                }

                _createClass(TabButton, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        this.tab.btn = this;
                        this.hasTitle = !!this.tab.tabTitle;
                        this.hasIcon = !!this.tab.tabIcon;
                        this.hasTitleOnly = this.hasTitle && !this.hasIcon;
                        this.hasIconOnly = this.hasIcon && !this.hasTitle;
                    }
                }, {
                    key: "onClick",
                    value: function onClick() {
                        this.tabs.select(this.tab);
                    }
                }]);

                return TabButton;
            })(Ion);

            __decorate([HostListener('click'), __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], TabButton.prototype, "onClick", null);
            TabButton = __decorate([Directive({
                selector: '.tab-button',
                inputs: ['tab'],
                host: {
                    '[attr.id]': 'tab._btnId',
                    '[attr.aria-controls]': 'tab._panelId',
                    '[attr.aria-selected]': 'tab.isSelected',
                    '[class.has-title]': 'hasTitle',
                    '[class.has-icon]': 'hasIcon',
                    '[class.has-title-only]': 'hasTitleOnly',
                    '[class.icon-only]': 'hasIconOnly',
                    '[class.disable-hover]': 'disHover'
                }
            }), __param(0, Host()), __metadata('design:paramtypes', [Tabs, typeof (_g = typeof Config !== 'undefined' && Config) === 'function' && _g || Object, typeof (_h = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _h || Object])], TabButton);
            /**
             * @private
             */

            TabHighlight = (function () {
                function TabHighlight(tabs, config, elementRef) {
                    _classCallCheck(this, TabHighlight);

                    if (config.get('tabbarHighlight')) {
                        tabs._highlight = this;
                        this.elementRef = elementRef;
                    }
                }

                _createClass(TabHighlight, [{
                    key: "select",
                    value: function select(tab) {
                        var _this4 = this;

                        rafFrames(3, function () {
                            var d = tab.btn.getDimensions();
                            var ele = _this4.elementRef.nativeElement;
                            ele.style.transform = 'translate3d(' + d.left + 'px,0,0) scaleX(' + d.width + ')';
                            if (!_this4.init) {
                                _this4.init = true;
                                rafFrames(6, function () {
                                    ele.classList.add('animate');
                                });
                            }
                        });
                    }
                }]);

                return TabHighlight;
            })();

            TabHighlight = __decorate([Directive({
                selector: 'tab-highlight'
            }), __param(0, Host()), __metadata('design:paramtypes', [Tabs, typeof (_j = typeof Config !== 'undefined' && Config) === 'function' && _j || Object, typeof (_k = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _k || Object])], TabHighlight);
            /**
             * @private
             */

            TabNavBarAnchor = function TabNavBarAnchor(tabs, viewContainerRef) {
                _classCallCheck(this, TabNavBarAnchor);

                tabs.navbarContainerRef = viewContainerRef;
            };

            TabNavBarAnchor = __decorate([Directive({ selector: 'template[navbar-anchor]' }), __param(0, Host()), __metadata('design:paramtypes', [Tabs, typeof (_l = typeof ViewContainerRef !== 'undefined' && ViewContainerRef) === 'function' && _l || Object])], TabNavBarAnchor);
        }
    };
});
System.register('ionic/components/tap-click/activator', ['../../util/dom'], function (_export) {
    'use strict';

    var rafFrames, Activator;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilDom) {
            rafFrames = _utilDom.rafFrames;
        }],
        execute: function () {
            Activator = (function () {
                function Activator(app, config, zone) {
                    _classCallCheck(this, Activator);

                    this.app = app;
                    this.zone = zone;
                    this.queue = [];
                    this.active = [];
                    this.clearStateDefers = 5;
                    this.clearAttempt = 0;
                    this.activatedClass = config.get('activatedClass') || 'activated';
                    this.x = 0;
                    this.y = 0;
                }

                _createClass(Activator, [{
                    key: 'downAction',
                    value: function downAction(ev, activatableEle, pointerX, pointerY, callback) {
                        // the user just pressed down
                        var self = this;
                        if (self.disableActivated(ev)) return false;
                        // remember where they pressed
                        self.x = pointerX;
                        self.y = pointerY;
                        // queue to have this element activated
                        self.queue.push(activatableEle);
                        function activateCss() {
                            var activatableEle = undefined;
                            for (var i = 0; i < self.queue.length; i++) {
                                activatableEle = self.queue[i];
                                if (activatableEle && activatableEle.parentNode) {
                                    self.active.push(activatableEle);
                                    activatableEle.classList.add(self.activatedClass);
                                }
                            }
                            self.queue = [];
                        }
                        this.zone.runOutsideAngular(function () {
                            rafFrames(2, activateCss);
                        });
                        return true;
                    }
                }, {
                    key: 'upAction',
                    value: function upAction() {
                        // the user was pressing down, then just let up
                        var self = this;
                        function activateUp() {
                            self.clearState();
                        }
                        this.zone.runOutsideAngular(function () {
                            rafFrames(self.clearStateDefers, activateUp);
                        });
                    }
                }, {
                    key: 'clearState',
                    value: function clearState() {
                        var _this = this;

                        // all states should return to normal
                        if (!this.app.isEnabled()) {
                            // the app is actively disabled, so don't bother deactivating anything.
                            // this makes it easier on the GPU so it doesn't have to redraw any
                            // buttons during a transition. This will retry in XX milliseconds.
                            setTimeout(function () {
                                _this.clearState();
                            }, 600);
                        } else {
                            // not actively transitioning, good to deactivate any elements
                            this.deactivate();
                        }
                    }
                }, {
                    key: 'deactivate',
                    value: function deactivate() {
                        // remove the active class from all active elements
                        var self = this;
                        self.queue = [];
                        function deactivate() {
                            for (var i = 0; i < self.active.length; i++) {
                                self.active[i].classList.remove(self.activatedClass);
                            }
                            self.active = [];
                        }
                        rafFrames(2, deactivate);
                    }
                }, {
                    key: 'disableActivated',
                    value: function disableActivated(ev) {
                        if (ev.defaultPrevented) return true;
                        var targetEle = ev.target;
                        for (var x = 0; x < 4; x++) {
                            if (!targetEle) break;
                            if (targetEle.hasAttribute('disable-activated')) return true;
                            targetEle = targetEle.parentElement;
                        }
                        return false;
                    }
                }]);

                return Activator;
            })();

            _export('Activator', Activator);
        }
    };
});
System.register('ionic/components/tap-click/ripple', ['./activator', '../../animations/animation', '../../util/dom'], function (_export) {
    'use strict';

    var Activator, Animation, raf, rafFrames, RippleActivator, TOUCH_DOWN_ACCEL, EXPAND_DOWN_PLAYBACK_RATE, EXPAND_OUT_PLAYBACK_RATE, FADE_OUT_DURATION;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_activator) {
            Activator = _activator.Activator;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_utilDom) {
            raf = _utilDom.raf;
            rafFrames = _utilDom.rafFrames;
        }],
        execute: function () {
            RippleActivator = (function (_Activator) {
                _inherits(RippleActivator, _Activator);

                function RippleActivator(app, config, zone) {
                    _classCallCheck(this, RippleActivator);

                    _get(Object.getPrototypeOf(RippleActivator.prototype), 'constructor', this).call(this, app, config, zone);
                    this.expands = {};
                    this.fades = {};
                    this.expandSpeed = null;
                }

                _createClass(RippleActivator, [{
                    key: 'downAction',
                    value: function downAction(ev, activatableEle, pointerX, pointerY) {
                        var _this = this;

                        if (_get(Object.getPrototypeOf(RippleActivator.prototype), 'downAction', this).call(this, ev, activatableEle, pointerX, pointerY)) {
                            // create a new ripple element
                            this.expandSpeed = EXPAND_DOWN_PLAYBACK_RATE;
                            this.zone.runOutsideAngular(function () {
                                raf(function () {
                                    var clientRect = activatableEle.getBoundingClientRect();
                                    raf(function () {
                                        _this.createRipple(activatableEle, pointerX, pointerY, clientRect);
                                    });
                                });
                            });
                        }
                    }
                }, {
                    key: 'createRipple',
                    value: function createRipple(activatableEle, pointerX, pointerY, clientRect) {
                        var _this2 = this;

                        var clientPointerX = pointerX - clientRect.left;
                        var clientPointerY = pointerY - clientRect.top;
                        var x = Math.max(Math.abs(clientRect.width - clientPointerX), clientPointerX) * 2;
                        var y = Math.max(Math.abs(clientRect.height - clientPointerY), clientPointerY) * 2;
                        var diameter = Math.max(Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), 64);
                        var radius = Math.sqrt(clientRect.width + clientRect.height);
                        var duration = 1000 * Math.sqrt(radius / TOUCH_DOWN_ACCEL) + 0.5;
                        var rippleEle = document.createElement('md-ripple');
                        var rippleId = Date.now();
                        var eleStyle = rippleEle.style;
                        eleStyle.width = eleStyle.height = diameter + 'px';
                        eleStyle.marginTop = eleStyle.marginLeft = -(diameter / 2) + 'px';
                        eleStyle.left = clientPointerX + 'px';
                        eleStyle.top = clientPointerY + 'px';
                        activatableEle.appendChild(rippleEle);
                        // create the animation for the fade out, but don't start it yet
                        this.fades[rippleId] = new Animation(rippleEle, { renderDelay: 0 });
                        this.fades[rippleId].fadeOut().duration(FADE_OUT_DURATION).playbackRate(1).onFinish(function () {
                            raf(function () {
                                _this2.fades[rippleId].dispose(true);
                                delete _this2.fades[rippleId];
                            });
                        });
                        // expand the circle from the users starting point
                        // start slow, and when they let up, then speed up the animation
                        this.expands[rippleId] = new Animation(rippleEle, { renderDelay: 0 });
                        this.expands[rippleId].fromTo('scale', '0.001', '1').duration(duration).playbackRate(this.expandSpeed).onFinish(function () {
                            _this2.expands[rippleId].dispose();
                            delete _this2.expands[rippleId];
                            _this2.next();
                        }).play();
                    }
                }, {
                    key: 'upAction',
                    value: function upAction() {
                        var _this3 = this;

                        this.deactivate();
                        this.expandSpeed = 1;
                        this.zone.runOutsideAngular(function () {
                            rafFrames(4, function () {
                                _this3.next();
                            });
                        });
                    }
                }, {
                    key: 'next',
                    value: function next() {
                        var now = Date.now();
                        var rippleId = undefined;
                        for (rippleId in this.expands) {
                            if (parseInt(rippleId, 10) + 4000 < now) {
                                this.expands[rippleId].dispose(true);
                                delete this.expands[rippleId];
                            } else if (this.expands[rippleId].playbackRate() === EXPAND_DOWN_PLAYBACK_RATE) {
                                this.expands[rippleId].playbackRate(EXPAND_OUT_PLAYBACK_RATE);
                            }
                        }
                        for (rippleId in this.fades) {
                            if (parseInt(rippleId, 10) + 4000 < now) {
                                this.fades[rippleId].dispose(true);
                                delete this.fades[rippleId];
                            } else if (!this.fades[rippleId].isPlaying) {
                                this.fades[rippleId].isPlaying = true;
                                this.fades[rippleId].play();
                            }
                        }
                    }
                }, {
                    key: 'clearState',
                    value: function clearState() {
                        this.deactivate();
                        this.next();
                    }
                }]);

                return RippleActivator;
            })(Activator);

            _export('RippleActivator', RippleActivator);

            TOUCH_DOWN_ACCEL = 512;
            EXPAND_DOWN_PLAYBACK_RATE = 0.35;
            EXPAND_OUT_PLAYBACK_RATE = 3;
            FADE_OUT_DURATION = 700;
        }
    };
});
System.register("ionic/components/tap-click/tap-click", ["angular2/core", "../app/app", "../../config/config", "../../util/dom", "./activator", "./ripple"], function (_export) {
    /**
     * @private
     */
    "use strict";

    var Injectable, NgZone, IonicApp, Config, pointerCoord, hasPointerMoved, Activator, RippleActivator, __decorate, __metadata, TapClick, ACTIVATABLE_ELEMENTS, ACTIVATABLE_ATTRIBUTES, POINTER_TOLERANCE, POINTER_MOVE_UNTIL_CANCEL, DISABLE_NATIVE_CLICK_AMOUNT, _a, _b, _c;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    _export("isActivatable", isActivatable);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function getActivatableTarget(ele) {
        var targetEle = ele;
        for (var x = 0; x < 4; x++) {
            if (!targetEle) break;
            if (isActivatable(targetEle)) return targetEle;
            targetEle = targetEle.parentElement;
        }
        return null;
    }
    /**
     * @private
     */

    function isActivatable(ele) {
        if (ACTIVATABLE_ELEMENTS.test(ele.tagName)) {
            return true;
        }
        var attributes = ele.attributes;
        for (var i = 0, l = attributes.length; i < l; i++) {
            if (ACTIVATABLE_ATTRIBUTES.test(attributes[i].name)) {
                return true;
            }
        }
        return false;
    }

    function addListener(type, listener, useCapture) {
        document.addEventListener(type, listener, useCapture);
    }
    function removeListener(type, listener) {
        document.removeEventListener(type, listener);
    }
    return {
        setters: [function (_angular2Core) {
            Injectable = _angular2Core.Injectable;
            NgZone = _angular2Core.NgZone;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_utilDom) {
            pointerCoord = _utilDom.pointerCoord;
            hasPointerMoved = _utilDom.hasPointerMoved;
        }, function (_activator) {
            Activator = _activator.Activator;
        }, function (_ripple) {
            RippleActivator = _ripple.RippleActivator;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            TapClick = (function () {
                function TapClick(app, config, zone) {
                    _classCallCheck(this, TapClick);

                    var self = this;
                    self.app = app;
                    self.zone = zone;
                    self.lastTouch = 0;
                    self.disableClick = 0;
                    self.lastActivated = 0;
                    if (config.get('activator') == 'ripple') {
                        self.activator = new RippleActivator(app, config, zone);
                    } else if (config.get('activator') == 'highlight') {
                        self.activator = new Activator(app, config, zone);
                    }
                    self.usePolyfill = config.get('tapPolyfill') === true;
                    zone.runOutsideAngular(function () {
                        addListener('click', self.click.bind(self), true);
                        addListener('touchstart', self.touchStart.bind(self));
                        addListener('touchend', self.touchEnd.bind(self));
                        addListener('touchcancel', self.pointerCancel.bind(self));
                        addListener('mousedown', self.mouseDown.bind(self), true);
                        addListener('mouseup', self.mouseUp.bind(self), true);
                    });
                    self.pointerMove = function (ev) {
                        if (hasPointerMoved(POINTER_MOVE_UNTIL_CANCEL, self.startCoord, pointerCoord(ev))) {
                            self.pointerCancel(ev);
                        }
                    };
                }

                _createClass(TapClick, [{
                    key: "touchStart",
                    value: function touchStart(ev) {
                        this.lastTouch = Date.now();
                        this.pointerStart(ev);
                    }
                }, {
                    key: "touchEnd",
                    value: function touchEnd(ev) {
                        this.lastTouch = Date.now();
                        if (this.usePolyfill && this.startCoord && this.app.isEnabled()) {
                            // only dispatch mouse click events from a touchend event
                            // when tapPolyfill config is true, and the startCoordand endCoord
                            // are not too far off from each other
                            var endCoord = pointerCoord(ev);
                            if (!hasPointerMoved(POINTER_TOLERANCE, this.startCoord, endCoord)) {
                                // prevent native mouse click events for XX amount of time
                                this.disableClick = this.lastTouch + DISABLE_NATIVE_CLICK_AMOUNT;
                                if (this.app.isScrolling()) {
                                    // do not fire off a click event while the app was scrolling
                                    console.debug('click from touch prevented by scrolling ' + Date.now());
                                } else {
                                    // dispatch a mouse click event
                                    console.debug('create click from touch ' + Date.now());
                                    var clickEvent = document.createEvent('MouseEvents');
                                    clickEvent.initMouseEvent('click', true, true, window, 1, 0, 0, endCoord.x, endCoord.y, false, false, false, false, 0, null);
                                    clickEvent.isIonicTap = true;
                                    ev.target.dispatchEvent(clickEvent);
                                }
                            }
                        }
                        this.pointerEnd(ev);
                    }
                }, {
                    key: "mouseDown",
                    value: function mouseDown(ev) {
                        if (this.isDisabledNativeClick()) {
                            console.debug('mouseDown prevent ' + ev.target.tagName + ' ' + Date.now());
                            // does not prevent default on purpose
                            // so native blur events from inputs can happen
                            ev.stopPropagation();
                        } else if (this.lastTouch + DISABLE_NATIVE_CLICK_AMOUNT < Date.now()) {
                            this.pointerStart(ev);
                        }
                    }
                }, {
                    key: "mouseUp",
                    value: function mouseUp(ev) {
                        if (this.isDisabledNativeClick()) {
                            console.debug('mouseUp prevent ' + ev.target.tagName + ' ' + Date.now());
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        if (this.lastTouch + DISABLE_NATIVE_CLICK_AMOUNT < Date.now()) {
                            this.pointerEnd(ev);
                        }
                    }
                }, {
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        var activatableEle = getActivatableTarget(ev.target);
                        if (activatableEle) {
                            this.startCoord = pointerCoord(ev);
                            var now = Date.now();
                            if (this.lastActivated + 150 < now) {
                                this.activator && this.activator.downAction(ev, activatableEle, this.startCoord.x, this.startCoord.y);
                                this.lastActivated = now;
                            }
                            this.moveListeners(true);
                        } else {
                            this.startCoord = null;
                        }
                    }
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd(ev) {
                        this.moveListeners(false);
                        this.activator && this.activator.upAction();
                    }
                }, {
                    key: "pointerCancel",
                    value: function pointerCancel(ev) {
                        console.debug('pointerCancel from ' + ev.type + ' ' + Date.now());
                        this.activator && this.activator.clearState();
                        this.moveListeners(false);
                    }
                }, {
                    key: "moveListeners",
                    value: function moveListeners(shouldAdd) {
                        removeListener(this.usePolyfill ? 'touchmove' : 'mousemove', this.pointerMove);
                        //this.zone.runOutsideAngular(() => {
                        if (shouldAdd) {
                            addListener(this.usePolyfill ? 'touchmove' : 'mousemove', this.pointerMove);
                        } else {}
                        //});
                    }
                }, {
                    key: "click",
                    value: function click(ev) {
                        var preventReason = null;
                        if (!this.app.isEnabled()) {
                            preventReason = 'appDisabled';
                        } else if (!ev.isIonicTap && this.isDisabledNativeClick()) {
                            preventReason = 'nativeClick';
                        }
                        if (preventReason !== null) {
                            console.debug('click prevent ' + preventReason + ' ' + Date.now());
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                    }
                }, {
                    key: "isDisabledNativeClick",
                    value: function isDisabledNativeClick() {
                        return this.disableClick > Date.now();
                    }
                }]);

                return TapClick;
            })();

            _export("TapClick", TapClick);

            _export("TapClick", TapClick = __decorate([Injectable(), __metadata('design:paramtypes', [typeof (_a = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _a || Object, typeof (_b = typeof Config !== 'undefined' && Config) === 'function' && _b || Object, typeof (_c = typeof NgZone !== 'undefined' && NgZone) === 'function' && _c || Object])], TapClick));ACTIVATABLE_ELEMENTS = /^(A|BUTTON)$/;
            ACTIVATABLE_ATTRIBUTES = /tappable|button/i;
            POINTER_TOLERANCE = 4;
            POINTER_MOVE_UNTIL_CANCEL = 10;
            DISABLE_NATIVE_CLICK_AMOUNT = 2500;
        }
    };
});
System.register("ionic/components/text-input/text-input", ["angular2/core", "angular2/common", "../nav/nav-controller", "../../config/config", "../../util/form", "../label/label", "../app/app", "../content/content", "../../util/dom", "../../platform/platform", "../button/button", "../icon/icon"], function (_export) {
    /**
     * @private
     */
    "use strict";

    var Component, Directive, Attribute, forwardRef, Host, Optional, ElementRef, Renderer, Input, Output, EventEmitter, ContentChild, ContentChildren, HostListener, NgIf, NavController, Config, Form, Label, IonicApp, Content, CSS, _hasFocus, pointerCoord, hasPointerMoved, Platform, Button, Icon, __decorate, __metadata, __param, TextInputElement, _TextInput, InputScrollAssist, SCROLL_ASSIST_SPEED, _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function cloneInput(srcInput, addCssClass) {
        var clonedInputEle = srcInput.cloneNode(true);
        clonedInputEle.classList.add(addCssClass);
        clonedInputEle.classList.remove('hide-focused-input');
        clonedInputEle.setAttribute('aria-hidden', true);
        clonedInputEle.removeAttribute('aria-labelledby');
        clonedInputEle.tabIndex = -1;
        return clonedInputEle;
    }

    function getScrollAssistDuration(distanceToScroll) {
        //return 3000;
        distanceToScroll = Math.abs(distanceToScroll);
        var duration = distanceToScroll / SCROLL_ASSIST_SPEED;
        return Math.min(400, Math.max(100, duration));
    }
    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            Directive = _angular2Core.Directive;
            Attribute = _angular2Core.Attribute;
            forwardRef = _angular2Core.forwardRef;
            Host = _angular2Core.Host;
            Optional = _angular2Core.Optional;
            ElementRef = _angular2Core.ElementRef;
            Renderer = _angular2Core.Renderer;
            Input = _angular2Core.Input;
            Output = _angular2Core.Output;
            EventEmitter = _angular2Core.EventEmitter;
            ContentChild = _angular2Core.ContentChild;
            ContentChildren = _angular2Core.ContentChildren;
            HostListener = _angular2Core.HostListener;
        }, function (_angular2Common) {
            NgIf = _angular2Common.NgIf;
        }, function (_navNavController) {
            NavController = _navNavController.NavController;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_utilForm) {
            Form = _utilForm.Form;
        }, function (_labelLabel) {
            Label = _labelLabel.Label;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_utilDom) {
            CSS = _utilDom.CSS;
            _hasFocus = _utilDom.hasFocus;
            pointerCoord = _utilDom.pointerCoord;
            hasPointerMoved = _utilDom.hasPointerMoved;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }, function (_buttonButton) {
            Button = _buttonButton.Button;
        }, function (_iconIcon) {
            Icon = _iconIcon.Icon;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            TextInputElement = (function () {
                function TextInputElement(type, _elementRef, _renderer) {
                    _classCallCheck(this, TextInputElement);

                    this._elementRef = _elementRef;
                    this._renderer = _renderer;
                    this.valueChange = new EventEmitter();
                    this.focusChange = new EventEmitter();
                    this.type = type || 'text';
                }

                _createClass(TextInputElement, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        if (this.ngModel) {
                            this.value = this.ngModel;
                        } else {
                            this.value = this._elementRef.nativeElement.value;
                        }
                    }
                }, {
                    key: "_keyup",
                    value: function _keyup(ev) {
                        this.valueChange.emit(ev.target.value);
                    }
                }, {
                    key: "_focus",
                    value: function _focus() {
                        this.focusChange.emit(true);
                    }
                }, {
                    key: "_blur",
                    value: function _blur() {
                        this.focusChange.emit(false);
                        this.hideFocus(false);
                    }
                }, {
                    key: "labelledBy",
                    value: function labelledBy(val) {
                        this._renderer.setElementAttribute(this._elementRef, 'aria-labelledby', val);
                    }
                }, {
                    key: "setFocus",
                    value: function setFocus() {
                        this.element().focus();
                    }
                }, {
                    key: "relocate",
                    value: function relocate(shouldRelocate, inputRelativeY) {
                        if (this._relocated !== shouldRelocate) {
                            var focusedInputEle = this.element();
                            if (shouldRelocate) {
                                var clonedInputEle = cloneInput(focusedInputEle, 'cloned-input');
                                focusedInputEle.classList.add('hide-focused-input');
                                focusedInputEle.style[CSS.transform] = "translate3d(-9999px," + inputRelativeY + "px,0)";
                                focusedInputEle.parentNode.insertBefore(clonedInputEle, focusedInputEle);
                                this.setFocus();
                            } else {
                                focusedInputEle.classList.remove('hide-focused-input');
                                focusedInputEle.style[CSS.transform] = '';
                                var clonedInputEle = focusedInputEle.parentNode.querySelector('.cloned-input');
                                if (clonedInputEle) {
                                    clonedInputEle.parentNode.removeChild(clonedInputEle);
                                }
                            }
                            this._relocated = shouldRelocate;
                        }
                    }
                }, {
                    key: "hideFocus",
                    value: function hideFocus(shouldHideFocus) {
                        var focusedInputEle = this.element();
                        if (shouldHideFocus) {
                            var clonedInputEle = cloneInput(focusedInputEle, 'cloned-hidden');
                            focusedInputEle.classList.add('hide-focused-input');
                            focusedInputEle.style[CSS.transform] = 'translate3d(-9999px,0,0)';
                            focusedInputEle.parentNode.insertBefore(clonedInputEle, focusedInputEle);
                        } else {
                            focusedInputEle.classList.remove('hide-focused-input');
                            focusedInputEle.style[CSS.transform] = '';
                            var clonedInputEle = focusedInputEle.parentNode.querySelector('.cloned-hidden');
                            if (clonedInputEle) {
                                clonedInputEle.parentNode.removeChild(clonedInputEle);
                            }
                        }
                    }
                }, {
                    key: "hasFocus",
                    value: function hasFocus() {
                        return _hasFocus(this.element());
                    }
                }, {
                    key: "addClass",
                    value: function addClass(className) {
                        this._renderer.setElementClass(this._elementRef, className, true);
                    }
                }, {
                    key: "hasClass",
                    value: function hasClass(className) {
                        this._elementRef.nativeElement.classList.contains(className);
                    }
                }, {
                    key: "element",
                    value: function element() {
                        return this._elementRef.nativeElement;
                    }
                }]);

                return TextInputElement;
            })();

            _export("TextInputElement", TextInputElement);

            __decorate([Input(), __metadata('design:type', String)], TextInputElement.prototype, "value", void 0);
            __decorate([Input(), __metadata('design:type', Object)], TextInputElement.prototype, "ngModel", void 0);
            __decorate([Output(), __metadata('design:type', typeof (_a = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _a || Object)], TextInputElement.prototype, "valueChange", void 0);
            __decorate([Output(), __metadata('design:type', typeof (_b = typeof EventEmitter !== 'undefined' && EventEmitter) === 'function' && _b || Object)], TextInputElement.prototype, "focusChange", void 0);
            __decorate([HostListener('keyup', ['$event']), __metadata('design:type', Function), __metadata('design:paramtypes', [Object]), __metadata('design:returntype', void 0)], TextInputElement.prototype, "_keyup", null);
            __decorate([HostListener('focus'), __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], TextInputElement.prototype, "_focus", null);
            __decorate([HostListener('blur'), __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], TextInputElement.prototype, "_blur", null);
            _export("TextInputElement", TextInputElement = __decorate([Directive({
                selector: 'textarea,input[type=text],input[type=password],input[type=number],input[type=search],input[type=email],input[type=url],input[type=tel],input[type=date],input[type=datetime],input[type=datetime-local],input[type=week],input[type=time]',
                host: {
                    'class': 'text-input'
                }
            }), __param(0, Attribute('type')), __metadata('design:paramtypes', [String, typeof (_c = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _c || Object, typeof (_d = typeof Renderer !== 'undefined' && Renderer) === 'function' && _d || Object])], TextInputElement));
            /**
             * @name Input
             * @module ionic
             * @description
             *
             * `ion-input` is a generic wrapper for both inputs and textareas. You can give `ion-input` attributes to tell it how to handle a child `ion-label` component.
             *
             * @property [fixed-label] - a persistant label that sits next the the input
             * @property [floating-label] - a label that will float about the input if the input is empty of looses focus
             * @property [stacked-label] - A stacked label will always appear on top of the input
             * @property [inset] - The input will be inset
             * @property [clearInput] - A clear icon will appear in the input which clears it
             *
             * @usage
             * ```html
             *  <ion-input>
             *    <ion-label>Username</ion-label>
             *    <input type="text" value="">
             *  </ion-input>
             *
             *  <ion-input clearInput>
             *    <input type="text" placeholder="Username">
             *  </ion-input>
             *
             *  <ion-input fixed-label>
             *    <ion-label>Username</ion-label>
             *    <input type="text" value="">
             *  </ion-input>
             *
             *  <ion-input floating-label>
             *    <ion-label>Username</ion-label>
             *    <input type="text" value="">
             *  </ion-input>
             * ```
             *
             */

            _TextInput = (function () {
                function TextInput(config, _form, _renderer, _elementRef, _app, _platform, _scrollView, _nav, isFloating, isStacked, isFixed, isInset) {
                    _classCallCheck(this, TextInput);

                    this._form = _form;
                    this._renderer = _renderer;
                    this._elementRef = _elementRef;
                    this._app = _app;
                    this._platform = _platform;
                    this._scrollView = _scrollView;
                    this._nav = _nav;
                    this.value = '';
                    _form.register(this);
                    this.type = 'text';
                    this.lastTouch = 0;
                    // make more gud with pending @Attributes API
                    this.displayType = isFloating === '' ? 'floating' : isStacked === '' ? 'stacked' : isFixed === '' ? 'fixed' : isInset === '' ? 'inset' : null;
                    this._assist = config.get('scrollAssist');
                    this.keyboardHeight = config.get('keyboardHeight');
                }

                /**
                 * @private
                 */

                _createClass(TextInput, [{
                    key: "ngOnInit",

                    /**
                     * @private
                     * On Initialization check for attributes
                     */
                    value: function ngOnInit() {
                        var clearInput = this.clearInput;
                        if (typeof clearInput === 'string') {
                            this.clearInput = clearInput === '' || clearInput === 'true';
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "ngAfterViewInit",
                    value: function ngAfterViewInit() {
                        var self = this;
                        if (self.input && self.label) {
                            // if there is an input and a label
                            // then give the label an ID
                            // and tell the input the ID of who it's labelled by
                            self.input.labelledBy(self.label.id);
                        }
                        self.scrollMove = function (ev) {
                            if (!(self._nav && self._nav.isTransitioning())) {
                                self.deregMove();
                                if (self.hasFocus()) {
                                    self.input.hideFocus(true);
                                    self._scrollView.onScrollEnd(function () {
                                        self.input.hideFocus(false);
                                        if (self.hasFocus()) {
                                            self.regMove();
                                        }
                                    });
                                }
                            }
                        };
                    }

                    /**
                      * @private
                     */
                }, {
                    key: "clearTextInput",
                    value: function clearTextInput() {
                        console.log("Should clear input");
                        console.log(this.textInputElement.value);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        if (this._assist && this._app.isEnabled()) {
                            // remember where the touchstart/mousedown started
                            this.startCoord = pointerCoord(ev);
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd(ev) {
                        if (!this._app.isEnabled()) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        } else if (this._assist && ev.type === 'touchend') {
                            // get where the touchend/mouseup ended
                            var endCoord = pointerCoord(ev);
                            // focus this input if the pointer hasn't moved XX pixels
                            // and the input doesn't already have focus
                            if (!hasPointerMoved(8, this.startCoord, endCoord) && !this.hasFocus()) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.initFocus();
                                // temporarily prevent mouseup's from focusing
                                this.lastTouch = Date.now();
                            }
                        } else if (this.lastTouch + 999 < Date.now()) {
                            ev.preventDefault();
                            ev.stopPropagation();
                            this.setFocus();
                            this.regMove();
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "initFocus",
                    value: function initFocus() {
                        var _this = this;

                        // begin the process of setting focus to the inner input element
                        var scrollView = this._scrollView;
                        if (scrollView && this._assist) {
                            // this input is inside of a scroll view
                            // find out if text input should be manually scrolled into view
                            var ele = this._elementRef.nativeElement;
                            var scrollData = _TextInput.getScrollData(ele.offsetTop, ele.offsetHeight, scrollView.getDimensions(), this.keyboardHeight, this._platform.height());
                            if (scrollData.scrollAmount > -3 && scrollData.scrollAmount < 3) {
                                // the text input is in a safe position that doesn't require
                                // it to be scrolled into view, just set focus now
                                this.setFocus();
                                this.regMove();
                                return;
                            }
                            // add padding to the bottom of the scroll view (if needed)
                            scrollView.addScrollPadding(scrollData.scrollPadding);
                            // manually scroll the text input to the top
                            // do not allow any clicks while it's scrolling
                            var scrollDuration = getScrollAssistDuration(scrollData.scrollAmount);
                            this._app.setEnabled(false, scrollDuration);
                            this._nav && this._nav.setTransitioning(true, scrollDuration);
                            // temporarily move the focus to the focus holder so the browser
                            // doesn't freak out while it's trying to get the input in place
                            // at this point the native text input still does not have focus
                            this.input.relocate(true, scrollData.inputSafeY);
                            // scroll the input into place
                            scrollView.scrollTo(0, scrollData.scrollTo, scrollDuration).then(function () {
                                // the scroll view is in the correct position now
                                // give the native text input focus
                                _this.input.relocate(false);
                                // all good, allow clicks again
                                _this._app.setEnabled(true);
                                _this._nav && _this._nav.setTransitioning(false);
                                _this.regMove();
                            });
                        } else {
                            // not inside of a scroll view, just focus it
                            this.setFocus();
                            this.regMove();
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "setFocus",
                    value: function setFocus() {
                        if (this.input) {
                            this._form.setAsFocused(this);
                            // set focus on the actual input element
                            this.input.setFocus();
                            // ensure the body hasn't scrolled down
                            document.body.scrollTop = 0;
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "regMove",
                    value: function regMove() {
                        var _this2 = this;

                        if (this._assist && this._scrollView) {
                            setTimeout(function () {
                                _this2.deregMove();
                                _this2.deregScroll = _this2._scrollView.addScrollEventListener(_this2.scrollMove);
                            }, 80);
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "deregMove",
                    value: function deregMove() {
                        this.deregScroll && this.deregScroll();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "focusChange",
                    value: function focusChange(hasFocus) {
                        this._renderer.setElementClass(this._elementRef, 'input-focused', hasFocus);
                        if (!hasFocus) {
                            this.deregMove();
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "hasFocus",
                    value: function hasFocus() {
                        return !!this.input && this.input.hasFocus();
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "hasValue",
                    value: function hasValue(inputValue) {
                        var inputHasValue = !!(inputValue && inputValue !== '');
                        this._renderer.setElementClass(this._elementRef, 'input-has-value', inputHasValue);
                    }

                    /**
                     * @private
                     * This function is used to add the Angular css classes associated with inputs in forms
                     */
                }, {
                    key: "hasClass",
                    value: function hasClass(className) {
                        this.input && this.input.hasClass(className);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "ngOnDestroy",
                    value: function ngOnDestroy() {
                        this.deregMove();
                        this._form.deregister(this);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_setInput",
                    set: function set(textInputElement) {
                        var _this3 = this;

                        if (textInputElement) {
                            textInputElement.addClass('item-input');
                            if (this.displayType) {
                                textInputElement.addClass(this.displayType + '-input');
                            }
                            this.input = textInputElement;
                            this.type = textInputElement.type;
                            this.hasValue(this.input.value);
                            textInputElement.valueChange.subscribe(function (inputValue) {
                                _this3.hasValue(inputValue);
                            });
                            this.focusChange(this.hasFocus());
                            textInputElement.focusChange.subscribe(function (hasFocus) {
                                _this3.focusChange(hasFocus);
                            });
                        } else {
                            console.error('<input> or <textarea> elements required within <ion-input>');
                        }
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_setLabel",
                    set: function set(label) {
                        if (label && this.displayType) {
                            label.addClass(this.displayType + '-label');
                        }
                        this.label = label;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_buttons",
                    set: function set(buttons) {
                        buttons.toArray().forEach(function (button) {
                            if (!button.isItem) {
                                button.addClass('item-button');
                            }
                        });
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "_icons",
                    set: function set(icons) {
                        icons.toArray().forEach(function (icon) {
                            icon.addClass('item-icon');
                        });
                    }
                }], [{
                    key: "getScrollData",
                    value: function getScrollData(inputOffsetTop, inputOffsetHeight, scrollViewDimensions, keyboardHeight, plaformHeight) {
                        // compute input's Y values relative to the body
                        var inputTop = inputOffsetTop + scrollViewDimensions.contentTop - scrollViewDimensions.scrollTop;
                        var inputBottom = inputTop + inputOffsetHeight;
                        // compute the safe area which is the viewable content area when the soft keyboard is up
                        var safeAreaTop = scrollViewDimensions.contentTop;
                        var safeAreaHeight = plaformHeight - keyboardHeight - safeAreaTop;
                        safeAreaHeight /= 2;
                        var safeAreaBottom = safeAreaTop + safeAreaHeight;
                        var inputTopWithinSafeArea = inputTop >= safeAreaTop && inputTop <= safeAreaBottom;
                        var inputTopAboveSafeArea = inputTop < safeAreaTop;
                        var inputTopBelowSafeArea = inputTop > safeAreaBottom;
                        var inputBottomWithinSafeArea = inputBottom >= safeAreaTop && inputBottom <= safeAreaBottom;
                        var inputBottomBelowSafeArea = inputBottom > safeAreaBottom;
                        /*
                        Text Input Scroll To Scenarios
                        ---------------------------------------
                        1) Input top within safe area, bottom within safe area
                        2) Input top within safe area, bottom below safe area, room to scroll
                        3) Input top above safe area, bottom within safe area, room to scroll
                        4) Input top below safe area, no room to scroll, input smaller than safe area
                        5) Input top within safe area, bottom below safe area, no room to scroll, input smaller than safe area
                        6) Input top within safe area, bottom below safe area, no room to scroll, input larger than safe area
                        7) Input top below safe area, no room to scroll, input larger than safe area
                        */
                        var scrollData = {
                            scrollAmount: 0,
                            scrollTo: 0,
                            scrollPadding: 0,
                            inputSafeY: 0
                        };
                        if (inputTopWithinSafeArea && inputBottomWithinSafeArea) {
                            // Input top within safe area, bottom within safe area
                            // no need to scroll to a position, it's good as-is
                            return scrollData;
                        }
                        // looks like we'll have to do some auto-scrolling
                        if (inputTopBelowSafeArea || inputBottomBelowSafeArea) {
                            // Input top and bottom below safe area
                            // auto scroll the input up so at least the top of it shows
                            if (safeAreaHeight > inputOffsetHeight) {
                                // safe area height is taller than the input height, so we
                                // can bring it up the input just enough to show the input bottom
                                scrollData.scrollAmount = Math.round(safeAreaBottom - inputBottom);
                            } else {
                                // safe area height is smaller than the input height, so we can
                                // only scroll it up so the input top is at the top of the safe area
                                // however the input bottom will be below the safe area
                                scrollData.scrollAmount = Math.round(safeAreaTop - inputTop);
                            }
                            scrollData.inputSafeY = -(inputTop - safeAreaTop) + 4;
                        } else if (inputTopAboveSafeArea) {
                            // Input top above safe area
                            // auto scroll the input down so at least the top of it shows
                            scrollData.scrollAmount = Math.round(safeAreaTop - inputTop);
                            scrollData.inputSafeY = safeAreaTop - inputTop + 4;
                        }
                        // figure out where it should scroll to for the best position to the input
                        scrollData.scrollTo = scrollViewDimensions.scrollTop - scrollData.scrollAmount;
                        if (scrollData.scrollAmount < 0) {
                            // when auto-scrolling up, there also needs to be enough
                            // content padding at the bottom of the scroll view
                            // manually add it if there isn't enough scrollable area
                            // figure out how many scrollable area is left to scroll up
                            var availablePadding = scrollViewDimensions.scrollHeight - scrollViewDimensions.scrollTop - scrollViewDimensions.contentHeight;
                            var paddingSpace = availablePadding + scrollData.scrollAmount;
                            if (paddingSpace < 0) {
                                // there's not enough scrollable area at the bottom, so manually add more
                                scrollData.scrollPadding = scrollViewDimensions.contentHeight - safeAreaHeight;
                            }
                        }
                        // if (!window.safeAreaEle) {
                        //   window.safeAreaEle = document.createElement('div');
                        //   window.safeAreaEle.style.position = 'absolute';
                        //   window.safeAreaEle.style.background = 'rgba(0, 128, 0, 0.7)';
                        //   window.safeAreaEle.style.padding = '2px 5px';
                        //   window.safeAreaEle.style.textShadow = '1px 1px white';
                        //   window.safeAreaEle.style.left = '0px';
                        //   window.safeAreaEle.style.right = '0px';
                        //   window.safeAreaEle.style.fontWeight = 'bold';
                        //   window.safeAreaEle.style.pointerEvents = 'none';
                        //   document.body.appendChild(window.safeAreaEle);
                        // }
                        // window.safeAreaEle.style.top = safeAreaTop + 'px';
                        // window.safeAreaEle.style.height = safeAreaHeight + 'px';
                        // window.safeAreaEle.innerHTML = `
                        //   <div>scrollTo: ${scrollData.scrollTo}</div>
                        //   <div>scrollAmount: ${scrollData.scrollAmount}</div>
                        //   <div>scrollPadding: ${scrollData.scrollPadding}</div>
                        //   <div>inputSafeY: ${scrollData.inputSafeY}</div>
                        //   <div>scrollHeight: ${scrollViewDimensions.scrollHeight}</div>
                        //   <div>scrollTop: ${scrollViewDimensions.scrollTop}</div>
                        //   <div>contentHeight: ${scrollViewDimensions.contentHeight}</div>
                        // `;
                        return scrollData;
                    }
                }]);

                return TextInput;
            })();

            _export("TextInput", _TextInput);

            __decorate([Input(), __metadata('design:type', Object)], _TextInput.prototype, "clearInput", void 0);
            __decorate([ContentChild(TextInputElement), __metadata('design:type', Object), __metadata('design:paramtypes', [Object])], _TextInput.prototype, "_setInput", null);
            __decorate([ContentChild(Label), __metadata('design:type', Object), __metadata('design:paramtypes', [Object])], _TextInput.prototype, "_setLabel", null);
            __decorate([ContentChildren(Button), __metadata('design:type', Object), __metadata('design:paramtypes', [Object])], _TextInput.prototype, "_buttons", null);
            __decorate([ContentChildren(Icon), __metadata('design:type', Object), __metadata('design:paramtypes', [Object])], _TextInput.prototype, "_icons", null);
            _TextInput = __decorate([Component({
                selector: 'ion-input',
                host: {
                    '(touchstart)': 'pointerStart($event)',
                    '(touchend)': 'pointerEnd($event)',
                    '(mouseup)': 'pointerEnd($event)',
                    'class': 'item',
                    '[class.ng-untouched]': 'hasClass("ng-untouched")',
                    '[class.ng-touched]': 'hasClass("ng-touched")',
                    '[class.ng-pristine]': 'hasClass("ng-pristine")',
                    '[class.ng-dirty]': 'hasClass("ng-dirty")',
                    '[class.ng-valid]': 'hasClass("ng-valid")',
                    '[class.ng-invalid]': 'hasClass("ng-invalid")'
                },
                template: '<div class="item-inner">' + '<ng-content></ng-content>' + '<input [type]="type" aria-hidden="true" scroll-assist *ngIf="_assist">' + '<button clear *ngIf="clearInput && value" class="text-input-clear-icon" (click)="clearTextInput()" (mousedown)="clearTextInput()"></button>' + '</div>',
                directives: [NgIf, forwardRef(function () {
                    return InputScrollAssist;
                }), forwardRef(function () {
                    return TextInputElement;
                }), Button]
            }), __param(6, Optional()), __param(6, Host()), __param(7, Optional()), __param(8, Attribute('floating-label')), __param(9, Attribute('stacked-label')), __param(10, Attribute('fixed-label')), __param(11, Attribute('inset')), __metadata('design:paramtypes', [typeof (_e = typeof Config !== 'undefined' && Config) === 'function' && _e || Object, typeof (_f = typeof Form !== 'undefined' && Form) === 'function' && _f || Object, typeof (_g = typeof Renderer !== 'undefined' && Renderer) === 'function' && _g || Object, typeof (_h = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _h || Object, typeof (_j = typeof IonicApp !== 'undefined' && IonicApp) === 'function' && _j || Object, typeof (_k = typeof Platform !== 'undefined' && Platform) === 'function' && _k || Object, typeof (_l = typeof Content !== 'undefined' && Content) === 'function' && _l || Object, typeof (_m = typeof NavController !== 'undefined' && NavController) === 'function' && _m || Object, String, String, String, String])], _TextInput);
            /**
             * @private
             */

            InputScrollAssist = (function () {
                function InputScrollAssist(_form, _input) {
                    _classCallCheck(this, InputScrollAssist);

                    this._form = _form;
                    this._input = _input;
                }

                _createClass(InputScrollAssist, [{
                    key: "receivedFocus",
                    value: function receivedFocus() {
                        this._form.focusNext(this._input);
                    }
                }]);

                return InputScrollAssist;
            })();

            __decorate([HostListener('focus'), __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', void 0)], InputScrollAssist.prototype, "receivedFocus", null);
            InputScrollAssist = __decorate([Directive({
                selector: '[scroll-assist]'
            }), __metadata('design:paramtypes', [typeof (_o = typeof Form !== 'undefined' && Form) === 'function' && _o || Object, _TextInput])], InputScrollAssist);SCROLL_ASSIST_SPEED = 0.4;
        }
    };
});
System.register("ionic/components/toggle/toggle", ["angular2/core", "angular2/common", "../../util/form", "../../config/config", "../../util/dom"], function (_export) {
    /**
     * @name Toggle
     * @description
     * A toggle technically is the same thing as an HTML checkbox input, except it looks different and is easier to use on a touch device. Ionic prefers to wrap the checkbox input with the `<label>` in order to make the entire toggle easy to tap or drag.
     * Togglees can also have colors assigned to them, by adding any color attribute to them.
     *
     * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/forms/) for more info on forms and input.
     * @property {any} [value] - the inital value of the toggle
     * @property {boolean} [checked] - whether the toggle it toggled or not
     * @property {boolean} [disabled] - whether the toggle is disabled or not
     * @property {string} [id] - a unique ID for a toggle
     * @usage
     * ```html
     * <!-- Create a single toggle -->
     *  <ion-toggle checked="true">
     *    Pineapple
     *  </ion-toggle>
     *
     * <!-- Create a list of togglees -->
     *  <ion-list>
     *
     *    <ion-toggle checked="true">
     *      Apple
     *    </ion-toggle>
     *
     *     <ion-toggle checked="false">
     *       Banana
     *     </ion-toggle>
     *
     *     <ion-toggle disabled="true">
     *       Cherry
     *     </ion-toggle>
     *
     *  </ion-list>
     * ```
     * @demo /docs/v3/demos/toggle/
     * @see {@link /docs/v3/components#toggle Toggle Component Docs}
     */
    "use strict";

    var Component, ElementRef, Renderer, Input, Optional, NgControl, Form, Config, pointerCoord, __decorate, __metadata, __param, Toggle, _a, _b, _c, _d, _e;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            ElementRef = _angular2Core.ElementRef;
            Renderer = _angular2Core.Renderer;
            Input = _angular2Core.Input;
            Optional = _angular2Core.Optional;
        }, function (_angular2Common) {
            NgControl = _angular2Common.NgControl;
        }, function (_utilForm) {
            Form = _utilForm.Form;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_utilDom) {
            pointerCoord = _utilDom.pointerCoord;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Toggle = (function () {
                function Toggle(_form, _elementRef, _renderer, config, ngControl) {
                    _classCallCheck(this, Toggle);

                    this._form = _form;
                    this._elementRef = _elementRef;
                    this._renderer = _renderer;
                    this.value = '';
                    this.checked = false;
                    this.disabled = false;
                    // deprecated warning
                    if (_elementRef.nativeElement.tagName == 'ION-SWITCH') {
                        console.warn('<ion-switch> has been renamed to <ion-toggle>, please update your HTML');
                    }
                    _form.register(this);
                    this.lastTouch = 0;
                    this.mode = config.get('mode');
                    if (ngControl) {
                        ngControl.valueAccessor = this;
                    }
                    var self = this;
                    function pointerMove(ev) {
                        var currentX = pointerCoord(ev).x;
                        if (self.checked) {
                            if (currentX + 15 < self.startX) {
                                self.toggle();
                                self.startX = currentX;
                            }
                        } else if (currentX - 15 > self.startX) {
                            self.toggle();
                            self.startX = currentX;
                        }
                    }
                    function pointerOut(ev) {
                        if (ev.currentTarget === ev.target) {
                            self.pointerUp(ev);
                        }
                    }
                    var toggleEle = _elementRef.nativeElement.querySelector('.toggle-media');
                    this.addMoveListener = function () {
                        toggleEle.addEventListener('touchmove', pointerMove);
                        toggleEle.addEventListener('mousemove', pointerMove);
                        _elementRef.nativeElement.addEventListener('mouseout', pointerOut);
                    };
                    this.removeMoveListener = function () {
                        toggleEle.removeEventListener('touchmove', pointerMove);
                        toggleEle.removeEventListener('mousemove', pointerMove);
                        _elementRef.nativeElement.removeEventListener('mouseout', pointerOut);
                    };
                }

                /**
                 * @private
                 */

                _createClass(Toggle, [{
                    key: "ngOnInit",
                    value: function ngOnInit() {
                        if (!this.id) {
                            this.id = 'tgl-' + this._form.nextId();
                            this._renderer.setElementAttribute(this._elementRef, 'id', this.id);
                        }
                        this.labelId = 'lbl-' + this.id;
                        this._renderer.setElementAttribute(this._elementRef, 'aria-labelledby', this.labelId);
                    }

                    /**
                     * Toggle the checked state of this toggle.
                     */
                }, {
                    key: "toggle",
                    value: function toggle() {
                        this.checked = !this.checked;
                    }
                }, {
                    key: "pointerDown",

                    /**
                     * @private
                     */
                    value: function pointerDown(ev) {
                        if (/touch/.test(ev.type)) {
                            this.lastTouch = Date.now();
                        }
                        if (this.isDisabled(ev)) return;
                        this.startX = pointerCoord(ev).x;
                        this.removeMoveListener();
                        this.addMoveListener();
                        this.isActivated = true;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "pointerUp",
                    value: function pointerUp(ev) {
                        if (this.isDisabled(ev)) return;
                        var endX = pointerCoord(ev).x;
                        if (this.checked) {
                            if (this.startX + 4 > endX) {
                                this.toggle(ev);
                            }
                        } else if (this.startX - 4 < endX) {
                            this.toggle(ev);
                        }
                        this.removeMoveListener();
                        this.isActivated = false;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.checked = value;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "onChange",
                    value: function onChange(val) {}
                    // TODO: figure the whys and the becauses

                    /**
                     * @private
                     */

                }, {
                    key: "onTouched",
                    value: function onTouched(val) {}
                    // TODO: figure the whys and the becauses

                    /**
                     * @private
                     */

                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "ngOnDestroy",
                    value: function ngOnDestroy() {
                        this.removeMoveListener();
                        this.toggleEle = this.addMoveListener = this.removeMoveListener = null;
                        this._form.deregister(this);
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "isDisabled",
                    value: function isDisabled(ev) {
                        return this.lastTouch + 999 > Date.now() && /mouse/.test(ev.type) || this.mode == 'ios' && ev.target.tagName == 'ION-TOGGLE';
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "initFocus",
                    value: function initFocus() {}
                }, {
                    key: "checked",
                    get: function get() {
                        return !!this._checked;
                    },
                    set: function set(val) {
                        this._checked = !!val;
                        this._renderer.setElementAttribute(this._elementRef, 'aria-checked', this._checked);
                        this.onChange(this._checked);
                    }
                }]);

                return Toggle;
            })();

            _export("Toggle", Toggle);

            __decorate([Input(), __metadata('design:type', String)], Toggle.prototype, "value", void 0);
            __decorate([Input(), __metadata('design:type', Object)], Toggle.prototype, "checked", void 0);
            __decorate([Input(), __metadata('design:type', Boolean)], Toggle.prototype, "disabled", void 0);
            __decorate([Input(), __metadata('design:type', String)], Toggle.prototype, "id", void 0);
            _export("Toggle", Toggle = __decorate([Component({
                selector: 'ion-toggle,ion-switch',
                host: {
                    'role': 'checkbox',
                    'class': 'item',
                    'tappable': '',
                    'tabindex': 0,
                    '[attr.aria-disabled]': 'disabled',
                    '(touchstart)': 'pointerDown($event)',
                    '(mousedown)': 'pointerDown($event)',
                    '(touchend)': 'pointerUp($event)',
                    '(mouseup)': 'pointerUp($event)'
                },
                template: '<ng-content select="[item-left]"></ng-content>' + '<div class="item-inner">' + '<ion-item-content id="{{labelId}}">' + '<ng-content></ng-content>' + '</ion-item-content>' + '<div class="toggle-media" [class.toggle-activated]="isActivated" disable-activated>' + '<div class="toggle-icon"></div>' + '</div>' + "</div>"
            }), __param(4, Optional()), __metadata('design:paramtypes', [typeof (_a = typeof Form !== 'undefined' && Form) === 'function' && _a || Object, typeof (_b = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _b || Object, typeof (_c = typeof Renderer !== 'undefined' && Renderer) === 'function' && _c || Object, typeof (_d = typeof Config !== 'undefined' && Config) === 'function' && _d || Object, typeof (_e = typeof NgControl !== 'undefined' && NgControl) === 'function' && _e || Object])], Toggle));
        }
    };
});
System.register("ionic/components/toolbar/toolbar", ["angular2/core", "../ion", "../../config/config", "../navbar/navbar", "../button/button"], function (_export) {
    /**
     * @private
     */
    "use strict";

    var Component, Directive, ElementRef, Optional, forwardRef, Inject, ContentChildren, Ion, Config, Navbar, Button, __decorate, __metadata, __param, ToolbarBase, Toolbar, ToolbarTitle, ToolbarItem, _a, _b, _c, _d, _e, _f;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Core) {
            Component = _angular2Core.Component;
            Directive = _angular2Core.Directive;
            ElementRef = _angular2Core.ElementRef;
            Optional = _angular2Core.Optional;
            forwardRef = _angular2Core.forwardRef;
            Inject = _angular2Core.Inject;
            ContentChildren = _angular2Core.ContentChildren;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            Config = _configConfig.Config;
        }, function (_navbarNavbar) {
            Navbar = _navbarNavbar.Navbar;
        }, function (_buttonButton) {
            Button = _buttonButton.Button;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                    d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            ToolbarBase = (function (_Ion) {
                _inherits(ToolbarBase, _Ion);

                function ToolbarBase(elementRef, config) {
                    _classCallCheck(this, ToolbarBase);

                    _get(Object.getPrototypeOf(ToolbarBase.prototype), "constructor", this).call(this, elementRef, config);
                    this.itemRefs = [];
                    this.titleRef = null;
                }

                /**
                 * @name Toolbar
                 * @description
                 * The toolbar is generic bar that sits above or below content.
                 * Unlike an `Navbar`, `Toolbar` can be used for a subheader as well.
                 * @usage
                 * ```html
                 * <ion-toolbar>
                 *   <ion-title>My Toolbar Title</ion-title>
                 * </ion-toolbar>
                 *
                 *  <ion-content></ion-content>
                 *  ```
                 * @demo /docs/v3/demos/toolbar/
                 * @see {@link ../../navbar/Navbar/ Navbar API Docs}
                 */

                /**
                 * @private
                 */

                _createClass(ToolbarBase, [{
                    key: "setTitleCmp",
                    value: function setTitleCmp(titleCmp) {
                        this.titleCmp = titleCmp;
                    }

                    /**
                     * @private
                     * Returns the toolbar title text if it exists or an empty string
                     */
                }, {
                    key: "getTitleText",
                    value: function getTitleText() {
                        return this.titleCmp && this.titleCmp.getTitleText() || '';
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "getTitleRef",
                    value: function getTitleRef() {
                        return this.titleCmp && this.titleCmp.elementRef;
                    }

                    /**
                     * @private
                     * A toolbar items include the left and right side `ion-buttons`,
                     * and every `menu-toggle`. It does not include the `ion-title`.
                     * @returns {TODO} Array of this toolbar's item ElementRefs.
                     */
                }, {
                    key: "getItemRefs",
                    value: function getItemRefs() {
                        return this.itemRefs;
                    }

                    /**
                     * @private
                     */
                }, {
                    key: "addItemRef",
                    value: function addItemRef(itemElementRef) {
                        this.itemRefs.push(itemElementRef);
                    }
                }]);

                return ToolbarBase;
            })(Ion);

            _export("ToolbarBase", ToolbarBase);

            Toolbar = (function (_ToolbarBase) {
                _inherits(Toolbar, _ToolbarBase);

                function Toolbar(elementRef, config) {
                    _classCallCheck(this, Toolbar);

                    _get(Object.getPrototypeOf(Toolbar.prototype), "constructor", this).call(this, elementRef, config);
                }

                return Toolbar;
            })(ToolbarBase);

            _export("Toolbar", Toolbar);

            _export("Toolbar", Toolbar = __decorate([Component({
                selector: 'ion-toolbar',
                template: '<div class="toolbar-background"></div>' + '<ng-content select="[menuToggle],ion-buttons[left]"></ng-content>' + '<ng-content select="ion-buttons[start]"></ng-content>' + '<ng-content select="ion-buttons[end],ion-buttons[right]"></ng-content>' + '<div class="toolbar-content">' + '<ng-content></ng-content>' + '</div>',
                host: {
                    'class': 'toolbar'
                }
            }), __metadata('design:paramtypes', [typeof (_a = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _a || Object, typeof (_b = typeof Config !== 'undefined' && Config) === 'function' && _b || Object])], Toolbar));
            /**
             * @name Title
             * @description
             * `ion-title` is a component that sets the title of the `Toolbar` or `Navbar`
             * @usage
             * ```html
             * <ion-navbar *navbar>
             *    <ion-title>Tab 1</ion-title>
             * </ion-navbar>
             *
             *<!-- or if you wanted to create a subheader title-->
             * <ion-navbar *navbar>
             *    <ion-title>Tab 1</ion-title>
             * </ion-navbar>
             * <ion-toolbar>
             *   <ion-title>SubHeader</ion-title>
             * </ion-toolbar>
             *  ```
             * @demo /docs/v3/demos/toolbar/
             */

            ToolbarTitle = (function (_Ion2) {
                _inherits(ToolbarTitle, _Ion2);

                function ToolbarTitle(elementRef, toolbar, navbar) {
                    _classCallCheck(this, ToolbarTitle);

                    _get(Object.getPrototypeOf(ToolbarTitle.prototype), "constructor", this).call(this, elementRef, null);
                    toolbar && toolbar.setTitleCmp(this);
                    navbar && navbar.setTitleCmp(this);
                }

                /**
                 * @private
                 */

                _createClass(ToolbarTitle, [{
                    key: "getTitleText",
                    value: function getTitleText() {
                        return this.getNativeElement().textContent;
                    }
                }]);

                return ToolbarTitle;
            })(Ion);

            _export("ToolbarTitle", ToolbarTitle);

            _export("ToolbarTitle", ToolbarTitle = __decorate([Component({
                selector: 'ion-title',
                template: '<div class="toolbar-title">' + '<ng-content></ng-content>' + '</div>'
            }), __param(1, Optional()), __param(2, Optional()), __param(2, Inject(forwardRef(function () {
                return Navbar;
            }))), __metadata('design:paramtypes', [typeof (_c = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _c || Object, Toolbar, typeof (_d = typeof Navbar !== 'undefined' && Navbar) === 'function' && _d || Object])], ToolbarTitle));
            /**
             * @private
             */

            ToolbarItem = (function () {
                function ToolbarItem(elementRef, toolbar, navbar) {
                    _classCallCheck(this, ToolbarItem);

                    toolbar && toolbar.addItemRef(elementRef);
                    navbar && navbar.addItemRef(elementRef);
                    this.inToolbar = !!(toolbar || navbar);
                    // Deprecation warning
                    if (elementRef.nativeElement.tagName === 'ION-NAV-ITEMS') {
                        if (elementRef.nativeElement.hasAttribute('primary')) {
                            console.warn('<ion-nav-items primary> has been renamed to <ion-buttons start>, please update your HTML');
                            elementRef.nativeElement.setAttribute('start', '');
                        } else if (elementRef.nativeElement.hasAttribute('secondary')) {
                            console.warn('<ion-nav-items secondary> has been renamed to <ion-buttons end>, please update your HTML');
                            elementRef.nativeElement.setAttribute('end', '');
                        } else {
                            console.warn('<ion-nav-items> has been renamed to <ion-buttons>, please update your HTML');
                        }
                    }
                }

                _createClass(ToolbarItem, [{
                    key: "_buttons",
                    set: function set(buttons) {
                        if (this.inToolbar) {
                            Button.setRoles(buttons, 'bar-button');
                        }
                    }
                }]);

                return ToolbarItem;
            })();

            _export("ToolbarItem", ToolbarItem);

            __decorate([ContentChildren(Button), __metadata('design:type', Object), __metadata('design:paramtypes', [Object])], ToolbarItem.prototype, "_buttons", null);
            _export("ToolbarItem", ToolbarItem = __decorate([Directive({
                selector: 'ion-buttons,[menuToggle],ion-nav-items'
            }), __param(1, Optional()), __param(2, Optional()), __param(2, Inject(forwardRef(function () {
                return Navbar;
            }))), __metadata('design:paramtypes', [typeof (_e = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _e || Object, Toolbar, typeof (_f = typeof Navbar !== 'undefined' && Navbar) === 'function' && _f || Object])], ToolbarItem));
        }
    };
});
System.register('ionic/config/test/config.spec', ['ionic/ionic'], function (_export) {
    'use strict';

    var Config, Platform, ionicProviders;

    _export('run', run);

    function run() {
        it('should set activator setting to none for old Android Browser on a linux device', function () {
            var config = new Config();
            var platform = new Platform();
            platform.userAgent('Mozilla/5.0 (Linux; U; Android 4.2.2; nl-nl; GT-I9505 Build/JDQ39) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30');
            platform.navigatorPlatform('linux');
            platform.load();
            config.setPlatform(platform);
            expect(config.get('activator')).toEqual('none');
        });
        it('should set activator setting to ripple for Android dev tools simulation on a mac', function () {
            var config = new Config();
            var platform = new Platform();
            platform.userAgent('Mozilla/5.0 (Linux; U; Android 4.2.2; nl-nl; GT-I9505 Build/JDQ39) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30');
            platform.navigatorPlatform('MacIntel');
            platform.load();
            config.setPlatform(platform);
            expect(config.get('activator')).toEqual('ripple');
        });
        it('should set activator setting to none for Android Chrome versions below v36 on a linux device', function () {
            var config = new Config();
            var platform = new Platform();
            platform.userAgent('Mozilla/5.0 (Linux; Android 4.2.2; GT-I9505 Build/JDQ39) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1650.59 Mobile Safari/537.36');
            platform.navigatorPlatform('linux');
            platform.load();
            config.setPlatform(platform);
            expect(config.get('activator')).toEqual('none');
        });
        it('should set activator setting to ripple for Android Chrome v36 and above on a linux device', function () {
            var config = new Config();
            var platform = new Platform();
            platform.userAgent('Mozilla/5.0 (Linux; Android 4.2.2; GT-I9505 Build/JDQ39) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1650.59 Mobile Safari/537.36');
            platform.navigatorPlatform('linux');
            platform.load();
            config.setPlatform(platform);
            expect(config.get('activator')).toEqual('ripple');
        });
        it('should set activator setting to ripple for Android v5.0 and above on a linux device not using Chrome', function () {
            var config = new Config();
            var platform = new Platform();
            platform.userAgent('Mozilla/5.0 (Android 5.0; Mobile; rv:41.0) Gecko/41.0 Firefox/41.0');
            platform.navigatorPlatform('linux');
            platform.load();
            config.setPlatform(platform);
            expect(config.get('activator')).toEqual('ripple');
        });
        it('should set activator setting to none for Android versions below v5.0 on a linux device not using Chrome', function () {
            var config = new Config();
            var platform = new Platform();
            platform.userAgent('Mozilla/5.0 (Android 4.4; Mobile; rv:41.0) Gecko/41.0 Firefox/41.0');
            platform.navigatorPlatform('linux');
            platform.load();
            config.setPlatform(platform);
            expect(config.get('activator')).toEqual('none');
        });
        it('should create a new Config instace when no confg passed in ionicProviders', function () {
            var providers = ionicProviders();
            var config = providers.find(function (provider) {
                return provider.useValue instanceof Config;
            }).useValue;
            expect(config.get('mode')).toEqual('ios');
        });
        it('should used passed in Config instance in ionicProviders', function () {
            var userConfig = new Config({
                mode: 'configInstance'
            });
            var providers = ionicProviders({ config: userConfig });
            var config = providers.find(function (provider) {
                return provider.useValue instanceof Config;
            }).useValue;
            expect(config.get('mode')).toEqual('configInstance');
        });
        it('should create new Config instance from config object in ionicProviders', function () {
            var providers = ionicProviders({ config: {
                    mode: 'configObj'
                } });
            var config = providers.find(function (provider) {
                return provider.useValue instanceof Config;
            }).useValue;
            expect(config.get('mode')).toEqual('configObj');
        });
        it('should override mode settings', function () {
            var config = new Config({
                mode: 'md'
            });
            var platform = new Platform(['ios']);
            config.setPlatform(platform);
            expect(config.get('mode')).toEqual('md');
            expect(config.get('tabbarPlacement')).toEqual('top');
        });
        it('should override mode settings from platforms setting', function () {
            var config = new Config({
                platforms: {
                    ios: {
                        mode: 'md'
                    }
                }
            });
            var platform = new Platform(['ios']);
            config.setPlatform(platform);
            expect(config.get('mode')).toEqual('md');
            expect(config.get('tabbarPlacement')).toEqual('top');
        });
        it('should get boolean value from querystring', function () {
            var config = new Config();
            var platform = new Platform();
            platform.url('http://biff.com/?ionicanimate=true');
            config.setPlatform(platform);
            expect(config.get('animate')).toEqual(true);
            config = new Config();
            platform = new Platform();
            platform.url('http://biff.com/?ionicanimate=false');
            config.setPlatform(platform);
            expect(config.get('animate')).toEqual(false);
        });
        it('should get value from case insensitive querystring key', function () {
            var config = new Config({
                mode: 'a'
            });
            var platform = new Platform();
            platform.url('http://biff.com/?ionicConfigKey=b');
            config.setPlatform(platform);
            expect(config.get('configKey')).toEqual('b');
        });
        it('should get value from querystring', function () {
            var config = new Config({
                mode: 'modeA'
            });
            var platform = new Platform();
            platform.url('http://biff.com/?ionicmode=modeB');
            config.setPlatform(platform);
            expect(config.get('mode')).toEqual('modeB');
        });
        it('should override mode platform', function () {
            var config = new Config({
                mode: 'modeA',
                platforms: {
                    mobile: {
                        mode: 'modeB'
                    },
                    ios: {
                        mode: 'modeC'
                    }
                }
            });
            var platform = new Platform(['mobile']);
            config.setPlatform(platform);
            expect(config.get('mode')).toEqual('modeB');
        });
        it('should override mode', function () {
            var config = new Config({
                mode: 'modeA'
            });
            var platform = new Platform(['core']);
            config.setPlatform(platform);
            expect(config.get('mode')).toEqual('modeA');
        });
        it('should get user settings after user platform settings', function () {
            var config = new Config({
                hoverCSS: true
            });
            var platform = new Platform(['ios']);
            config.setPlatform(platform);
            expect(config.get('hoverCSS')).toEqual(true);
        });
        it('should get ios mode for core platform', function () {
            var config = new Config();
            var platform = new Platform(['core']);
            config.setPlatform(platform);
            expect(config.get('mode')).toEqual('ios');
        });
        it('should get ios mode for ipad platform', function () {
            var config = new Config();
            var platform = new Platform(['mobile', 'ios', 'ipad', 'tablet']);
            config.setPlatform(platform);
            expect(config.get('mode')).toEqual('ios');
        });
        it('should get md mode for windowsphone platform', function () {
            var config = new Config();
            var platform = new Platform(['mobile', 'windowsphone']);
            config.setPlatform(platform);
            expect(config.get('mode')).toEqual('md');
        });
        it('should get md mode for android platform', function () {
            var config = new Config();
            var platform = new Platform(['mobile', 'android']);
            config.setPlatform(platform);
            expect(config.get('mode')).toEqual('md');
        });
        it('should override ios mode config with user platform setting', function () {
            var config = new Config({
                tabbarPlacement: 'hide',
                platforms: {
                    ios: {
                        tabbarPlacement: 'top'
                    }
                }
            });
            var platform = new Platform(['ios']);
            config.setPlatform(platform);
            expect(config.get('tabbarPlacement')).toEqual('top');
        });
        it('should override ios mode config with user setting', function () {
            var config = new Config({
                tabbarPlacement: 'top'
            });
            var platform = new Platform(['ios']);
            config.setPlatform(platform);
            expect(config.get('tabbarPlacement')).toEqual('top');
        });
        it('should get setting from md mode', function () {
            var config = new Config();
            var platform = new Platform(['android']);
            config.setPlatform(platform);
            expect(config.get('tabbarPlacement')).toEqual('top');
        });
        it('should get setting from ios mode', function () {
            var config = new Config();
            var platform = new Platform(['ios']);
            config.setPlatform(platform);
            expect(config.get('tabbarPlacement')).toEqual('bottom');
        });
        it('should set/get platform setting from set()', function () {
            var config = new Config();
            var platform = new Platform(['ios']);
            config.setPlatform(platform);
            config.set('tabbarPlacement', 'bottom');
            config.set('ios', 'tabbarPlacement', 'top');
            expect(config.get('tabbarPlacement')).toEqual('top');
        });
        it('should set/get setting from set()', function () {
            var config = new Config();
            var platform = new Platform(['ios']);
            config.setPlatform(platform);
            config.set('tabbarPlacement', 'top');
            expect(config.get('tabbarPlacement')).toEqual('top');
        });
        it('should set ios platform settings from settings()', function () {
            var config = new Config();
            var platform = new Platform(['ios']);
            config.setPlatform(platform);
            config.settings('ios', {
                key: 'iosValue'
            });
            expect(config.get('key')).toEqual('iosValue');
        });
        it('should set/get mobile setting even w/ higher priority ios', function () {
            var config = new Config();
            var platform = new Platform(['mobile', 'ios']);
            config.setPlatform(platform);
            config.settings({
                key: 'defaultValue',
                platforms: {
                    mobile: {
                        key: 'mobileValue'
                    }
                }
            });
            expect(config.get('key')).toEqual('mobileValue');
        });
        it('should set/get mobile setting even w/ higher priority ios', function () {
            var config = new Config();
            var platform = new Platform(['mobile', 'ios']);
            config.setPlatform(platform);
            config.settings({
                key: 'defaultValue',
                platforms: {
                    mobile: {
                        key: 'mobileValue'
                    }
                }
            });
            expect(config.get('key')).toEqual('mobileValue');
        });
        it('should set/get android setting w/ higher priority than mobile', function () {
            var config = new Config();
            var platform = new Platform(['mobile', 'android']);
            config.setPlatform(platform);
            config.settings({
                key: 'defaultValue',
                platforms: {
                    mobile: {
                        key: 'mobileValue'
                    },
                    android: {
                        key: 'androidValue'
                    }
                }
            });
            expect(config.get('key')).toEqual('androidValue');
        });
        it('should set/get ios setting w/ platforms set', function () {
            var config = new Config();
            var platform = new Platform(['ios']);
            config.setPlatform(platform);
            config.settings({
                key: 'defaultValue',
                platforms: {
                    ios: {
                        key: 'iosValue'
                    },
                    android: {
                        key: 'androidValue'
                    }
                }
            });
            expect(config.get('key')).toEqual('iosValue');
        });
        it('should set/get default setting w/ platforms set, but no platform match', function () {
            var config = new Config();
            config.settings({
                key: 'defaultValue',
                platforms: {
                    ios: {
                        key: 'iosValue'
                    },
                    android: {
                        key: 'androidValue'
                    }
                }
            });
            expect(config.get('key')).toEqual('defaultValue');
        });
        it('should set setting object', function () {
            var config = new Config();
            config.settings({
                name: 'Doc Brown',
                occupation: 'Weather Man'
            });
            expect(config.get('name')).toEqual('Doc Brown');
            expect(config.get('name')).toEqual('Doc Brown');
            expect(config.get('occupation')).toEqual('Weather Man');
            expect(config.get('occupation')).toEqual('Weather Man');
        });
        it('should get null setting', function () {
            var config = new Config();
            expect(config.get('name')).toEqual(null);
            expect(config.get('name')).toEqual(null);
            expect(config.get('occupation')).toEqual(null);
            expect(config.get('occupation')).toEqual(null);
        });
        it('should set/get single setting', function () {
            var config = new Config();
            config.set('name', 'Doc Brown');
            config.set('occupation', 'Weather Man');
            expect(config.get('name')).toEqual('Doc Brown');
            expect(config.get('name')).toEqual('Doc Brown');
            expect(config.get('occupation')).toEqual('Weather Man');
            expect(config.get('occupation')).toEqual('Weather Man');
        });
        it('should init w/ given config settings', function () {
            var config = new Config({
                name: 'Doc Brown',
                occupation: 'Weather Man'
            });
            expect(config.get('name')).toEqual('Doc Brown');
            expect(config.get('occupation')).toEqual('Weather Man');
        });
        it('should get settings object', function () {
            var config = new Config({
                name: 'Doc Brown',
                occupation: 'Weather Man'
            });
            expect(config.settings()).toEqual({
                name: 'Doc Brown',
                occupation: 'Weather Man'
            });
        });
        it('should create default config w/ bad settings value', function () {
            var config = new Config(null);
            expect(config.settings()).toEqual({});
            config = new Config(undefined);
            expect(config.settings()).toEqual({});
            config = new Config();
            expect(config.settings()).toEqual({});
            config = new Config([1, 2, 3]);
            expect(config.settings()).toEqual({});
            config = new Config('im bad, you know it');
            expect(config.settings()).toEqual({});
            config = new Config(8675309);
            expect(config.settings()).toEqual({});
            config = new Config(true);
            expect(config.settings()).toEqual({});
            config = new Config(false);
            expect(config.settings()).toEqual({});
            config = new Config(1);
            expect(config.settings()).toEqual({});
            config = new Config(function () {});
            expect(config.settings()).toEqual({});
        });
    }

    return {
        setters: [function (_ionicIonic) {
            Config = _ionicIonic.Config;
            Platform = _ionicIonic.Platform;
            ionicProviders = _ionicIonic.ionicProviders;
        }],
        execute: function () {}
    };
});
System.register('ionic/platform/test/platform.spec', ['ionic/ionic'], function (_export) {
    'use strict';

    var Platform, ANDROID_UA, IPHONE_UA, IPAD_UA;

    _export('run', run);

    function run() {
        it('should set core as the fallback', function () {
            var platform = new Platform();
            platform.userAgent('idk');
            platform.load();
            expect(platform.is('android')).toEqual(false);
            expect(platform.is('ios')).toEqual(false);
            expect(platform.is('core')).toEqual(true);
        });
        it('should set android via platformOverride, despite ios user agent', function () {
            var platform = new Platform();
            platform.userAgent(IPAD_UA);
            platform.load('android');
            expect(platform.is('android')).toEqual(true);
            expect(platform.is('ios')).toEqual(false);
        });
        it('should get case insensitive querystring value', function () {
            var platform = new Platform();
            platform.url('/?KEY=value');
            expect(platform.query('key')).toEqual('value');
        });
        it('should get querystring value', function () {
            var platform = new Platform();
            platform.url('/?key=value');
            expect(platform.query('key')).toEqual('value');
        });
        it('should set ios via platformOverride, despite android querystring', function () {
            var platform = new Platform();
            platform.url('/?ionicplatform=android');
            platform.load('ios');
            expect(platform.is('android')).toEqual(false);
            expect(platform.is('ios')).toEqual(true);
        });
        it('should set ios via platformOverride', function () {
            var platform = new Platform();
            platform.load('ios');
            expect(platform.is('android')).toEqual(false);
            expect(platform.is('ios')).toEqual(true);
        });
        it('should set android via platformOverride', function () {
            var platform = new Platform();
            platform.load('android');
            expect(platform.is('android')).toEqual(true);
            expect(platform.is('ios')).toEqual(false);
        });
        it('should set ios via querystring', function () {
            var platform = new Platform();
            platform.url('/?ionicplatform=ios');
            platform.load();
            expect(platform.is('mobile')).toEqual(true);
            expect(platform.is('android')).toEqual(false);
            expect(platform.is('ios')).toEqual(true);
            expect(platform.is('tablet')).toEqual(false);
        });
        it('should set ios via querystring, even with android user agent', function () {
            var platform = new Platform();
            platform.url('/?ionicplatform=ios');
            platform.userAgent(ANDROID_UA);
            platform.load();
            expect(platform.is('android')).toEqual(false);
            expect(platform.is('ios')).toEqual(true);
        });
        it('should set android via querystring', function () {
            var platform = new Platform();
            platform.url('/?ionicplatform=android');
            platform.load();
            expect(platform.is('android')).toEqual(true);
            expect(platform.is('ios')).toEqual(false);
        });
        it('should set android via querystring, even with ios user agent', function () {
            var platform = new Platform();
            platform.url('/?ionicplatform=android');
            platform.userAgent(IPHONE_UA);
            platform.load();
            expect(platform.is('android')).toEqual(true);
            expect(platform.is('ios')).toEqual(false);
        });
        it('should set android via user agent', function () {
            var platform = new Platform();
            platform.userAgent(ANDROID_UA);
            platform.load();
            expect(platform.is('mobile')).toEqual(true);
            expect(platform.is('android')).toEqual(true);
            expect(platform.is('ios')).toEqual(false);
        });
        it('should set iphone via user agent', function () {
            var platform = new Platform();
            platform.userAgent(IPHONE_UA);
            platform.load();
            expect(platform.is('mobile')).toEqual(true);
            expect(platform.is('android')).toEqual(false);
            expect(platform.is('ios')).toEqual(true);
            expect(platform.is('iphone')).toEqual(true);
            expect(platform.is('tablet')).toEqual(false);
        });
        it('should set ipad via user agent', function () {
            var platform = new Platform();
            platform.userAgent(IPAD_UA);
            platform.load();
            expect(platform.is('mobile')).toEqual(true);
            expect(platform.is('android')).toEqual(false);
            expect(platform.is('ios')).toEqual(true);
            expect(platform.is('ipad')).toEqual(true);
            expect(platform.is('tablet')).toEqual(true);
        });
    }

    return {
        setters: [function (_ionicIonic) {
            Platform = _ionicIonic.Platform;
        }],
        execute: function () {
            ANDROID_UA = 'Mozilla/5.0 (Linux; Android 5.1.1; Nexus 6 Build/LYZ28E) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.20 Mobile Safari/537.36';
            IPHONE_UA = 'Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4';
            IPAD_UA = 'Mozilla/5.0 (iPad; CPU OS 7_0 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11A465 Safari/9537.53';
        }
    };
});
System.register('ionic/platform/storage/local-storage', ['./storage'], function (_export) {
    /**
     * @name LocalStorage
     * @description
     * The LocalStorage storage engine uses the browser's local storage system for
     * storing key/value pairs.
     *
     * Note: LocalStorage should ONLY be used for temporary data that you can afford to lose.
     * Given disk space constraints on a mobile device, local storage might be "cleaned up"
     * by the operating system (iOS).
     *
     * For guaranteed, long-term storage, use the SqlStorage engine which stores data in a file.
     *
     * @usage
     * ```ts
     * import {Page, Storage, LocalStorage} from 'ionic/ionic';
     * @Page({
     *   template: `<ion-content></ion-content>`
     * });
     * export class MyClass{
     *  constructor(){
     *    this.local = new Storage(LocalStorage);
     *    this.local.set('didTutorial', true);
     *  }
     *}
     *```
     * @demo /docs/v3/demos/local-storage/
     * @see {@link /docs/platform/storage/ Storage Platform Docs}
     */
    'use strict';

    var StorageEngine, LocalStorage;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_storage) {
            StorageEngine = _storage.StorageEngine;
        }],
        execute: function () {
            LocalStorage = (function (_StorageEngine) {
                _inherits(LocalStorage, _StorageEngine);

                function LocalStorage() {
                    _classCallCheck(this, LocalStorage);

                    _get(Object.getPrototypeOf(LocalStorage.prototype), 'constructor', this).call(this);
                }

                /**
                 * Get the value of a key in LocalStorage
                 * @param {String} key the key you want to lookup in LocalStorage
                 */

                _createClass(LocalStorage, [{
                    key: 'get',
                    value: function get(key) {
                        return new Promise(function (resolve, reject) {
                            try {
                                var value = window.localStorage.getItem(key);
                                resolve(value);
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }

                    /**
                     * Set a key value pair and save it to LocalStorage
                     * @param {String} key the key you want to save to LocalStorage
                     * @param {Any} value the value of the key you're saving
                     */
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        return new Promise(function (resolve, reject) {
                            try {
                                window.localStorage.setItem(key, value);
                                resolve();
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }

                    /**
                     * Remove a key from LocalStorage
                     * @param {String} key the key you want to remove from LocalStorage
                     */
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        return new Promise(function (resolve, reject) {
                            try {
                                window.localStorage.removeItem(key);
                                resolve();
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }]);

                return LocalStorage;
            })(StorageEngine);

            _export('LocalStorage', LocalStorage);
        }
    };
});
System.register('ionic/platform/storage/sql', ['./storage', '../../util'], function (_export) {
    'use strict';

    var StorageEngine, util, DB_NAME, SqlStorage;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_storage) {
            StorageEngine = _storage.StorageEngine;
        }, function (_util) {
            util = _util;
        }],
        execute: function () {
            DB_NAME = '__ionicstorage';

            /**
             * SqlStorage uses SQLite or WebSQL (development only!) to store data in a
             * persistent SQL store on the filesystem.
             *
             * This is the preferred storage engine, as data will be stored in appropriate
             * app storage, unlike Local Storage which is treated differently by the OS.
             *
             * For convenience, the engine supports key/value storage for simple get/set and blob
             * storage. The full SQL engine is exposed underneath through the `query` method.
             *
             * @usage
             ```js
             * let storage = new Storage(SqlStorage, options);
             * storage.set('name', 'Max');
             * storage.get('name').then((name) => {
             * });
             *
             * // Sql storage also exposes the full engine underneath
             * storage.query('insert into projects(name, data) values('Cool Project', 'blah')');
             * storage.query('select * from projects').then((resp) => {})
             * ```
             *
             * The `SqlStorage` service supports these options:
             * {
             *   name: the name of the database (__ionicstorage by default)
             *   backupFlag: // where to store the file, default is BACKUP_LOCAL which DOES NOT store to iCloud. Other options: BACKUP_LIBRARY, BACKUP_DOCUMENTS
             *   existingDatabase: whether to load this as an existing database (default is false)
             * }
             *
             */

            SqlStorage = (function (_StorageEngine) {
                _inherits(SqlStorage, _StorageEngine);

                function SqlStorage() {
                    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                    _classCallCheck(this, SqlStorage);

                    _get(Object.getPrototypeOf(SqlStorage.prototype), 'constructor', this).call(this);
                    var dbOptions = util.defaults(options, {
                        name: DB_NAME,
                        backupFlag: SqlStorage.BACKUP_LOCAL,
                        existingDatabase: false
                    });
                    if (window.sqlitePlugin) {
                        var _location = this._getBackupLocation(dbOptions.backupFlag);
                        this._db = window.sqlitePlugin.openDatabase(util.extend({
                            name: dbOptions.name,
                            location: _location,
                            createFromLocation: dbOptions.existingDatabase ? 1 : 0
                        }, dbOptions));
                    } else {
                        console.warn('Storage: SQLite plugin not installed, falling back to WebSQL. Make sure to install cordova-sqlite-storage in production!');
                        this._db = window.openDatabase(dbOptions.name, '1.0', 'database', 5 * 1024 * 1024);
                    }
                    this._tryInit();
                }

                _createClass(SqlStorage, [{
                    key: '_getBackupLocation',
                    value: function _getBackupLocation(dbFlag) {
                        switch (dbFlag) {
                            case SqlStorage.BACKUP_LOCAL:
                                return 2;
                            case SqlStorage.BACKUP_LIBRARY:
                                return 1;
                            case SqlStorage.BACKUP_DOCUMENTS:
                                return 0;
                            default:
                                throw Error('Invalid backup flag: ' + dbFlag);
                        }
                    }

                    // Initialize the DB with our required tables
                }, {
                    key: '_tryInit',
                    value: function _tryInit() {
                        this._db.transaction(function (tx) {
                            tx.executeSql('CREATE TABLE IF NOT EXISTS kv (key text primary key, value text)', [], function (tx, res) {}, function (tx, err) {
                                console.error('Storage: Unable to create initial storage tables', tx, err);
                            });
                        });
                    }

                    /**
                     * Perform an arbitrary SQL operation on the database. Use this method
                     * to have full control over the underlying database through SQL operations
                     * like SELECT, INSERT, and UPDATE.
                     *
                     * @param {string} query the query to run
                     * @param {array} params the additional params to use for query placeholders
                     * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                     */
                }, {
                    key: 'query',
                    value: function query(_query) {
                        var _this = this;

                        var params = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

                        return new Promise(function (resolve, reject) {
                            try {
                                _this._db.transaction(function (tx) {
                                    tx.executeSql(_query, params, function (tx, res) {
                                        resolve({
                                            tx: tx,
                                            res: res
                                        });
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }

                    /**
                     * Get the value in the database identified by the given key.
                     * @param {string} key the key
                     * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                     */
                }, {
                    key: 'get',
                    value: function get(key) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this2._db.transaction(function (tx) {
                                    tx.executeSql("select key, value from kv where key = ? limit 1", [key], function (tx, res) {
                                        if (res.rows.length > 0) {
                                            var item = res.rows.item(0);
                                            resolve(item.value);
                                        }
                                        resolve(null);
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }

                    /**
                    * Set the value in the database for the given key. Existing values will be overwritten.
                    * @param {string} key the key
                    * @param {string} value The value (as a string)
                    * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                    */
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        var _this3 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this3._db.transaction(function (tx) {
                                    tx.executeSql('insert or replace into kv(key, value) values (?, ?)', [key, value], function (tx, res) {
                                        resolve();
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }

                    /**
                    * Remove the value in the database for the given key.
                    * @param {string} key the key
                    * @param {string} value The value (as a string)
                    * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                    */
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        var _this4 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this4._db.transaction(function (tx) {
                                    tx.executeSql('delete from kv where key = ?', [key], function (tx, res) {
                                        resolve();
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }]);

                return SqlStorage;
            })(StorageEngine);

            _export('SqlStorage', SqlStorage);

            SqlStorage.BACKUP_LOCAL = 2;
            SqlStorage.BACKUP_LIBRARY = 1;
            SqlStorage.BACKUP_DOCUMENTS = 0;
        }
    };
});
System.register('ionic/platform/storage/storage', [], function (_export) {
    /**
     * Storage is an easy way to store key/value pairs and other complicated
     * data in a way that uses a variety of storage engines underneath.
     *
     * For most cases, we recommend the SqlStorage system as it will store
     * data in a file in the app's sandbox. LocalStorage should ONLY be used
     * for temporary data as it may be "cleaned up" by the operation system
     * during low disk space situations.
     */
    /**
     * @private
    */
    'use strict';

    var Storage, StorageEngine;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            Storage = (function () {
                function Storage(strategyCls, options) {
                    _classCallCheck(this, Storage);

                    this._strategy = new strategyCls(options);
                }

                /**
                 * @private
                */

                _createClass(Storage, [{
                    key: 'get',
                    value: function get(key) {
                        return this._strategy.get(key);
                    }
                }, {
                    key: 'getJson',
                    value: function getJson(key) {
                        try {
                            return JSON.parse(this._strategy.get(key));
                        } catch (e) {
                            console.warn('Storage getJson(): unable to parse value for key', key, ' as JSON');
                            return null;
                        }
                    }
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        return this._strategy.set(key, value);
                    }
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        return this._strategy.remove(key);
                    }
                }, {
                    key: 'query',
                    value: function query(_query, params) {
                        return this._strategy.query(_query, params);
                    }
                }]);

                return Storage;
            })();

            _export('Storage', Storage);

            StorageEngine = (function () {
                function StorageEngine() {
                    _classCallCheck(this, StorageEngine);
                }

                _createClass(StorageEngine, [{
                    key: 'get',
                    value: function get(key, value) {
                        throw Error("get() not implemented for this storage engine");
                    }
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        throw Error("set() not implemented for this storage engine");
                    }
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        throw Error("remove() not implemented for this storage engine");
                    }
                }, {
                    key: 'query',
                    value: function query(_query2, params) {
                        throw Error("query() not implemented for this storage engine");
                    }
                }]);

                return StorageEngine;
            })();

            _export('StorageEngine', StorageEngine);
        }
    };
});